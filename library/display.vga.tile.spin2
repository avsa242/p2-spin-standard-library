{
    --------------------------------------------
    Filename: display.vga.tile.spin2
    Author: Eric Smith
    Modified by: Jesse Burt
    Description: Tiling VGA text driver
    Started Nov 13, 2019
    Updated Oct 3, 2020
    See end of file for terms of use.
    --------------------------------------------
}

{{
'******************************
'*  VGA tiled image driver
'******************************

Runs in its own COG. See README.txt for theory of operation.

Two variants are provided: an 8 bit palette version and a 32 bit
full color. To select the 8 bit version pass "4" (4 bytes per pixel)
for the bytesperchr parameter; for 32 bit pass "8"

Methods:

start(params)
  Starts the driver. "params" is a pointer to a block of 32 bit parameters longs:
  params[0]: base pin to use for the VGA
  params[1]: pointer to screen buffer
  params[2]: number of columns
  params[3]: number of rows
  params[4]: pointer to font data
  params[5]: font width (for now, must be 8)
  params[6]: font height
  params[7]: pixel clock scaling value ($8000_0000 * pixel_clock / system_clock)
  params[8]: horizontal front porch
  params[9]: hsync pulse length
  params[10]: vertical front porch
  params[11]: vsync lines
  params[12]: vertical back porch
  params[13]: polarity: %00 = both positive, %10 = vertical negative, %01 = horizontal negative
  params[14]: cell size, i.e. bytes per character (1, 2, 4, or 8)
  
  returns 1 + the number of the COG used, or 0 on failure
}}

#include "lib.vgatext.spin2"
#include "lib.terminal.spin2"

CON

    INTENSITY = 80                              ' 0..128

VAR

    long _ptr_dispbuffer
    long _mycog
    long _hw_rev
    long _cell_size, _cols, _rows

OBJ

    smpin   : "core.con.smartpins"

PUB Start(pinbase, ptr_params, ptr_dispbuffer): okay | ptr, tmp

    _cols := long[ptr_params][2]
    _rows := long[ptr_params][3]
    _cell_size := long[ptr_params][15]
    _ptr_dispbuffer := ptr_dispbuffer

' check what kind of hardware we are using
    if _hw_rev == 0
        _hw_rev := check_hw_rev()

    if _hw_rev == 1
' RevA (old) silicon
' change streamer commands
        ptr := @m_bs
        tmp := $CF000000
        long[ptr][0] := tmp                     ' before sync
        long[ptr][1] := tmp                     ' sync
        long[ptr][2] := tmp                     ' before visible
        long[ptr][3] := tmp                     ' visible
        ptr := @m_rf_even
        long[ptr][0] := $8f000000               ' even chars
        long[ptr][1] := $8f010000               ' odd chars (diff. LUT base)
    else
' new silicon
        ptr := @m_bs
        tmp := $7f010000
        long[ptr][0] := tmp
        long[ptr][1] := tmp
        long[ptr][2] := tmp
        long[ptr][3] := tmp
        ptr := @m_rf_even
        long[ptr][0] := $0f000000               ' even characters
        long[ptr][1] := $0f010000               ' odd characters

    resetTerminal()
    _mycog := cogspin(16, @entry, ptr_params) + 1
    return _mycog

PUB Stop()

    if _mycog
        cogstop(_mycog-1)
        _mycog := 0

PRI check_hw_rev(): tmp
' check the hardware revision
' return 1 for original silicon, 2 for new silicon
' the difference is in how setq+rdlong works for ptra offsets;
' ptra++ is applied the appropriate number of times in rev 2 silicon
    tmp := 0
    cogspin(16, @hwcheck, @tmp)
    repeat while tmp == 0
    return tmp
  
CON

    PIXSHIFT            = 31
    LINE_HANDLER        = $1c0                  ' COG mem addr of
    LINE_HANDLER_END    = $1f0                  ' pixel subroutine
  
DAT     
'l      c       i       o                       c/f
                org     0
' on entry to the COG, ptra contains the parameter block, and
' ptrb points to the HUB address of the code (@entry)
entry
' read parameters
basepin_val
                rdlong  basepin_val, ptra++
buffer_base
                rdlong  buffer_base, ptra++
text_cols
                rdlong  text_cols, ptra++
text_rows
                rdlong  text_rows, ptra++
font_base
                rdlong  font_base, ptra++
fnt_width
                rdlong  fnt_width, ptra++
fnt_height
                rdlong  fnt_height, ptra++
fpix_scale
                rdlong  fpix_scale, ptra++
hfront_porch
                rdlong  hfront_porch, ptra++
hsync_pulse
                rdlong  hsync_pulse, ptra++
hback_porch
                rdlong  hback_porch, ptra++
vfront_porch
                rdlong  vfront_porch, ptra++
vsync_pulse
                rdlong  vsync_pulse, ptra++
vback_porch
                rdlong  vback_porch, ptra++
polarity
                rdlong  polarity, ptra++
' this must be either 8 (for 32 bit color) or 4 (for 8 bit color)
bytesperchr
                rdlong  bytesperchr, ptra++

' Setup 
' (this code can be overwritten once we are going)

vga_start
' calculate things based on parameters
char_cnt
                mov     char_cnt, text_cols
strkthru_ln
                shr     char_cnt, #1            ' process 2 chars at a time
vsync_val
                mov     strkthru_ln, fnt_height
stride
                shr     strkthru_ln, #1         ' divide height by 2
stride_chunks
                mov     stride, text_cols
hpixels
                mul     stride, bytesperchr
vpixels
                mov     stride_chunks, stride
ptr_buff
                add     stride_chunks, #63
ptr_fnt
                shr     stride_chunks, #6       ' divide by 64
mycogid
                mov     hpixels, text_cols
fntln_cntr
                mul     hpixels, fnt_width
x
                mov     vpixels, text_rows
y
                mul     vpixels, fnt_height

'l      c       i       o                       c/f
' copy parameters into settings
curchar
                add     m_rf_even, fnt_width
cureff
                add     m_rf_odd, fnt_width
bgcolor
                add     m_bs, hfront_porch
fgcolor
                add     m_sn, hsync_pulse
                add     m_bv, hback_porch
                add     m_vi, hpixels

' put our COG id into the DAC info
                cogid   mycogid
                shl     mycogid, #8
                or      dacmode_s, mycogid
                or      dacmode_c, mycogid

                setxfrq fpix_scale              ' set transfer frequency
                mov     vsync_val, basepin_val
                add     vsync_val, #4
	
        ' set up initial polarity
                test    polarity, #%10          wc
                drvc    vsync_val
                test    polarity, #1            wc
' NOTE: the setcmod instruction puts its argument in the D field (bits 9-17)
' so to set the low bit of the argument, set bit 9 of the instruction
                bitc    cmodval, #9             ' set bit for cmodval
	
' set up level scaling
                setcy   ##INTENSITY << 24       ' r  set colorspace for rgb
                setci   ##INTENSITY << 16       ' g
                setcq   ##INTENSITY << 08       ' b
cmodval
                setcmod #%01_0_000_0            ' enable colorspace conversion
                                                ' note low bit is set above

                wrpin   dacmode_s, basepin_val  ' enable dac modes in pins 0..3
                dirh    basepin_val
                add     basepin_val, #1
                wrpin   dacmode_c, basepin_val
                dirh    basepin_val
                add     basepin_val, #1
                wrpin   dacmode_c, basepin_val
                dirh    basepin_val
                add     basepin_val, #1
                wrpin   dacmode_c, basepin_val
                dirh    basepin_val

' load different routines into upper LUT depending on the bytes per char
' 8, 4, 2, or 1
' ptrb still points at @entry; make it point to the code we want to load
                encod   bytesperchr, bytesperchr' 1, 2, 4, 8 -> 0, 1, 2, 3
                alts    bytesperchr, #ln_offs_tbl   ' look up in ln_offs_tbl
                add     ptrb, 0-0               ' offset for the code to load

' now load the code into LUT
                setq    #(LINE_HANDLER_END-LINE_HANDLER)-1
                rdlong  LINE_HANDLER, ptrb
'l      c       i       o                       c/f
' Field loop
field   
                mov     y, vfront_porch         ' top blanks
                call    #blank
                mov     ptr_buff, buffer_base
                mov     ptr_fnt, font_base
                mov     fntln_cntr, fnt_height
                add     field_cnt, #1
                test    field_cnt, #32          wz
        if_z    mov     field_fx, #$ff
        if_nz   mov     field_fx, #$0f
  
                mov     y, vpixels              ' set visible line
line    
                call    #hsync                  ' do horizontal sync;
                                                ' also loads up next font line

' now read the character data
' this is stored as 8 byte per character;
' two longs, first containing 24 bit color + character glyph,
' second containing the 24 bit color and a reserved field
                rdfast  stride_chunks, ptr_buff

                sub     fntln_cntr, #1          wz
        if_z    mov     fntln_cntr, fnt_height
        if_z    mov     ptr_fnt, font_base
        if_z    add     ptr_buff, stride        ' next line

' check for effects on this line
                mov     line_fx, #$91
                cmp     fntln_cntr, #1          wz
        if_z    or      line_fx, #$22
                cmp     fntln_cntr, strkthru_ln wz
        if_z    or      line_fx, #$44

' turn off blink specific stuff
                and     line_fx, field_fx

' the main loop processes 2 characters (16 pixels) at a time,
' ping-ponging between even and odd
'
' we use LUT elements 0,1 and 32,33 to hold the colors, ping-ponging back
' between them
' we have to use 32,33 because the granularity of changing the streamer
' LUT pointer is 5 bits
                call    #\LINE_HANDLER          ' call the pixel loop
                djnz    y, #line

end_of_line
                mov     y, vback_porch          ' bottom blanks
                call    #blank

                drvnot  vsync_val               ' sync on

                mov     y, vsync_pulse          ' sync blanks
                call    #blank

                drvnot  vsync_val               ' sync off

                jmp     #field                  ' loop

	
' Subroutines
blank           call    #hsync                  ' blank lines
                xcont   m_vi, #0
    _ret_       djnz    y, #blank

hsync           xcont   m_bs, #0                ' horizontal sync
                xcont   m_sn, #1
                xcont   m_bv, #0
                setq    #63                     ' read 64 longs from font table
                rdlong  fnt_ln, ptr_fnt
    _ret_       add     ptr_fnt, #256

' Initialized data
dacmode_s       long    smpin.DAC_123OHM_3V3 | smpin.OUTPUT_ENABLED
dacmode_c       long    smpin.DAC_75OHM_2V0 | smpin.OUTPUT_ENABLED

m_bs            long    $7F010000{+HFRONT_PORCH}' before sync
m_sn            long    $7F010000{+HSYNC}       ' sync
m_bv            long    $7F010000{+HBACK_PORCH} ' before visible
m_vi            long    $7F010000{+HPIXELS}     ' visible

m_rf_even       long    $0F000000{+FONT_WIDTH}  ' 1bpp
m_rf_odd        long    $0F010000{+FONT_WIDTH}  ' 1bpp LUT immediate

' active character effects for this line
' these bits have the following meanings:
'    01 = hide (show all fgground color)
'    02 = underline
'    04 = strikethrough
'    08 = reserved
'    10 = blinking hide
'    20 = blinking underline
'    40 = blinking strikethrough
'    80 = if hidden, use bgcolor instead of fgcolor

line_fx         long    0

' active effects for this field; the blinking ones will be turned off
' on half of the fields
field_fx        long    0

' count of elapsed fields, used for blinking
field_cnt       long    0

' standard ANSI 256 color palette
color_plt
	long	$00000000, $80000000, $00800000, $80800000, $00008000, $80008000, $00808000, $c0c0c000
	long	$80808000, $ff000000, $00ff0000, $ffff0000, $0000ff00, $ff00ff00, $00ffff00, $ffffff00
	long	$00000000, $00003300, $00006600, $00009900, $0000cc00, $0000ff00, $00330000, $00333300
	long	$00336600, $00339900, $0033cc00, $0033ff00, $00660000, $00663300, $00666600, $00669900
	long	$0066cc00, $0066ff00, $00990000, $00993300, $00996600, $00999900, $0099cc00, $0099ff00
	long	$00cc0000, $00cc3300, $00cc6600, $00cc9900, $00cccc00, $00ccff00, $00ff0000, $00ff3300
	long	$00ff6600, $00ff9900, $00ffcc00, $00ffff00, $33000000, $33003300, $33006600, $33009900
	long	$3300cc00, $3300ff00, $33330000, $33333300, $33336600, $33339900, $3333cc00, $3333ff00
	long	$33660000, $33663300, $33666600, $33669900, $3366cc00, $3366ff00, $33990000, $33993300
	long	$33996600, $33999900, $3399cc00, $3399ff00, $33cc0000, $33cc3300, $33cc6600, $33cc9900
	long	$33cccc00, $33ccff00, $33ff0000, $33ff3300, $33ff6600, $33ff9900, $33ffcc00, $33ffff00
	long	$66000000, $66003300, $66006600, $66009900, $6600cc00, $6600ff00, $66330000, $66333300
	long	$66336600, $66339900, $6633cc00, $6633ff00, $66660000, $66663300, $66666600, $66669900
	long	$6666cc00, $6666ff00, $66990000, $66993300, $66996600, $66999900, $6699cc00, $6699ff00
	long	$66cc0000, $66cc3300, $66cc6600, $66cc9900, $66cccc00, $66ccff00, $66ff0000, $66ff3300
	long	$66ff6600, $66ff9900, $66ffcc00, $66ffff00, $99000000, $99003300, $99006600, $99009900
	long	$9900cc00, $9900ff00, $99330000, $99333300, $99336600, $99339900, $9933cc00, $9933ff00
	long	$99660000, $99663300, $99666600, $99669900, $9966cc00, $9966ff00, $99990000, $99993300
	long	$99996600, $99999900, $9999cc00, $9999ff00, $99cc0000, $99cc3300, $99cc6600, $99cc9900
	long	$99cccc00, $99ccff00, $99ff0000, $99ff3300, $99ff6600, $99ff9900, $99ffcc00, $99ffff00
	long	$cc000000, $cc003300, $cc006600, $cc009900, $cc00cc00, $cc00ff00, $cc330000, $cc333300
	long	$cc336600, $cc339900, $cc33cc00, $cc33ff00, $cc660000, $cc663300, $cc666600, $cc669900
	long	$cc66cc00, $cc66ff00, $cc990000, $cc993300, $cc996600, $cc999900, $cc99cc00, $cc99ff00
	long	$cccc0000, $cccc3300, $cccc6600, $cccc9900, $cccccc00, $ccccff00, $ccff0000, $ccff3300
	long	$ccff6600, $ccff9900, $ccffcc00, $ccffff00, $ff000000, $ff003300, $ff006600, $ff009900
	long	$ff00cc00, $ff00ff00, $ff330000, $ff333300, $ff336600, $ff339900, $ff33cc00, $ff33ff00
	long	$ff660000, $ff663300, $ff666600, $ff669900, $ff66cc00, $ff66ff00, $ff990000, $ff993300
	long	$ff996600, $ff999900, $ff99cc00, $ff99ff00, $ffcc0000, $ffcc3300, $ffcc6600, $ffcc9900
	long	$ffcccc00, $ffccff00, $ffff0000, $ffff3300, $ffff6600, $ffff9900, $ffffcc00, $ffffff00
	long	$08080800, $12121200, $1c1c1c00, $26262600, $30303000, $3a3a3a00, $44444400, $4e4e4e00
	long	$58585800, $62626200, $6c6c6c00, $76767600, $80808000, $8a8a8a00, $94949400, $9e9e9e00
	long	$a8a8a800, $b2b2b200, $bcbcbc00, $c6c6c600, $d0d0d000, $dadada00, $e4e4e400, $eeeeee00

' space for 256 bytes of font data
fnt_ln          long    0[64]

' table of offsets to the character handling subroutines
ln_offs_tbl
                long    @char1_loop - @entry
                long    @char2_loop - @entry
                long    @char4_loop - @entry
                long    @char8_loop - @entry

                orgf    LINE_HANDLER

                fit     LINE_HANDLER_END
	
' LUT subroutines
' all of these should process a whole line of
' output
'
' timing: generally speaking we process an even
' and odd character (16 pixels) at a time
' assuming a 250 MHz system clock this gives us
' the following requirements:

' 640x480 25 MHz pixel clock: 10 cycles/pixel
'              so 5*16 == 80 instructions
' 800x600 40 MHz pixel clock:  6 cycles/pixel
'              so 3*16 == 48 instructions
' 1024x768 65 MHz pixel clock: 3.75 cycles/pixel
'              or roughly 30 instructions
'
' for a 160 MHz system clock:
' 640x480:  50 instructions
' 800x600:  32 instructions
' 1024x768: 19 instructions

' 8 bytes/character
' 24 instructions
                org     LINE_HANDLER
char8_loop
                rep     @end_32bppchar, char_cnt
next_32bppchar
' even pixel
                rflong  fgcolor
                rflong  bgcolor
                getbyte curchar, fgcolor, #0
                test    bgcolor, line_fx        wz

                andn    fgcolor, #$FF
                andn    bgcolor, #$FF
                altgb   curchar, #fnt_ln        ' fetch from font table
                getbyte curchar

        if_nz   or      curchar, #$ff           ' if effect mask active add line
                xcont   m_rf_even, curchar
                wrlut   bgcolor, #0
                wrlut   fgcolor, #1

' odd pixel
                rflong  fgcolor
                rflong  bgcolor
                getbyte curchar, fgcolor, #0
                test    bgcolor, line_fx        wz

                andn    fgcolor, #$FF
                andn    bgcolor, #$FF           ' handle in the glyphat code
                altgb   curchar, #fnt_ln        ' fetch from font table
                getbyte curchar

        if_nz   or      curchar, #$ff           ' if effect mask active add line
                xcont   m_rf_odd, curchar
                wrlut   bgcolor, #32
                wrlut   fgcolor, #33

' end of loop
end_32bppchar
                ret

                fit     LINE_HANDLER_END

' 4 bytes/char
' 30 instructions
	
                org     LINE_HANDLER
char4_loop
                rep     @end_8bppchar, char_cnt
next_8bppchar
	' even character
                rfbyte  fgcolor
                rfbyte  bgcolor
                rfbyte  curchar
                rfbyte  cureff                  wc

' do table lookup on colors
                alts    fgcolor, #color_plt
                mov     fgcolor, 0-0
                alts    bgcolor, #color_plt
                mov     bgcolor, 0-0

                altgb   curchar, #fnt_ln        ' fetch from font table
                getbyte curchar
                and     cureff, line_fx         wz

        if_nz   muxnc   curchar, #$ff           ' if effect mask active add line
                xcont   m_rf_even, curchar
                wrlut   bgcolor, #0
                wrlut   fgcolor, #1

' odd character
                rfbyte  fgcolor
                rfbyte  bgcolor
                rfbyte  curchar
                rfbyte  cureff                  wc

' do table lookup on colors
                alts    fgcolor, #color_plt
                mov     fgcolor, 0-0
                alts    bgcolor, #color_plt
                mov     bgcolor, 0-0

                altgb   curchar, #fnt_ln        ' fetch from font table
                getbyte curchar
                and     cureff, line_fx         wz

        if_nz   muxnc   curchar, #$ff           ' if effect mask active add line
                xcont   m_rf_odd, curchar
                wrlut   bgcolor, #32
                wrlut   fgcolor, #33
end_8bppchar
                ret
                fit     LINE_HANDLER_END

' 2 bytes/char
' this consists of an 8 bit character followed by
' 8 bit effects; 1 bit blink, 3 bits bg color, 4 bits fg color
'
' 30 instructions
                org     LINE_HANDLER
char2_loop
                and     line_fx, #$80
                rep     @end_char16, char_cnt
next_char16

' even character
                rfbyte  curchar
                rfbyte  cureff                  wc
                getnib  fgcolor, cureff, #0
                getnib  bgcolor, cureff, #1

' do table lookup on colors
                alts    fgcolor, #color_plt
                mov     fgcolor, 0-0
                alts    bgcolor, #color_plt
                mov     bgcolor, 0-0

                altgb   curchar, #fnt_ln        ' fetch from font table
                getbyte curchar
                test    cureff, line_fx         wz
        if_nz   xor     curchar, #$ff           ' if effect mask active add line

                xcont   m_rf_even, curchar
                wrlut   bgcolor, #0
                wrlut   fgcolor, #1

' odd character
                rfbyte  curchar
                rfbyte  cureff                  wc
                getnib  fgcolor, cureff, #0
                getnib  bgcolor, cureff, #1

' do table lookup on colors
                alts    fgcolor, #color_plt
                mov     fgcolor, 0-0
                alts    bgcolor, #color_plt
                mov     bgcolor, 0-0

                altgb   curchar, #fnt_ln        ' fetch from font table
                getbyte curchar
                test    cureff, line_fx         wz
        if_nz   xor     curchar, #$ff           ' if effect mask active add line

                xcont   m_rf_odd, curchar
                wrlut   bgcolor, #32
                wrlut   fgcolor, #33
end_char16
                ret
                fit     LINE_HANDLER_END

' 1 bytes/char
' this consists of an 7 bit character; the high bit is
' used for blinking
'
' 16 instructions
                org     LINE_HANDLER
char1_loop
                mov     fgcolor, color_plt+7
                mov     bgcolor, color_plt
                wrlut   bgcolor, #0
                wrlut   fgcolor, #1
                wrlut   bgcolor, #32
                wrlut   fgcolor, #33
                and     line_fx, #$80

                rep     @end_char8, char_cnt
next_char8

' even character
                rfbyte  curchar
                mov     cureff, curchar
                and     curchar, #$7f
                and     cureff, line_fx         wz

                altgb   curchar, #fnt_ln        ' fetch from font table
                getbyte curchar

        if_nz   xor     curchar, #$ff           ' if effect mask active add line
                xcont   m_rf_even, curchar

' odd character
                rfbyte  curchar
                mov     cureff, curchar
                and     curchar, #$7f
                and     cureff, line_fx         wz

                altgb   curchar, #fnt_ln        ' fetch from font table
                getbyte curchar

        if_nz   xor     curchar, #$ff           ' if effect mask active add line
                xcont   m_rf_odd, curchar

' end of loop
end_char8
                ret
                fit     LINE_HANDLER_END

DAT

'l      c       i       o                       c/f
	            org     0
' code used to check hardware revision
' in rev A (the original silicon) setq + rdlong pa, ptrb++ 
'  increments ptrb only once
' in rev B (revised silicon) it will increment ptrb appropriately
'
hwcheck
                mov     pb, ptrb
                setq    #1
                rdlong  $1e0, ptrb++
                subr    pb, ptrb
                shr     pb, #2                  wz
        if_z    mov     pb, #1
                wrlong  pb, ptra
                cogid   pa
                cogstop pa

