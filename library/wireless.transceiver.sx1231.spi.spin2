{
    --------------------------------------------
    Filename: wireless.transceiver.sx1231.spi.spin2
    Author: Jesse Burt
    Description: Driver for the Semtech SX1231 UHF Transceiver IC (P2 version)
    Copyright (c) 2020
    Started Apr 21, 2020
    Updated Jun 22, 2020
    See end of file for terms of use.
    --------------------------------------------
}

CON

' SX1231 Oscillator Frequency
    FXOSC                   = 32_000_000
    FSTEP                   = FXOSC / (1 << 19)

' Sequencer operating modes
    OPMODE_AUTO             = 0
    OPMODE_MANUAL           = 1

    OPMODE_SLEEP            = 0
    OPMODE_STDBY            = 1
    OPMODE_FS               = 2
    OPMODE_TX               = 3
    OPMODE_RX               = 4

' Data processing modes
    DATAMODE_PACKET         = 0
    DATAMODE_CONT_W_SYNC    = 2
    DATAMODE_CONT_WO_SYNC   = 3

' Modulation types
    MOD_FSK                 = 0
    MOD_OOK                 = 1

' Gaussian modulation shaping filters
    BT_NONE                 = 0
    BT_1_0                  = 1
    BT_0_5                  = 2
    BT_0_3                  = 3

' AFC method/routine
    AFC_STANDARD            = 0
    AFC_IMPROVED            = 1

' LNA Gain
    LNA_AGC                 = 0
    LNA_HIGH                = 1

' Sync word read/write operation
    SW_READ                 = 0
    SW_WRITE                = 1

' DC-free encoding/decoding
    DCFREE_NONE             = %00
    DCFREE_MANCH            = %01
    DCFREE_WHITE            = %10

' Address matching
    ADDRCHK_NONE            = %00
    ADDRCHK_CHK_NO_BCAST    = %01
    ADDRCHK_CHK_BCAST       = %10

' Intermediate modes
    IMODE_SLEEP             = %00
    IMODE_STBY              = %01
    IMODE_RX                = %10
    IMODE_TX                = %11

' Conditions for entering and exiting intermediate modes
    ENTCOND_NONE            = %000
    ENTCOND_FIFONOTEMPTY    = %001
    ENTCOND_FIFOLVL         = %010
    ENTCOND_CRCOK           = %011
    ENTCOND_PAYLDRDY        = %100
    ENTCOND_SYNCADD         = %101
    ENTCOND_PKTSENT         = %110
    ENTCOND_FIFOEMPTY       = %111

    EXITCOND_NONE           = %000
    EXITCOND_FIFOEMPTY      = %001
    EXITCOND_FIFOLVL        = %010
    EXITCOND_CRCOK          = %011
    EXITCOND_PAYLDRDY       = %100
    EXITCOND_SYNCADD        = %101
    EXITCOND_PKTSENT        = %110
    EXITCOND_TIMEOUT        = %111

' Conditions for starting packet transmission
    TXSTART_FIFOLVL         = 0
    TXSTART_FIFONOTEMPTY    = 1

' AES Key
    KEY_RD                  = 0
    KEY_WR                  = 1

' Packet length config
    PKTLEN_FIXED            = 0
    PKTLEN_VAR              = 1

' Constants for compatibility with other drivers
    IDLE_RXTX               = 0
    SYNCMODE_3032_CS        = 0
    AGC_OFF                 = 0

VAR

    byte _CS, _MOSI, _MISO, _SCK

OBJ

'    spi : "com.spi"
    spi : "com.spi.bitbang-fast"
    core: "core.con.sx1231"
    time: "time"                                                    'Basic timing functions
    io  : "io"

PUB Null()
''This is not a top-level object

PUB Start(CS_PIN, SCK_PIN, MOSI_PIN, MISO_PIN, SCK_FREQ=1_000_000): okay | tmp

    if lookdown(CS_PIN: 0..63) and lookdown(SCK_PIN: 0..63) and lookdown(MOSI_PIN: 0..63) and lookdown(MISO_PIN: 0..63) and SCK_FREQ > 0 and SCK_FREQ =< core.SCK_MAX_FREQ
        if okay := spi.start (MOSI_PIN, MISO_PIN, SCK_PIN, SCK_FREQ, 0) 'SPI Object Started?
            _CS := CS_PIN
            _MOSI := MOSI_PIN
            _MISO := MISO_PIN
            _SCK := SCK_PIN

            io.High(_CS)
            io.Output(_CS)

            time.MSleep (10)

            tmp := DeviceID()
            if lookdown(tmp: $21, $22, $23, $24)             'Is it really an SX1231?
                return okay

    return                                                    'If we got here, something went wrong

PUB Stop()

'    spi.stop

PUB Defaults() | tmp[4]
' Factory defaults
    AddressCheck(ADDRCHK_NONE)
    AFCAuto(FALSE)
    AFCMethod(AFC_STANDARD)
    AutoRestartRX(TRUE)
    BroadcastAddress($00)
    CarrierFreq(915_000_000)
    CRCCheckEnabled(TRUE)
    DataMode(DATAMODE_PACKET)
    DataRate(4800)
    DataWhitening(FALSE)
    Encryption(FALSE)
    bytefill(@tmp, $00, 16)
    EncryptionKey(KEY_WR, @tmp)
    EnterCondition(ENTCOND_NONE)
    ExitCondition(EXITCOND_NONE)
    FIFOThreshold(15)
    FreqDeviation(5000)
    GaussianFilter(BT_NONE)
    IntermediateMode(IMODE_SLEEP)
    Listen(FALSE)
    LNAGain(LNA_AGC)
    LNAZInput(200)
    LowBattLevel(1_835)
    LowBattMon(FALSE)
    ManchesterEnc(FALSE)
    Modulation(MOD_FSK)
    NodeAddress($00)
    OCPCurrent(95)
    OpMode(OPMODE_STDBY)
    OvercurrentProtection(TRUE)
    PayloadLen(64)
    PayloadLenCfg(PKTLEN_FIXED)
    PreambleLen(3)
    RampTime(40)
    RXBandwidth(10_400)
    Sequencer(OPMODE_AUTO)
    bytefill(@tmp, $01, 8)
    SyncWord(SW_WRITE, @tmp)
    SyncWordEnabled(TRUE)
    SyncWordLength(4)
    SyncWordMaxBitErr(0)
    TXPower(13)
    TXStartCondition(TXSTART_FIFONOTEMPTY)

PUB AbortListen() | tmp
' Abort listen mode when used together with Listen(FALSE)
    readReg (core.OPMODE, 1, @tmp)
    tmp &= core.MASK_LISTENABORT
    tmp := (tmp | (1 << core.FLD_LISTENABORT)) & core.OPMODE_MASK
    writeReg (core.OPMODE, 1, @tmp)

PUB AddressCheck(mode=-2): result | tmp
' Enable address checking/matching/filtering
'   Valid values:
'       ADDRCHK_NONE (%00): No address check
'       ADDRCHK_CHK_NO_BCAST (%01): Check address, but ignore broadcast addresses
'       ADDRCHK_CHK_00_BCAST (%10): Check address, and also respond to broadcast address
'   Any other value polls the chip and returns the current setting
    tmp := $00
    readReg(core.PACKETCONFIG1, 1, @tmp)
    case mode
        ADDRCHK_NONE, ADDRCHK_CHK_NO_BCAST, ADDRCHK_CHK_BCAST:
            mode <<= core.FLD_ADDRESSFILTERING
        OTHER:
            result := ((tmp >> core.FLD_ADDRESSFILTERING) & core.BITS_ADDRESSFILTERING)
            return

    tmp &= core.MASK_ADDRESSFILTERING
    tmp := (tmp | mode) & core.PACKETCONFIG1_MASK
    writeReg(core.PACKETCONFIG1, 1, @tmp)

PUB AFCAuto(enabled=-2): result | tmp
' Enable automatic AFC
'   Valid values: TRUE (-1 or 1), FALSE (0)
'   Any other value polls the chip and returns the current setting
    tmp := $00
    readReg(core.AFCFEI, 1, @tmp)
    case abs(enabled)
        0, 1:
            enabled := (abs(enabled) << core.FLD_AFCAUTOON)
        OTHER:
            result := ((tmp >> core.FLD_AFCAUTOON) & %1) * TRUE
            return

    tmp &= core.MASK_AFCAUTOON
    tmp := (tmp | enabled) & core.AFCFEI_MASK
    writeReg(core.AFCFEI, 1, @tmp)

PUB AFCComplete(): result
' AFC (auto or manual) completed
'   Returns: TRUE if complete, FALSE otherwise
    readReg (core.AFCFEI, 1, @result)
    result := ((result >> core.FLD_AFCDONE) & %1) * TRUE

PUB AFCMethod(method=-2): result | tmp
' Set AFC method/routine
'   Valid values:
'       AFC_STANDARD (0): Standard AFC routine
'       AFC_IMPROVED (1): Improved AFC routine, for signals with modulation index < 2
'   Any other value polls the chip and returns the current setting
    readReg (core.AFCCTRL, 1, @tmp)
    case method
        AFC_STANDARD, AFC_IMPROVED:
            method := method << core.FLD_AFCLOWBETAON
        OTHER:
            result := (tmp >> core.FLD_AFCLOWBETAON) & %1
            return

    tmp := (tmp | method) & core.AFCCTRL_MASK
    writeReg (core.AFCCTRL, 1, @tmp)

PUB AFCOffset(): result | tmp
' Read AFC frequency offset
'   Returns: Frequency offset in Hz
    tmp := $00
    readReg(core.AFCMSB, 2, @tmp)
    if tmp & $8000
        result := (65536-tmp) * FSTEP
    else
        result := tmp * FSTEP
    return

PUB AFCStart() | tmp
' Trigger a manual AFC
    readReg (core.AFCFEI, 1, @tmp)
    tmp |= %1   '1 << core.FLD_AFCSTART
    writeReg (core.AFCFEI, 1, @tmp)

PUB AfterRX(next_state): result
' Defines the state the radio transitions to after a packet is successfully received
    result := IntermediateMode(next_state)

PUB AfterTX(next_state): result
' Defines the state the radio transitions to after a packet is successfully transmitted
    result := IntermediateMode(next_state)

PUB AGCFilterLength(param)
' dummy method

PUB AGCMode(param)
' dummy method

PUB AppendStatus(param)
' dummy method

PUB AutoCal(param)
' dummy method

PUB AutoRestartRX(enabled=-2): result | tmp
' Enable automatic RX restart (RSSI phase)
'   Valid values: TRUE (-1 or 1), FALSE (0)
'   Any other value polls the chip and returns the current setting
'   NOTE: Restart occurs after payload is ready and the packet has been read from the FIFO
    tmp := $00
    readReg(core.PACKETCONFIG2, 1, @tmp)
    case abs(enabled)
        0, 1:
            enabled := abs(enabled) << core.FLD_AUTORESTARTRXON
        OTHER:
            result := ((tmp >> core.FLD_AUTORESTARTRXON) & %1) * TRUE
            return

    tmp &= core.MASK_AUTORESTARTRXON
    tmp := (tmp | enabled) & core.PACKETCONFIG2_MASK
    writeReg(core.PACKETCONFIG2, 1, @tmp)

PUB BattLow(): result
' Battery low detector
'   Returns TRUE if battery low, FALSE otherwise
    readReg (core.LOWBAT, 1, @result)
    result := ((result >> core.FLD_LOWBATMONITOR) & %1)* TRUE

PUB BroadcastAddress(addr=-2): result | tmp
' Set broadcast address
'   Valid values: $00..$FF
'   Any other value polls the chip and returns the current setting
    tmp := $00
    readReg (core.BROADCASTADRS, 1, @tmp)
    case addr
        $00..$FF:
        OTHER:
            result := tmp
            return

    writeReg (core.BROADCASTADRS, 1, @addr)

PUB CarrierFreq(Hz=-2): result | tmp
' Set Carrier frequency, in Hz
'   Valid values:
'       290_000_000..340_000_000, 424_000_000..510_000_000, 862_000_000..1_020_000_000
'   Any other value polls the chip and returns the current setting
'   NOTE: Set value will be rounded
    readReg (core.FRFMSB, 3, @tmp)
    case Hz
        290_000_000..340_000_000, 424_000_000..510_000_000, 862_000_000..1_020_000_000:
            Hz := Hz / FSTEP
            Hz &= core.BITS_FRF
        OTHER:
            result := tmp & core.BITS_FRF
            result := tmp * FSTEP
            return

    tmp := Hz & core.BITS_FRF
    writeReg (core.FRFMSB, 3, @tmp)

PUB CarrierSense(param)
' dummy method

PUB Channel(param)
' dummy method

PUB CRCCheckEnabled(enabled=-2): result | tmp
' Enable CRC calculation (TX) and checking (RX)
'   Valid values: TRUE (-1 or 1), FALSE (0)
'   Any other value polls the chip and returns the current setting
    tmp := $00
    readReg(core.PACKETCONFIG1, 1, @tmp)
    case abs(enabled)
        0, 1:
            enabled := (abs(enabled) & %1) << core.FLD_CRCON
        OTHER:
            result := ((tmp >> core.FLD_CRCON) & %1) * TRUE
            return

    tmp &= core.MASK_CRCON
    tmp := (tmp | enabled) & core.PACKETCONFIG1_MASK
    writeReg(core.PACKETCONFIG1, 1, @tmp)

PUB CRCLength(param)
' dummy method

PUB DataMode(mode=-2): result | tmp
' Set data processing mode
'   Valid values:
'       DATAMODE_PACKET (0): Packet mode
'       DATAMODE_CONT_W_SYNC (2): Continuous mode with bit synchronizer
'       DATAMODE_CONT_WO_SYNC (3): Continuous mode without bit synchronizer
'   Any other value polls the chip and returns the current setting
    readReg (core.DATAMODUL, 1, @tmp)
    case mode
        DATAMODE_PACKET, DATAMODE_CONT_W_SYNC, DATAMODE_CONT_WO_SYNC:
            mode := mode << core.FLD_DATAMODE
        OTHER:
            result := (tmp >> core.FLD_DATAMODE) & core.BITS_DATAMODE
            return result

    tmp &= core.MASK_DATAMODE
    tmp := (tmp | mode) & core.DATAMODUL_MASK
    writeReg (core.DATAMODUL, 1, @tmp)

PUB DataRate(bps=-2): result | tmp
' Set on-air data rate, in bits per second
'   Valid values:
'       1_200..300_000
'   Any other value polls the chip and returns the current setting
'   NOTE: Result will be rounded
'   NOTE: Effective data rate will be halved if Manchester encoding is used
    readReg (core.BITRATEMSB, 2, @tmp)
    case bps
        1_200..300_000:
            bps := FXOSC / bps
        OTHER:
            result := tmp
            return FXOSC / result

    tmp := bps & core.BITS_BITRATE
    writeReg (core.BITRATEMSB, 2, @tmp)
    return tmp

PUB DataWhitening(enabled=-2): result | tmp
' Enable data whitening
'   Valid values: TRUE (-1 or 1), FALSE (0)
'   Any other value polls the chip and returns the current setting
'   NOTE: This setting and ManchesterEnc are mutually exclusive; enabling this will disable ManchesterEnc
    tmp := $00
    readReg(core.PACKETCONFIG1, 1, @tmp)
    case abs(enabled)
        0:
        1:
            enabled := DCFREE_WHITE << core.FLD_DCFREE
        OTHER:
            result := ((tmp >> core.FLD_DCFREE) & core.BITS_DCFREE)
            return (result == DCFREE_WHITE)

    tmp &= core.MASK_DCFREE
    tmp := (tmp | enabled) & core.PACKETCONFIG1_MASK
    writeReg(core.PACKETCONFIG1, 1, @tmp)

PUB DCBlock(param)
' dummy method

PUB DeviceID(): result
' Read device ID
'   Returns:
'       Value   Chip version
'       $21:    V2a
'       $22:    V2b
'       $23:    V2c
'       $24:    ???
    readReg (core.VERSION, 1, @result)

PUB DVGAGain(param=-2)
' dummy method

PUB Encryption(enabled=-2) | tmp
' Enable AES encryption/decryption
'   Valid values: TRUE (-1 or 1), FALSE (0)
'   Any other value polls the chip and returns the current setting
'   NOTE: Encryption is limited to payloads of a maximum of 66 bytes
    tmp := $00
    readReg(core.PACKETCONFIG2, 1, @tmp)
    case abs(enabled)
        0, 1:
            enabled := abs(enabled) & %1
        OTHER:
            result := (tmp & %1) * TRUE
            return

    tmp &= core.MASK_AESON
    tmp := (tmp | enabled) & core.PACKETCONFIG2_MASK
    writeReg(core.PACKETCONFIG2, 1, @tmp)

PUB EncryptionKey(rw, buff_addr) | tmp
' Set AES 128-bit encryption key
'   Valid values:
'       rw: KEY_RD (0), KEY_WR (1)
'       buff_addr: All bytes at address may be $00..$FF
'   NOTE: Variable at buff_addr must be at least 16 bytes
'           1st byte of key is MSB
    case rw
        KEY_WR:
            writeReg(core.AESKEY1, 16, buff_addr)
        OTHER:
            readReg(core.AESKEY1, 16, buff_addr)

PUB EnterCondition(condition=-2): result | tmp
' Set interrupt condition for entering intermediate mode
'   Valid values:
'       ENTCOND_NONE (%000)            Automodes off
'       ENTCOND_FIFONOTEMPTY (%001)    Rising edge of FIFO not empty
'       ENTCOND_FIFOLVL (%010)         Rising edge of FIFO level
'       ENTCOND_CRCOK (%011)           Rising edge of CRC OK
'       ENTCOND_PAYLDRDY (%100)        Rising edge of Payload ready
'       ENTCOND_SYNCADD (%101)         Rising edge of Sync Address
'       ENTCOND_PKTSENT (%110)         Rising edge of Packet sent
'       ENTCOND_FIFOEMPTY (%111)       Falling edge of FIFO not empty (i.e., FIFO empty)
'   Any other value polls the chip and returns the current setting
    tmp := $00
    readReg (core.AUTOMODES, 1, @tmp)
    case condition
        ENTCOND_NONE, ENTCOND_FIFONOTEMPTY, ENTCOND_FIFOLVL, ENTCOND_CRCOK, ENTCOND_PAYLDRDY, ENTCOND_SYNCADD, ENTCOND_PKTSENT, ENTCOND_FIFOEMPTY:
            condition <<= core.FLD_ENTERCONDITION
        OTHER:
            result := (tmp >> core.FLD_ENTERCONDITION) & core.BITS_ENTERCONDITION
            return

    tmp &= core.MASK_ENTERCONDITION
    tmp := (tmp | condition) & core.AUTOMODES_MASK
    writeReg(core.AUTOMODES, 1, @tmp)

PUB ExitCondition(condition=-2): result | tmp
' Set interrupt condition for entering intermediate mode
'   Valid values:
'       EXITCOND_NONE (%000)           Automodes off
'       EXITCOND_FIFOEMPTY (%001)      Falling edge of FIFO not empty
'       EXITCOND_FIFOLVL (%010)        Rising edge of FIFO level or timeout
'       EXITCOND_CRCOK (%011)          Rising edge of CRC OK or timeout
'       EXITCOND_PAYLDRDY (%100)       Rising edge of Payload ready or timeout
'       EXITCOND_SYNCADD (%101)        Rising edge of Sync Addressor timeout
'       EXITCOND_PKTSENT (%110)        Rising edge of Packet sent
'       EXITCOND_TIMEOUT (%111)        Rising edge of timeout
'   Any other value polls the chip and returns the current setting
    tmp := $00
    readReg (core.AUTOMODES, 1, @tmp)
    case condition
        EXITCOND_NONE, EXITCOND_FIFOEMPTY, EXITCOND_FIFOLVL, EXITCOND_CRCOK, EXITCOND_PAYLDRDY, EXITCOND_SYNCADD, EXITCOND_PKTSENT, EXITCOND_TIMEOUT:
            condition <<= core.FLD_EXITCONDITION
        OTHER:
            result := (tmp >> core.FLD_EXITCONDITION) & core.BITS_EXITCONDITION
            return

    tmp &= core.MASK_EXITCONDITION
    tmp := (tmp | condition) & core.AUTOMODES_MASK
    writeReg(core.AUTOMODES, 1, @tmp)

PUB FEIComplete(): result
' Indicates if FEI measurement complete
'   Returns: TRUE if complete, FALSE otherwise
    result := $00
    readReg(core.AFCFEI, 1, @result)
    result := ((result >> core.FLD_FEIDONE) & %1) * TRUE
    return

PUB FEIError(): result | tmp
' Frequency error
'   Returns: FEI measurement, in Hz
    tmp := $00
    readReg(core.AFCFEI, 2, @tmp)
    if tmp & $8000
        result := (65536-tmp) * FSTEP
    else
        result := tmp * FSTEP
    return

PUB FEIStart() | tmp
' Trigger a manual FEI measurement
    tmp := $00
    readReg(core.AFCFEI, 1, @tmp)
    tmp := tmp | (1 << core.FLD_FEISTART)
    writeReg(core.AFCFEI, 1, @tmp)

PUB FIFOEmpty(): result
' FIFO Empty status
'   Returns: TRUE if FIFO empty, FALSE if FIFO contains at least one byte
    result := $00
    readReg (core.IRQFLAGS2, 1, @result)
    result := (((result >> core.FLD_FIFONOTEMPTY) & %1) ^ %1) * TRUE

PUB FIFOFull(): result
' FIFO Full status
'   Returns: TRUE if FIFO full, FALSE if there's at least one byte available
    result := $00
    readReg (core.IRQFLAGS2, 1, @result)
    result := ((result >> core.FLD_FIFOFULL) & %1) * TRUE

PUB FIFOThreshold(bytes=-2): result | tmp
' Set threshold for triggering FIFO level interrupt
'   Valid values: 0..127
'   Any other value polls the chip and returns the current setting
    tmp := $00
    readReg(core.FIFOTHRESH, 1, @tmp)
    case bytes
        0..127:
        OTHER:
            result := tmp & core.BITS_FIFOTHRESHOLD
            return

    tmp &= core.MASK_FIFOTHRESHOLD
    tmp := (tmp | bytes) & core.FIFOTHRESH_MASK
    writeReg(core.FIFOTHRESH, 1, @tmp)

PUB FlushTX()
' dummy method

PUB FreqDeviation(Hz=-2): result | tmp
' Set carrier deviation, in Hz
'   Valid values:
'       600..300_000
'       Default is 5_000
'   Any other value polls the chip and returns the current setting
'   NOTE: Set value will be rounded
    tmp := 0
    readReg (core.FDEVMSB, 2, @tmp)
    case Hz
        600..300_000:
            Hz := (Hz / FSTEP) & core.BITS_FDEV
        OTHER:
            tmp &= core.BITS_FDEV
            result := tmp * FSTEP

    writeReg (core.FDEVMSB, 2, @Hz)

PUB FSTX()
' dummy method

PUB GaussianFilter(BT=-2): result | tmp
' Set Gaussian filter/data shaping parameters
'   Valid values:
'       BT_NONE (0): No shaping
'       BT_1_0 (1): Gaussian filter, BT = 1.0
'       BT_0_5 (2): Gaussian filter, BT = 0.5
'       BT_0_3 (3): Gaussian filter, BT = 0.3

'   Any other value polls the chip and returns the current setting
    readReg (core.DATAMODUL, 1, @tmp)
    case BT
        BT_NONE..BT_0_3:
            BT := BT << core.FLD_MODULATIONSHAPING
        OTHER:
            result := (tmp >> core.FLD_MODULATIONSHAPING) & core.BITS_MODULATIONSHAPING
            return result

    tmp &= core.MASK_MODULATIONSHAPING
    tmp := (tmp | BT) & core.DATAMODUL_MASK
    writeReg (core.DATAMODUL, 1, @tmp)

PUB Idle()
' Change chip state to idle (standby)
    OpMode (OPMODE_STDBY)

PUB IntermediateMode(mode=-2): result | tmp
' Set intermediate operating mode
'   Valid values:
'       IMODE_SLEEP (%00): Sleep
'       IMODE_STBY (%01): Standby
'       IMODE_RX (%10): Receive
'       IMODE_TX (%11): Transmit
'   Any other value polls the chip and returns the current setting
    tmp := $00
    readReg(core.AUTOMODES, 1, @tmp)
    case mode
        IMODE_SLEEP, IMODE_STBY, IMODE_RX, IMODE_TX:
            mode &= core.BITS_INTERMEDIATEMODE
        OTHER:
            result := (tmp >> core.FLD_INTERMEDIATEMODE) & core.BITS_INTERMEDIATEMODE
            return

    tmp &= core.MASK_INTERMEDIATEMODE
    tmp := (tmp | mode) & core.AUTOMODES_MASK
    writeReg(core.AUTOMODES, 1, @tmp)

PUB Interrupt(): result
' Read interrupt state
'   Bits:
'   15  - FIFO is full
'   14  - FIFO isn't empty
'   13  - FIFO level exceeds threshold set by FIFOThreshold()
'   12  - FIFO overrun
'   11  - Payload sent
'   10  - Payload ready
'   9   - RX Payload CRC OK
'   8   - Battery voltage below level set by LowBattLevel()
'   7   - OpMode ready
'   6   - RX mode only: After RSSI, AGC and AFC
'   5   - TX mode only: after PA ramp up
'   4   - FS, RX, TX OpModes: PLL locked
'   3   - RX mode only: RSSI exceeds level set by RSSIThreshold()
'   2   - Timeout
'   1   - Entered intermediate mode
'   0   - Syncword and address (if enabled) match
    readReg(core.IRQFLAGS1, 2, @result)

PUB IntFreq(param=-2)
' dummy method

PUB Listen(enabled=-2): result | tmp
' Enable listen mode
'   Valid values: TRUE (-1 or 1), FALSE (0)
'   Any other value polls the chip and returns the current setting
'   NOTE: Should be enable when in standby mode
    readReg (core.OPMODE, 1, @tmp)
    case abs(enabled)
        0, 1:
            enabled := (abs(enabled)) << core.FLD_LISTENON
        OTHER:
            result := ((tmp >> core.FLD_LISTENON) & %1) * TRUE
            return result

    tmp &= core.MASK_LISTENON
    tmp := (tmp | enabled) & core.OPMODE_MASK
    writeReg (core.OPMODE, 1, @tmp)

PUB LNAGain(dB=-2): result | tmp
' Set LNA gain, in dB relative to highest gain
'   Valid values:
'      *LNA_AGC (0): Gain is set by the internal AGC loop
'       LNA_HIGH (1): Highest gain
'       -6: (Highest gain - 6dB)
'       -12: (Highest gain - 12dB)
'       -24: (Highest gain - 24dB)
'       -36: (Highest gain - 36dB)
'       -48: (Highest gain - 48dB)
'   Any other value polls the chip and returns the current setting
    readReg (core.LNA, 1, @tmp)
    case dB := lookdown(dB: LNA_AGC, LNA_HIGH, -6, -12, -24, -36, -48)
        1..7:
            dB := dB-1 & core.BITS_LNAGAINSELECT
        OTHER:'XXX Should this read the LNACURRENTGAIN field instead?
            result := tmp & core.BITS_LNAGAINSELECT
            return lookupz(result: LNA_AGC, LNA_HIGH, -6, -12, -24, -36, -48)

    tmp &= core.MASK_LNAGAINSELECT
    tmp := (tmp | dB) & core.LNA_MASK
    writeReg (core.LNA, 1, @tmp)

PUB LNAZInput(ohms=-2): result | tmp
' Set LNA's input impedance, in ohms
'   Valid values:
'       50, *200
'   Any other value polls the chip and returns the current setting
    readReg (core.LNA, 1, @tmp)
    case ohms := lookdown(ohms: 50, 200)
        1, 2:
            ohms := (ohms-1) << core.FLD_LNAZIN
        OTHER:
            result := (tmp >> core.FLD_LNAZIN) & %1
            return lookupz(result: 50, 200)

    tmp &= core.MASK_LNAZIN
    tmp := (tmp | ohms) & core.LNA_MASK
    writeReg (core.LNA, 1, @tmp)


PUB LowBattLevel(mV=-2): result | tmp
' Set low battery threshold, in millivolts
'   Valid values:
'       1695, 1764, *1835, 1905, 1976, 2045, 2116, 2185
'   Any other value polls the chip and returns the current setting
    readReg (core.LOWBAT, 1, @tmp)
    case mV := lookdown(mV: 1695, 1764, 1835, 1905, 1976, 2045, 2116, 2185)
        1..8:
            mV := (mV-1) & core.BITS_LOWBATTRIM
        OTHER:
            result := tmp & core.BITS_LOWBATTRIM
            return lookupz(result: 1695, 1764, 1835, 1905, 1976, 2045, 2116, 2185)

    tmp &= core.MASK_LOWBATTRIM
    tmp := (tmp | mV) & core.LOWBAT_MASK
    writeReg (core.LOWBAT, 1, @tmp)

PUB LowBattMon(enabled=-2): result | tmp
' Enable low battery detector signal
'   Valid values: TRUE (-1 or 1), FALSE (0)
'   Any other value polls the chip and returns the current setting
    readReg (core.LOWBAT, 1, @tmp)
    case abs(enabled)
        0, 1:
            enabled := (abs(enabled)) << core.FLD_LOWBATON
        OTHER:
            result := ((tmp >> core.FLD_LOWBATON) & %1) * TRUE
            return result

    tmp &= core.MASK_LOWBATON
    tmp := (tmp | enabled) & core.LOWBAT_MASK
    writeReg (core.LOWBAT, 1, @tmp)

PUB ManchesterEnc(enabled=-2): result | tmp
' Enable Manchester encoding/decoding
'   Valid values: TRUE (-1 or 1), FALSE (0)
'   Any other value polls the chip and returns the current setting
'   NOTE: This setting and DataWhitening are mutually exclusive; enabling this will disable DataWhitening
    tmp := $00
    readReg(core.PACKETCONFIG1, 1, @tmp)
    case abs(enabled)
        0:
        1:
            enabled := DCFREE_MANCH << core.FLD_DCFREE
        OTHER:
            result := ((tmp >> core.FLD_DCFREE) & core.BITS_DCFREE)
            return (result == DCFREE_MANCH)

    tmp &= core.MASK_DCFREE
    tmp := (tmp | enabled) & core.PACKETCONFIG1_MASK
    writeReg(core.PACKETCONFIG1, 1, @tmp)

PUB Modulation(type=-2): result | tmp
' Set modulation type
'   Valid values:
'       MOD_FSK (0): Frequency Shift Keyed
'       MOD_OOK (1): On-Off Keyed
'   Any other value polls the chip and returns the current setting
    readReg (core.DATAMODUL, 1, @tmp)
    case type
        MOD_FSK, MOD_OOK:
            type := type << core.FLD_MODULATIONTYPE
        OTHER:
            result := (tmp >> core.FLD_MODULATIONTYPE) & core.BITS_MODULATIONTYPE
            return result

    tmp &= core.MASK_MODULATIONTYPE
    tmp := (tmp | type) & core.DATAMODUL_MASK
    writeReg (core.DATAMODUL, 1, @tmp)

PUB NodeAddress(addr=-2): result | tmp
' Set node address
'   Valid values: $00..$FF
'   Any other value polls the chip and returns the current setting
    tmp := $00
    readReg (core.NODEADRS, 1, @tmp)
    case addr
        $00..$FF:
        OTHER:
            result := tmp
            return

    writeReg (core.NODEADRS, 1, @addr)

PUB OCPCurrent(mA=-2): result | tmp
' Set PA overcurrent protection level, in milliamps
'   Valid values:
'       45..120 (Default: 95)
'   NOTE: Set value will be rounded to the nearest 5mA
'   Any other value polls the chip and returns the current setting
    readReg (core.OCP, 1, @tmp)
    case mA
        45..120:
            mA := (mA-45)/5 & core.BITS_OCPTRIM
        OTHER:
            result := 45 + 5 * (tmp & core.BITS_OCPTRIM)
            return result

    tmp &= core.MASK_OCPTRIM
    tmp := (tmp | mA) & core.OCP_MASK
    writeReg (core.OCP, 1, @tmp)

PUB OpMode(mode=-2): result | tmp
' Set operating mode
'   Valid values:
'       OPMODE_SLEEP (0): Sleep mode
'       OPMODE_STDBY (1): Standby mode
'       OPMODE_FS (2): Frequency Synthesizer mode
'       OPMODE_TX (3): Transmitter mode
'       OPMODE_RX (4): Receiver mode
'   Any other value polls the chip and returns the current setting
    readReg (core.OPMODE, 1, @tmp)
    case mode
        %000..%100:
            mode := mode << core.FLD_MODE
        OTHER:
            result := (tmp >> core.FLD_MODE) & core.BITS_MODE
            return

    tmp &= core.MASK_MODE
    tmp := (tmp | mode) & core.OPMODE_MASK
    writeReg (core.OPMODE, 1, @tmp)

PUB OvercurrentProtection(enabled=-2): result | tmp
' Enable PA overcurrent protection
'   Valid values: *TRUE (-1 or 1), FALSE (0)
'   Any other value polls the chip and returns the current setting
    readReg (core.OCP, 1, @tmp)
    case abs(enabled)
        0, 1:
            enabled := (abs(enabled)) << core.FLD_OCPON
        OTHER:
            result := ((tmp >> core.FLD_OCPON) & %1) * TRUE
            return result

    tmp &= core.MASK_OCPON
    tmp := (tmp | enabled) & core.OCP_MASK
    writeReg (core.OCP, 1, @tmp)

PUB PayloadLen(length=-2): result
' Set payload/packet length, in bytes
'   Behavior differs depending on setting of PacketFormat:
'       If PacketFormat == PKTLEN_FIXED, this sets payload length
'       If PacketFormat == PKTLEN_VAR, this sets max length in RX, and is ignored in TX
'   Valid values: 0..255
'   Any other value polls the chip and returns the current setting
    result := $00
    readReg (core.PAYLOADLENGTH, 1, @result)
    case length
        0..255:
        OTHER:
            return

    writeReg (core.PAYLOADLENGTH, 1, @length)

PUB PayloadLenCfg(mode=-2): result | tmp
' Set payload/packet length, in bytes
'   Behavior differs depending on setting of PacketFormat:
'       If PacketFormat == PKTLEN_FIXED, this sets payload length
'       If PacketFormat == PKTLEN_VAR, this sets max length in RX, and is ignored in TX
'   Valid values: 0..255
'   Any other value polls the chip and returns the current setting
    tmp := $00
    readReg (core.PACKETCONFIG1, 1, @tmp)
    case mode
        PKTLEN_FIXED, PKTLEN_VAR:
            mode <<= core.FLD_PACKETFORMAT
        OTHER:
            result := (tmp >> core.FLD_PACKETFORMAT) & %1
            return

    tmp &= core.MASK_PACKETFORMAT
    tmp := (tmp | mode) & core.PACKETCONFIG1_MASK
    writeReg (core.PACKETCONFIG1, 1, @tmp)

PUB PayloadSent(): result
' Packet sent status
'   Returns: TRUE if packet sent, FALSE otherwise
'   NOTE: Once set, this flag clears when exiting TX mode
    result := $00
    readReg (core.IRQFLAGS2, 1, @result)
    result := ((result >> core.FLD_PACKETSENT) & %1) * TRUE

PUB PreambleLen(bytes=-2): result
' Set number of bytes in preamble
'   Valid values: 0..65535
'   Any other value polls the chip and returns the current setting
    result := $00
    readReg(core.PREAMBLEMSB, 2, @result)
    case bytes
        0..65535:
        OTHER:
            return

    writeReg(core.PREAMBLEMSB, 2, @bytes)

PUB RampTime(uSec=-2): result | tmp
' Set rise/fall time of ramp up/down in FSK, in microseconds
'   Valid values:
'       3400, 2000, 1000, 500, 250, 125, 100, 62, 50, 40, 31, 25, 20, 15, 12, 10
'   Any other value polls the chip and returns the current setting
    readReg (core.PARAMP, 1, @tmp)
    case uSec := lookdown(uSec: 3400, 2000, 1000, 500, 250, 125, 100, 62, 50, 40, 31, 25, 20, 15, 12, 10)
        1..16:
            uSec := (uSec-1) & core.BITS_PARAMP
        OTHER:
            result := tmp & core.BITS_PARAMP
            return lookupz(result: 3400, 2000, 1000, 500, 250, 125, 100, 62, 50, 40, 31, 25, 20, 15, 12, 10)

    tmp := uSec & core.PARAMP_MASK
    writeReg (core.PARAMP, 1, @tmp)

PUB RCOscCal(enabled=-2): result | tmp
' Trigger calibration of RC oscillator
'   Valid values:
'       TRUE (-1 or 1)
'   Any other value polls the chip and returns the current calibration status
'   Returns:
'       FALSE: RC calibration in progress
'       TRUE: RC calibration complete
    readReg (core.OSC1, 1, @tmp)
    case abs(enabled)
        1:
            enabled := (abs(enabled)) << core.FLD_RCCALSTART
        OTHER:
            result := ((tmp >> core.FLD_RCCALDONE) & %1) * TRUE
            return result

    tmp := (tmp | enabled) & core.OSC1_MASK
    writeReg (core.OSC1, 1, @tmp)

PUB RSSI(): result | tmp
' Received Signal Strength Indicator
'   Returns: Signal strength seen by transceiver, in dBm
    tmp := %1
    writeReg(core.RSSICONFIG, 1, @tmp)
    repeat
        readReg(core.RSSICONFIG, 1, @tmp)
    until tmp & %10

    readReg(core.RSSIVALUE, 1, @result)
    result := ~result
    result >>= 1

PUB RXBandwidth(Hz=-2): result | tmp, tmp_m, tmp_e
' Set receiver channel filter bandwidth, in Hz
'   Valid values: 2600, 3100, 3900, 5200, 6300, 7800, 10400, 12500, 15600, 20800, 25000, 31300, 41700, 50000, 62500, 83300, 100000, 125000, 166700, 200000, 250000, 333300, 400000, 500000
'   Any other value polls the chip and returns the current setting
    tmp := $00
    readReg(core.RXBW, 1, @tmp)
    case Hz
        2_600..500_000:
            tmp_e := tmp_m := lookdownz(Hz: 500000, 400000, 333300, 250000, 200000, 166700, 125000, 100000, 83300, 62500, 50000, 41700, 31300, 25000, 20800, 15600, 12500, 10400, 7800, 6300, 5200, 3900, 3100, 2600)
            tmp_m := lookupz(tmp_m: %00, %01, %10, %00, %01, %10, %00, %01, %10, %00, %01, %10, %00, %01, %10, %00, %01, %10, %00, %01, %10, %00, %01, %10) << core.FLD_RXBWMANT
            tmp_e := lookupz(tmp_e: 00, 00, 00, 01, 01, 01, 02, 02, 02, 03, 03, 03, 04, 04, 04, 05, 05, 05, 06, 06, 06, 07, 07, 07)
            Hz := tmp_m | tmp_e
        OTHER:
            tmp.byte[3] := tmp.byte[0] & core.BITS_RXBWEXP
            tmp.byte[2] := lookupz( (tmp.byte[0] >> core.FLD_RXBWMANT) & core.BITS_RXBWMANT: 16, 20, 24)
            result := FXOSC / ( tmp.byte[2] * (1 << (tmp.byte[3] + 2)) )
            return

    tmp &= core.MASK_RXBW
    tmp := (tmp | Hz) & core.RXBW_MASK
    writeReg(core.RXBW, 1, @tmp)

PUB RXPayload(nr_bytes, buff_addr)
' Read data queued in the RX FIFO
'   nr_bytes Valid values: 1..66
'   Any other value is ignored
'   NOTE: Ensure buffer at address buff_addr is at least as big as the number of bytes you're reading
    readReg(core.FIFO, nr_bytes, buff_addr)

PUB RXMode()
' Change chip state to RX (receive)
    OpMode (OPMODE_RX)

PUB SensitivityBoost() | tmp

    tmp := $2D
    writeReg(core.TESTLNA, 1, @tmp)

PUB Sequencer(mode=-2): result | tmp
' Control automatic sequencer
'   Valid values:
'       *OPMODE_AUTO (0): Automatic sequence, as selected by OperatingMode
'        OPMODE_MANUAL (1): Mode is forced
'   Any other value polls the chip and returns the current setting
    readReg (core.OPMODE, 1, @tmp)
    case mode
        OPMODE_AUTO, OPMODE_MANUAL:
            mode := mode << core.FLD_SEQUENCEROFF
        OTHER:
            result := (tmp >> core.FLD_SEQUENCEROFF) & %1
            return result

    tmp &= core.MASK_SEQUENCEROFF
    tmp := (tmp | mode) & core.OPMODE_MASK
    writeReg (core.OPMODE, 1, @tmp)

PUB Sleep()
' Power down chip
    OpMode(OPMODE_SLEEP)

PUB SyncMode(param)
' dummy method

PUB SyncWord(rw, buff_addr)
' Set sync word to value at buff_addr
'   Valid values:
'       rw: SW_READ (0), SW_WRITE (1)
'       variable at address buff_addr: All bytes can be $01..$FF
'   For rw, any value other than SW_WRITE (1) polls the chip and returns the current setting
'   NOTE: Variable pointed to by buff_addr must be at least 8 bytes in length
    case rw
        SW_WRITE:
            writeReg(core.SYNCVALUE1, 8, buff_addr)
        OTHER:
            readReg(core.SYNCVALUE1, 8, buff_addr)  'XXX Future test: set nr_bytes arg to SyncWordBytes(-2)?

PUB SyncWordEnabled(enabled=-2): result | tmp
' Enable sync word generation (TX) and detection (RX)
'   Valid values: TRUE (-1 or 1), FALSE (0)
'   Any other value polls the chip and returns the current setting
    tmp := $00
    readReg(core.SYNCCONFIG, 1, @tmp)
    case abs(enabled)
        0, 1:
            enabled := abs(enabled) << core.FLD_SYNCON
        OTHER:
            result := ((tmp >> core.FLD_SYNCON) & %1) * TRUE
            return

    tmp &= core.MASK_SYNCON
    tmp := (tmp | enabled) & core.SYNCCONFIG_MASK
    writeReg(core.SYNCCONFIG, 1, @tmp)

PUB SyncWordLength(bytes=-2): result | tmp
' Set number of bytes in sync word
'   Valid values: 1..8
'   Any other value polls the chip and returns the current setting
    tmp := $00
    readReg(core.SYNCCONFIG, 1, @tmp)
    case bytes
        1..8:
            bytes := (bytes-1) << core.FLD_SYNCSIZE
        OTHER:
            result := ((tmp >> core.FLD_SYNCSIZE) & core.BITS_SYNCSIZE) + 1
            return

    tmp &= core.MASK_SYNCSIZE
    tmp := (tmp | bytes) & core.SYNCCONFIG_MASK
    writeReg(core.SYNCCONFIG, 1, @tmp)

PUB SyncWordMaxBitErr(bits=-2): result | tmp
' Set maximum number of tolerated bit errors in sync word
'   Valid values: 0..7
'   Any other value polls the chip and returns the current setting
    tmp := $00
    readReg(core.SYNCCONFIG, 1, @tmp)
    case bits
        0..7:
        OTHER:
            result := (tmp & core.BITS_SYNCTOL)
            return

    tmp &= core.MASK_SYNCTOL
    tmp := (tmp | bits) & core.SYNCCONFIG_MASK
    writeReg(core.SYNCCONFIG, 1, @tmp)

PUB Temperature(): result | tmp
' Read temperature
'   Returns: Degrees C
    tmp := (1 << core.FLD_TEMPMEASSTART)    ' Trigger a temperature measurement
    writeReg(core.TEMP1, 1, @tmp)
    tmp := $00
    repeat                                  ' Wait until the measurement is complete
        readReg(core.TEMP1, 1, @tmp)
    while ((tmp >> core.FLD_TEMPMEASRUNNING) & %1)

    result := $00
    readReg(core.TEMP2, 1, @result)
    if result & $80
        return 256-result
    else
        return result

PUB TXMode()
' Change chip state to transmit
    OpMode(OPMODE_TX)

PUB TXPayload(nr_bytes, buff_addr)
' Queue data to transmit in the TX FIFO
'   nr_bytes Valid values: 1..66
'   Any other value is ignored
    writeReg(core.FIFO, nr_bytes, buff_addr)

PUB TXPower(dBm=-255): result | tmp
' Set transmit output power, in dBm
'   Valid values:
'       -18..17
'   Any other value polls the chip and returns the current setting
    tmp := 0
    readReg (core.PALEVEL, 1, @tmp.byte[0])
    case dBm
        -18..13:
            dBm := (dBm + 18) & core.BITS_OUTPUTPOWER
            tmp &= core.MASK_OUTPUTPOWER                                ' Zero out the existing power level setting
            tmp &= core.MASK_PA0ON                                      '   and all of the PAx bits
            tmp := tmp & core.MASK_PA1ON & core.MASK_PA2ON              '
            tmp := tmp | (1 << core.FLD_PA0ON)                          ' Turn on only the PA0 bit
            tmp.byte[1] := core.PA1_NORMAL                              ' Turn off the PA_BOOST circuit
            tmp.byte[2] := core.PA2_NORMAL
        14..17:
            dBm := (dBm + 14) & core.BITS_OUTPUTPOWER
            tmp &= core.MASK_OUTPUTPOWER
            tmp &= core.MASK_PA0ON
            tmp := tmp & core.MASK_PA1ON & core.MASK_PA2ON
            tmp := tmp | (1 << core.FLD_PA1ON) | (1 << core.FLD_PA2ON)
            tmp.byte[1] := core.PA1_NORMAL                              ' Turn off the PA_BOOST circuit
            tmp.byte[2] := core.PA2_NORMAL
        18..20:
            dBm := (dBm + 11) & core.BITS_OUTPUTPOWER
            tmp &= core.MASK_OUTPUTPOWER
            tmp &= core.MASK_PA0ON
            tmp := tmp & core.MASK_PA1ON & core.MASK_PA2ON
            tmp := tmp | (1 << core.FLD_PA1ON) | (1 << core.FLD_PA2ON)  ' Turn on the PA1 and 2 bits
            tmp.byte[1] := core.PA1_BOOST                               '   and the PA_BOOST circuit
            tmp.byte[2] := core.PA2_BOOST
        OTHER:
            result := tmp & core.BITS_OUTPUTPOWER                       ' Determine offset to calculate current
            case (tmp >> core.FLD_PA2ON) & core.BITS_PA012              ' TXPower by checking which PAx bits are set
                %100:                                                   ' Only PA0 is set
                    result -= 18
                %011, %010:                                             ' PA1 and possibly PA2 are set
                    readReg(core.TESTPA1, 1, @tmp.byte[1])
                    readReg(core.TESTPA2, 1, @tmp.byte[2])
                    if tmp.byte[1] == core.PA1_BOOST and tmp.byte[2] == core.PA2_BOOST
                        result -= 11                                    ' PA_BOOST is active
                    else
                        result -= 14                                    ' PA_BOOST is inactive
            return result

    tmp := (tmp | dBm) & core.PALEVEL_MASK
    writeReg (core.PALEVEL, 1, @tmp.byte[0])
    writeReg (core.TESTPA1, 1, @tmp.byte[1])
    writeReg (core.TESTPA2, 1, @tmp.byte[2])

PUB TXStartCondition(when=-2): result | tmp
' Define when to begin packet transmission
'   Valid values:
'       TXSTART_FIFOLVL (0): If the number of bytes in the FIFO exceeds FIFOThreshold
'       TXSTART_FIFONOTEMPTY (1): If there's at least one byte in the FIFO
'   Any other value polls the chip and returns the current setting
    tmp := $00
    readReg(core.FIFOTHRESH, 1, @tmp)
    case when
        TXSTART_FIFOLVL, TXSTART_FIFONOTEMPTY:
            when <<= core.FLD_TXSTARTCONDITION
        OTHER:
            result := (tmp >> core.FLD_TXSTARTCONDITION) & %1
            return

    tmp &= core.MASK_TXSTARTCONDITION
    tmp := (tmp | when) & CORE.FIFOTHRESH_MASK
    writeReg(core.FIFOTHRESH, 1, @tmp)

PUB WaitRX() | tmp
' Force the receiver in wait mode (continuous RX)
    tmp := $00
    readReg(core.PACKETCONFIG2, 1, @tmp)

    tmp &= core.MASK_RESTARTRX
    tmp := (tmp | (1 << core.FLD_RESTARTRX)) & core.PACKETCONFIG2_MASK
    writeReg(core.PACKETCONFIG2, 1, @tmp)

PRI readReg(reg_nr, nr_bytes, buff_addr) | tmp
' Read nr_bytes from register 'reg_nr' to address 'buff_addr'
    case reg_nr
        $00..$13, $18..$4F, $58..$59, $5F, $6F, $71:
            io.Low(_CS)
'            spi.Write(reg_nr)
            spi.Write(_MOSI, _SCK, core.MOSI_BITORDER, 8, reg_nr)
            repeat tmp from nr_bytes-1 to 0
'                byte[buff_addr][tmp] := spi.Read
                byte[buff_addr][tmp] := spi.Read(_MISO, _SCK, core.MISO_BITORDER, 8)
            io.High(_CS)

        OTHER:
            return

PRI writeReg(reg_nr, nr_bytes, buff_addr) | tmp
' Write nr_bytes to register 'reg_nr' stored in val
    case reg_nr
        $00..$13, $18..$4F, $58..$59, $5F, $6F, $71:
            io.Low(_CS)
'            spi.Write(reg_nr | core.W)
            spi.Write(_MOSI, _SCK, core.MOSI_BITORDER, 8, reg_nr | core.W)
            repeat tmp from nr_bytes-1 to 0
'                spi.Write(byte[buff_addr][tmp])
                spi.Write(_MOSI, _SCK, core.MOSI_BITORDER, 8, byte[buff_addr][tmp])
            io.High(_CS)

        OTHER:
            return

DAT
{
    --------------------------------------------------------------------------------------------------------
    TERMS OF USE: MIT License

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
    associated documentation files (the "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
    following conditions:

    The above copyright notice and this permission notice shall be included in all copies or substantial
    portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    --------------------------------------------------------------------------------------------------------
}
