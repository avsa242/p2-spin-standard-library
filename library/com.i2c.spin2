{
   --------------------------------------------
    Filename: com.i2c.spin2
    Description: Bitbanged I2C driver for the P2X8C4M64P
    Author: Jesse Burt
        (based on jm_i2c.spin, originally by Jon McPhalen)
    Created: Jun 15, 2019
    Updated: Oct 20, 2020
    See end of file for terms of use.
    --------------------------------------------

    NOTE: Pull-up resistors _required_ on the SDA _and_ SCL lines.
        SCL is not driven
}
CON

    #0, ACK, NAK

VAR

    long _SCL                                   ' Bus pins
    long _SDA
    long _delay, _hdelay, _qdelay

PUB Setup(I2C_SCL, I2C_SDA, I2C_HZ=100_000): okay
' Define I2C SCL (clock) and SDA (data) pins
    _delay := (clkfreq/I2C_HZ)                  ' Calculate delays based on clock freq
    _hdelay := _delay >> 1
    _qdelay := _delay >> 2

    _SCL := I2C_SCL
    _SDA := I2C_SDA
    pinf(I2C_SCL)                               ' Float pins
    pinf(I2C_SDA)
    reset()
    okay := cogid() + 1
    return

PUB Present(slave_addr): ackbit
' Pings device, returns true if ACK
    start()
    ackbit := (write(slave_addr) == ACK)
    stop()

PUB Read(ackbit): i2cbyte | SCL, SDA
' Read byte from I2C bus
'   Valid values:
'       ackbit:
'           ACK (0): Send ACK to slave device
'           NAK (non-zero): Send NAK to slave device
    longmove(@SCL, @_SCL, 2)
    ackbit := (ackbit <> 0)
    pinf(SDA)                                   ' Make SDA input

    repeat 8
        qd()
        pinf(SCL)                               ' Float SCL
        hd()
        i2cbyte := (i2cbyte << 1) | pinr(SDA)   ' Read the bit
        pinl(SCL)                               ' SCL low
        qd()

    (ackbit) ? (pinf(SDA)) : (pinl(SDA))        ' Output ACK bit
    qd()
    pinf(SCL)                                   ' Float SCL
    hd()
    pinl(SCL)                                   ' SCL low
    qd()

    return (i2cbyte & $FF)

PUB Reset() | SCL, SDA
' Reset device
    longmove(@SCL, @_SCL, 2)
    repeat 9
        pinl(SCL)
        hd()
        pinf(SCL)
        hd()
        if (pinr(SDA))
            quit

PUB Start()
' I2C Start condition (S, Sr)
'   NOTE: Blocks while SCL held low (clock stretching)
    pinf(_SDA)                                  ' Float pins
    pinf(_SCL)
    repeat while (pinr(_SCL) == 0)              ' Allow "clock stretching"
    hd()
    pinl(_SDA)                                  ' SDA low
    hd()
    pinl(_SCL)                                  ' SCL low
    hd()

PUB Stop()
' I2C Stop condition (P)
'   NOTE: Blocks while SCL held low (clock stretching)
    pinl(_SDA)                                  ' SDA low
    hd()
    pinf(_SCL)                                  ' Float SCL
    hd()
    repeat until (pinr(_SCL) == 1)              ' Hold for clock stretch
    pinf(_SDA)                                  ' Float SDA
    hd()

PUB Wait(slave_addr) | ackbit
' Waits for I2C device to be ready for new command
    repeat
        start()
        ackbit := write(slave_addr)
    until (ackbit == ACK)

PUB WaitTimeout(slave_addr, usec): ackbit, timeout | tmp
' Wait for I2C device to be ready for new command,
'   up to a maximum timeout of 'usec' microseconds
'   Returns:
'       1st return value: TRUE if slave acknowledged, FALSE otherwise
'       2nd return value: Duration waited, in microseconds
    timeout := usec
    repeat
        start()
        ackbit := write(slave_addr)
        waitus(1)
        timeout--
    until (ackbit == ACK) OR (timeout == 0)
    return (ackbit == ACK), usec-timeout

PUB Write(i2cbyte): ackbit | SCL, SDA
' Write byte to I2C bus
' -- leaves SCL low
    longmove(@SCL, @_SCL, 2)
    i2cbyte := (i2cbyte ^ $FF) << 24            ' Move msb (bit7) to bit31
    repeat 8                                    ' Output eight bits, MSB first
        ((i2cbyte rol= 1) & %1) ? (pinl(SDA)) : (pinf(SDA))
        hd()
        pinf(SCL)                               ' SCL high
        hd()
        pinl(SCL)                               ' SCL low
    pinf(SDA)                                   ' Release SDA to read ack bit
    hd()
    pinf(SCL)                                   ' SCL high
    hd()
    ackbit := pinr(SDA)                         ' Read ack bit
    pinl(SCL)                                   ' SCL low
    return ackbit

PRI hd()

    waitx (_hdelay)

PRI qd()

    waitx (_qdelay)

DAT
{
    --------------------------------------------------------------------------------------------------------
    TERMS OF USE: MIT License

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
    associated documentation files (the "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
    following conditions:

    The above copyright notice and this permission notice shall be included in all copies or substantial
    portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    --------------------------------------------------------------------------------------------------------
}
