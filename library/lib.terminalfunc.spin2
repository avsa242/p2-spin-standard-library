{{
   standard routines for dealing with text
   these are intended to extend any class with a "tx" method
   with the following additional methods

   str(s) : print a string; note that unlike standard Spin the string()
      wrapper is not required for string literals, because we have defaulted
      the parameter s to be a string
   dec(d) : print a signed decimal number
   decuns(d) : print an unsigned decimal number
   hex(d, n): print a hex number with n digits (n defaults to 8)
   bin(d, n): print a binary number with n digits (n defaults to 32)
   nl : print a carriage return and newline
   printf(s, ...) : like C printf
}}

'' output a string
PUB Str(s = string("")) | c

    repeat while ((c := byte[s++]) <> 0)
        Char(c)


' Print an number with a given base
' We do this by finding the remainder repeatedly
' This gives us the digits in reverse order
'   so we store them in a buffer; the worst case
'   buffer size needed is 32 (for base 2)
'
'
' signflag indicates how to handle the sign of the
' number:
'   0 == treat number as unsigned
'   1 == print nothing before positive numbers
'   anything else: print before positive numbers
' for signed negative numbers we always print a "-"
'
' we will print at least prec digits
'
VAR

    byte buf[32]

PUB Num(val, base, signflag, digitsNeeded) | i, digit, r1, q1
' If signflag is nonzero, it indicates we should treat
' val as signed; if it is > 1, it is a character we should
' print for positive numbers (typically "+")
    if (signflag)
        if (val < 0)
            signflag := "-"
            val := -val

' Make sure we will not overflow our buffer
    if (digitsNeeded > 32)
        digitsNeeded := 32

' Accumulate the digits
    i := 0
    repeat
        if (val < 0)
' Synthesize unsigned division from signed
' Basically shift val right by 2 to make it positive
' Then adjust the result afterwards by the bit we
' shifted out
            r1 := val&1  ' Capture low bit
            q1 := val>>1 ' Divide val by 2
            digit := r1 + 2*(q1 // base)
            val := 2*(q1 / base)
            if (digit => base)
                val++
                digit -= base
        else
            digit := val // base
            val := val / base

        if (digit => 0 and digit =< 9)
            digit += "0"
        else
            digit := (digit - 10) + "A"
        buf[i++] := digit
        --digitsNeeded
    while (val <> 0 or digitsNeeded > 0) and (i < 32)
    if (signflag > 1)
        Char(signflag)

' Now print the digits in reverse order
    repeat while (i > 0)
        Char(buf[--i])

PUB Dec(val)
' Print a signed decimal number
    Num(val, 10, 1, 0)

PUB DecUns(val, digits = 0)
' Print an unsigned decimal number with the specified
'   number of digits; 0 means just use as many as we need
    Num(val, 10, 0, digits)

PUB Hex(val, digits = 8) | mask
' Print a hex number with the specified number
'   of digits; 0 means just use as many as we need

    if digits > 0 and digits < 8
        mask := (|< (4*digits)) - 1
        val &= mask
    Num(val, 16, 0, digits)

PUB Bin(val, digits = 32) | mask
' Print a number in binary form
    if digits > 0 and digits < 32
        mask := (|< digits) - 1
        val &= mask
    Num(val, 2, 0, digits)

PUB NL
' Print a newline
    Char(13)
    Char(10)

PUB PrintF(fmt = string(""), an=0, bn=0, cn=0, dn=0, en=0, fn=0) | c, valptr, val
' C like formatted print
    valptr := @an'1
    repeat'1
        c := byte[fmt++]'2
        if (c == 0)'2
            quit'3
        if c == "%"'2
            c := byte[fmt++]'3
            if (c == 0)'3
                quit'4
            if (c == "%")'3
                Char(c)'4
                next'4
            val := long[valptr]'3
            valptr += 4'3
            case c'3
                "d": Dec(val)'4
                "u": DecUns(val)
                "x": Hex(val)
                "s": Str(val)
                "c": Char(val)
        elseif c == "\"'2
            c := byte[fmt++]'3
            if c == 0'3
                quit'4
            case c'3
                "n": NL'4
                "r": Char(13)
                "t": Char(8)
                other: Char(c)
        else'2
            Char(c)'3
