{
    --------------------------------------------
    Filename: ansiterminal.common.spin2h
    Description: Add ANSI terminal functionality to a
        terminal driver (P2 version)
    Requires: Terminal driver that provides the following methods:
        putchar(ch) - Output one character to terminal
        getchar()   - Read one character from terminal
        dec(num)    - Output a decimal number to terminal
    Author: Jesse Burt
    Copyright (c) 2022
    Created: Jun 18, 2019
    Updated: Oct 21, 2022
    See end of file for terms of use.
    --------------------------------------------
}

CON

    { Clear modes }
    CLR_CUR_TO_END      = 0     ' Clear from cursor position to end of line
    CLR_CUR_TO_BEG      = 1     ' Clear from cursor position to beginning of line
    CLR_ALL_HOME        = 2     ' Clear screen and return to home position
    CLR_ALL_DEL_SCRLB   = 3     ' Clear all and delete scrollback

    { Graphic Rendition modes }
    SGR_RESET           = 0     ' Reset text attributes

    SGR_INTENSITY_BOLD  = 1     ' Text intensity
    SGR_INTENSITY_FAINT = 2
    SGR_INTENSITY_NML   = 22

    SGR_ITALIC          = 3     ' Can be either Italic or
'    SGR_INVERSE         = 3     '  Inverse, depending on the terminal

    SGR_UNDERLINE       = 4     ' Underlined text
    SGR_UNDERLINE_DBL   = 21
    SGR_UNDERLINE_OFF   = 24

    SGR_BLINKSLOW       = 5     ' Blinking text
    SGR_BLINKFAST       = 6     ' Not supported by all terminals
    SGR_BLINK_OFF       = 25

    SGR_INVERSE         = 7     ' Inverse text, or inverse terminal
    SGR_INVERSE_OFF     = 27

    SGR_CONCEAL         = 8     ' Concealed text
    SGR_REVEAL          = 28

    SGR_STRIKETHRU      = 9     ' strike-through text
    SGR_STRIKETHRU_OFF  = 29

    SGR_PRI_FONT        = 10    ' Select primary font

    SGR_FGCOLOR_DEF     = 39
    SGR_BGCOLOR_DEF     = 49

    SGR_FRAMED          = 51    '
    SGR_ENCIRCLED       = 52    ' Not supported by many terminals
    SGR_FRAMED_ENC_OFF  = 54    '

    SGR_OVERLINED       = 53    ' Overlined text
    SGR_OVERLINED_OFF   = 55


    { Text colors }
    FG                  = 30
    BG                  = 40
    BRIGHT              = 60

    BLACK               = 0
    DKGREY              = BRIGHT + BLACK
    GREY                = 7
    WHITE               = BRIGHT + GREY

    RED                 = 1
    LTRED               = BRIGHT + RED

    GREEN               = 2
    LTGREEN             = BRIGHT + GREEN

    YELLOW              = 3
    BROWN               = 3
    LTYELLOW            = BRIGHT + YELLOW
    LTBROWN             = BRIGHT + BROWN

    BLUE                = 4
    LTBLUE              = BRIGHT + BLUE

    MAGENTA             = 5
    VIOLET              = 5
    LTMAGENTA           = BRIGHT + MAGENTA
    LTVIOLET            = BRIGHT + VIOLET

    CYAN                = 6
    LTCYAN              = BRIGHT + CYAN

    { Semi-graphics characters }
    { Corners: }
    LOWRT               = $6a                   ' Lower-right
    UPPRT               = $6b                   ' Upper-right
    UPPLT               = $6c                   ' Upper-left
    LOWLT               = $6d                   ' Lower-left
    CROSS               = $6e                   ' Cross/4-way
    { Horizontal and Vertical lines }
    HLINE               = $71                   ' H-line
    LVLHSTEM            = $74                   ' Left V-line w/H-stem
    RVLHSTEM            = $75                   ' Right V-line w/H-stem
    BHLVSTEM            = $76                   ' Bottom H-line w/V-stem
    THLVSTEM            = $77                   ' Top H-line w/V-stem
    VLINE               = $78                   ' V-line

PUB bgcolor(bcolor)
' Set background color
    csi()
    putchar(";")
    dec(BG + bcolor)
    putchar("m")

PUB blink(mode=5)
' Set Blink attribute
    sgr(mode)

PUB bold(mode=1)
' Set Bold attribute
    sgr(mode)

PUB box(x0, y0, x1, y1, brd_fg, brd_bg, filled) | inwidth, inheight, inbot, intop, x, y
' Draw a box, using semigraphics characters
'   x0, y0, x1, y1: upper left, lower right coords
'   brd_fg, brd_bg: border foreground, background colors
'   filled: fill box (bool)
    inwidth := x1-x0-1                          ' inside border w, h
    inheight := y1-y0-1
    intop := y0+1                               ' inside border top, bot.
    inbot := y1-1

    case filled
        false:                                  ' not filled:
            bgcolor(brd_bg)
            fgcolor(brd_fg)
            pos_xy(x0, y0)                      ' draw top:
            semi_gfx_ena(true)                  '   enable semi_gfx_ena mode
            putchar(UPPLT)                      '   upper-left corner
            repeat inwidth
                putchar(HLINE)                  '   fill horiz. lines
            putchar(UPPRT)                      '   upper-right corner

            pos_xy(x0, y1)                      ' draw bottom
            putchar(LOWLT)
            repeat inwidth
                putchar(HLINE)
            putchar(LOWRT)

            repeat y from intop to inbot        ' draw left side
                pos_xy(x0, y)
                putchar(VLINE)                  '   v-lines

            repeat y from intop to inbot        ' draw right side
                pos_xy(x1, y)
                putchar(VLINE)
            semi_gfx_ena(false)                 ' done. turn off semi_gfx_ena mode

        true:                                   ' filled:
            bgcolor(brd_bg)
            fgcolor(brd_fg)
            pos_xy(x0, y0)                      ' set window pos
            semi_gfx_ena(true)                  ' turn on semi_gfx_ena mode

            putchar(UPPLT)                      ' top row:
            repeat inwidth                      '   fill with horiz. lines
                putchar(HLINE)
            putchar(UPPRT)

            repeat y from intop to inbot        ' middle rows:
                pos_xy(x0, y)                   '   left border
                putchar(VLINE)                  '   vert. lines
                repeat inwidth
                    putchar(" ")                '   fill line with spaces
                putchar(VLINE)                  '   right border
            pos_xy(x0, y)
            putchar(LOWLT)                      ' bottom row
            repeat inwidth
                putchar(HLINE)
            putchar(LOWRT)
            semi_gfx_ena(false)                 ' done. turn off semi_gfx_ena mode

PUB clear()
' Clear the terminal
    clear_mode(CLR_ALL_HOME)

PUB clearline = clear_ln
PUB clear_line = clear_ln
PUB clear_ln()
' Clear current line of terminal
    clear_lnx(CLR_CUR_TO_END)

PUB clearlinex = clear_lnx
PUB clear_lnx(mode)
' Clear line using explicitly set mode
    csi()
    dec(mode)
    putchar("K")

PUB clearmode = clear_mode
PUB clear_mode(mode)
' Clear screen using explicitly set mode
    csi()
    dec(mode)
    putchar("J")
    if (mode == CLR_ALL_HOME)
        position (0, 0)

PUB color(fcolor, bcolor)
' Set foreground and background colors
    csi()
    dec(FG + fcolor)
    putchar(";")
    dec(BG + bcolor)
    putchar("m")

PUB conceal(mode=8)
' Set Conceal attribute
    sgr(mode)

PUB cursorpositionreporting = curs_pos_report_ena
PUB curs_pos_report_ena(enabled)
' Enable/disable mouse cursor position reporting
    csi()
    case enabled
        FALSE:
            str(string("?1000;1006;1015l"))
        OTHER:
            str(string("?1000;1006;1015h"))

PUB cursornextline = curs_next_line
PUB curs_next_line(rows)
' Move cursor to beginning of next row, or 'rows' number of rows down
    csi()
    dec(rows)
    putchar("E")

PUB cursorprevline = curs_prev_line
PUB curs_prev_line(rows)
' Move cursor to beginning of previous row, or 'rows' number of rows up
    csi()
    dec(rows)
    putchar("F")

PUB encircle()
' Set Encircle attribute
    sgr(SGR_ENCIRCLED)

PUB fgcolor(fcolor)
' Set foreground color
    csi()
    dec(FG + fcolor)
    putchar("m")

PUB framed()
' Set framed attribute
    sgr(SGR_FRAMED)

PUB hidecursor = hide_curs
PUB hide_curs()
' Hide cursor
    csi()
    putchar("?")
    dec(25)
    putchar("l")
    
PUB home()
' Move cursor to home/upper-left position
    pos_xy(0, 0)

PUB inverse(mode=7)
' Set inverse attribute
    sgr(mode)

PUB italic()
' Set italicized attribute
    sgr(SGR_ITALIC)

PUB mousecursorposition = mouse_curs_pos
PUB mouse_curs_pos() | b, x, y
' Report Current mouse position (press mouse button to update)
'   Returns: Button pressed, X, Y coordinates (packed into long)
'       byte 0: X coordinate
'       byte 1: Y coordinate
'       byte 2: Button pressed/wheel movement:
'           0 - Left
'           1 - Middle
'           2 - Right
'           3 - Released
'           64- Mouse wheel up
'           65- Mouse wheel down
'   NOTE: The position is only updated when a mouse button is pressed or wheel is moved
    if charin() == ESC
        if charin() == "["
            if charin() == "M"
'               If we made it this far, it's a mouse position event
            else
                return 0
        else
            return 0
    else
        return 0

    b := charin-32                              ' button data = 32+button
    x := charin-33                              ' transform upper-left coords
    y := charin-33                              '   to 0, 0 instead of 1, 1
    result := (b << 16) | (y << 8) | x          ' Pack into the return value

PUB movedown = move_down
PUB move_down(rows=1)
' Move cursor down 1 or more rows
    csi()
    dec(rows)
    putchar("B")

PUB moveleft = move_left
PUB move_left(columns=1)
' Move cursor back/left 1 or more columns
    csi()
    dec(columns)
    putchar("D")

PUB moveright = move_right
PUB move_right(columns=1)
' Move cursor forward/right 1 or more columns
    csi()
    dec(columns)
    putchar("C")

PUB moveup = move_up
PUB move_up(rows=1)
' Move cursor up 1 or more rows
    csi()
    dec(rows)
    putchar("A")

PUB overline()
' Set Overline attribute
    sgr(SGR_OVERLINED)

PUB position = pos_xy
PUB pos_xy(x, y)
' position cursor at column x, row y (from top-left)
    csi()
    dec(y+1)                                    ' 1-base coordinates
    putchar(";")
    dec(x+1)
    putchar("f")

PUB positionx = pos_x
PUB pos_x(column)
' Set horizontal position of cursor
    csi()
    dec(column+1)                               ' 1-base coordinate
    putchar("G")

PUB positiony = pos_y
PUB pos_y(y)
' Set vertical position of cursor
    csi()
    dec(y+1)                                    ' 1-base coordinate
    putchar("d")

PUB reset()
' Reset terminal attributes
    csi()
    putchar("m")

PUB scrolldown = scroll_down
PUB scroll_down(lines=1)
' Scroll display down 1 or more lines
    csi()
    dec(lines)
    putchar("T")

PUB scrollup = scroll_up
PUB scroll_up(lines=1)
' Scroll display up 1 or more lines
    csi()
    dec(lines)
    putchar("S")

PUB semigfx = semi_gfx_ena
PUB semi_gfx_ena(enabled=1)
' Enable semi-graphics (e.g., line-drawing) mode
    case abs(enabled)
        1:
            str(string(ESC, "(", "0"))
        0:
            str(string(ESC, "(", "B"))

PUB showcursor = show_cursor
PUB show_cursor()
' Show cursor
    csi()
    putchar("?")
    dec(25)
    putchar("h")

PUB strikethru(mode=9)
' Set strike-through attribute
    sgr(mode)

PUB textwindow = text_win
PUB text_win(ptr_titlestr, x, y, w, h, brd_fg, brd_bg, ttl_fg)
' Draw a window with title string and border
'   x, y: upper-left coords of window
'   w, h: window dimensions (_outer_)
'   brd_fg, brd_bg: window border foreground, background colors
'   ttl_fg: title text fg color
    box(x, y, x+w, y+h-1, brd_fg, brd_bg, true)
    bgcolor(brd_bg)
    fgcolor(ttl_fg)

    pos_xy(x+2, y)                              ' display window title
    str(ptr_titlestr)

PUB underline(mode=4)
' Set Underline attribute
    sgr(mode)

PRI csi()
' Command Sequence Introducer
    putchar(ESC)
    putchar("[")

PRI sgr(mode)
' Select Graphic Rendition
    csi()
    dec(mode)
    putchar("m")

DAT
{
Copyright 2022 Jesse Burt

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute,
sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
}

