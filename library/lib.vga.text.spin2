CON

    STATE_NORMAL = 0
    STATE_ESCAPE = 1
    STATE_CSI = 2
    MAX_ESC_ARGS = 8

    CHAR_INVERSE = $01
    CHAR_BOLD = $02

    DEFAULT_FG_COLOR = $FFFFFF00
    DEFAULT_BG_COLOR = 0

VAR

    long curx, cury       ' cursor position
    long savex, savey
    long bgcolor, fgcolor ' current color
    long state
    long screenptr
    long args[MAX_ESC_ARGS]
    long argidx
    long char_effects

PRI InitTerminal

    ResetGraphicsState
    CLS
    curx := cury := 0
    state := STATE_NORMAL
    screenptr := @screen_buffer

PRI ResetGraphicsState

    bgcolor := DEFAULT_BG_COLOR
    fgcolor := DEFAULT_FG_COLOR
    char_effects := 0

PRI ScrollUp

    bytemove(screenptr, screenptr + 8*COLS, 8*(ROWS-1)*COLS)
    bytefill(screenptr + 8*(ROWS-1)*COLS, 0, 8*COLS)

PRI CheckPosition

    if curx => COLS
        curx := 0
        cury++
    elseif curx < 0
        curx := 0
    if cury => ROWS
        scrollup
        cury := ROWS-1
    elseif cury < 0
        cury := 0

PUB Char(c) | fg, bg

    if (state == STATE_NORMAL)
        case c
            8:
                --curx
            10:
                cury++
            13:
                curx := 0
            20:
                curx := (curx + 8) & ~7
            27:
                state := STATE_ESCAPE
            OTHER:
                fg := fgcolor
                bg := bgcolor
                if char_effects & CHAR_INVERSE
                    fg,bg := bg,fg  ' swap
                CheckPosition
                GlyphAt(curx, cury, c, fg, bg)
                curx++
    elseif (state == STATE_ESCAPE)
        HandleESC(c)
    elseif (state == STATE_CSI)
        HandleCSI(c)

PRI HandleESC(c) | i

    if (c == "[")
        repeat i from 0 to MAX_ESC_ARGS-1
            args[i] := 0
        argidx := 0
        state := STATE_CSI
    elseif (c == "c")
        InitTerminal
    else
        state := STATE_NORMAL

PRI DefaultVal(arg, v)

    return (arg) ? arg : v

PRI HandleCSI(c)
' Handle ANSI control sequences

{{
    glyphat(40, 10, c, $ffff0000, $00404000)
    pausems(1000)
}}
    if (c => "0" and c =< "9")
      args[argidx] := 10*args[argidx] + (c - "0")
      return
    argidx++
    if argidx == MAX_ESC_ARGS
      --argidx
    case c
        ";":
            return
        "A":
            cury -= defaultval(args[0], 1)
        "B":
            cury += defaultval(args[0], 1)
        "C":
            curx += defaultval(args[0], 1)
        "D":
            curx -= defaultval(args[0], 1)
        "E":
            cury += defaultval(args[0], 1)
            curx := 0
        "F":
            cury -= defaultval(args[0], 1)
            curx := 0
        "G":
            curx := defaultval(args[0], 1) - 1
        "H":
            cury := defaultval(args[0], 1) - 1
            curx := defaultval(args[1], 1) - 1
        "J":
            ClearInDisplay(defaultval(args[0], 0))
        "m":
            SetGraphicRendition(0)
        "s":
            savex := curx
            savey := cury
        "u":
            curx := savex
            cury := savey

    state := STATE_NORMAL

PUB GlyphAt(x, y, ch, fgcol, bgcol) | bufptr

    bufptr := @screen_buffer
    bufptr += (y*COLS + x) *8
    fgcol |= (ch & $FF)
    bgcol &= $FFFFFF00
    long[bufptr] := fgcol
    bufptr += 4
    long[bufptr] := bgcol

PUB CLS

   longfill(@screen_buffer, 0, COLS*ROWS*2)

PRI Clear(a, b) | ptr, cnt
' clear from position a to position b (inclusive)
    ptr := @screen_buffer + a
    cnt := b-a
    repeat while cnt => 0
        long[ptr] := fgcolor
        ptr += 4
        long[ptr] := bgcolor
        ptr += 4
        --cnt

PRI ClearInDisplay(n) | startpix, endpix
' Clear from cursor to end of display (if n==0) or from start of screen to cursor (n == 1)
' n==2 clears whole display and resets cursor to top
    case n
        2:
            curx := cury := 0
            n:=0
            startpix := COLS*cury + curx
            endpix := COLS*ROWS - 1
        1:
            startpix := 0
            endpix := COLS*cury + curx
        OTHER:
            startpix := COLS*cury + curx
            endpix := COLS*ROWS - 1

    clear(startpix, endpix)

PRI FetchArg(i)
' Get an argument that's already been set up, return -1 if not valid
    if i => argidx
        return -1
    return args[i]

PRI Hexdig(i)
' Debug routine

    if i =< 10
        return i + "0"
    return (i-10) + "A"

PRI SetGraphicRendition(i) | code, a, b

    if i > argidx
        return
    code := fetcharg(i++)

{{
  a := hexdig(code & $F)
  b := hexdig((code >> 4) & $F)
  glyphat(41, 10, b, $ffffff00, $00202000)
  glyphat(42, 10, a, $ffffff00, $00202000)
  pausems(1000)
}}
    case code
        0:
            ResetGraphicsState
        1:
            char_effects |= CHAR_BOLD
        7:
            char_effects |= CHAR_INVERSE
        21:
            char_effects &= !CHAR_BOLD
        22:
            char_effects &= !CHAR_BOLD
        27:
            char_effects &= !CHAR_INVERSE
        30..37:
            fgcolor := AnsiColor(code - 30)
        38:
            fgcolor,i := GetArgColor(i)
        39:
            fgcolor := DEFAULT_FG_COLOR
        40..47:
            bgcolor := AnsiColor(code - 40)
        48:
            bgcolor,i := GetArgColor(i)
        49:
            bgcolor := DEFAULT_BG_COLOR

    SetGraphicRendition(i)

DAT

    colortab
        long $00000000, $7F000000, $007F0000, $7F7F0000
        long $00007F00, $7F007F00, $007F7F00, $C0C0C000
        long $7F7F7F00, $FF000000, $00FF0000, $FFFF0000
        long $0000FF00, $FF00FF00, $00FFFF00, $FFFFFFFF

PRI ANSIColor(n) | ptr
' Look up an ANSI color from the color table
    if char_effects & CHAR_BOLD
        n += 8
    ptr := @colortab
    return long[ptr + 4*n]

PRI SixColor(x) | r, g, b
' Calculate an RGB color from a 6,6,6 encoded 8 bit color
    b := x // 6
    x := x / 6
    g := x // 6
    r := x / 6
    r := (255 * r)/6
    g := (255 * g)/6
    b := (255 * b)/6
    return (r<<24) | (g<<16) | b

PRI GetArgColor(i): col, newi | r, g, b, code
' Get a color out of arguments
    code := fetcharg(i++)
    if code == 0
        return 0, i
    if code == 2
        r := fetcharg(i++) & $FF
        g := fetcharg(i++) & $FF
        b := fetcharg(i++) & $FF
        return (r<<24 | g<<16 | b<<8), i
    if code == 5
        r := fetcharg(i++) & $FF
        if (r =< 15)
            r := colortab[r]
        elseif (r => 232)
            r := 10 * (r - 232)
            r +- 8
            return (r<<24 | r<<16 | r<<8), i
        else
            r := SixColor(r)
            return r, i
    return 0, i  ' punt for now

