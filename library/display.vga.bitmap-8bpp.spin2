{
    --------------------------------------------
    Filename: display.vga.bitmap-8bpp.spin2
    Description: 8-bits per pixel bitmap VGA driver (320x240)
    Modified by: Jesse Burt
    Started: Apr 6, 2020
    Updated: Sep 3, 2022
    See end of file for terms of use.
    --------------------------------------------
    NOTE: This is based on raycast5b_SpinDisplay2a.spin2,
        originally written by Rayman/Ray Allen
}
#define MEMMV_NATIVE bytemove
#include "lib.gfx.bitmap.spin2"

CON

    PIX_CLK     = 25_175_000
    BYTESPERPX  = 1
    MAX_COLOR   = 255
    HSYNC_PAR   = 0
    RED_PAR     = 1
    GREEN_PAR   = 2
    BLUE_PAR    = 3
    VSYNC_PAR   = 4
    PTR_FB_PAR  = 5

    INTENSITY   = 127                                        ' 0..128

' Character attributes
    DRAWBG      = 1 << 0

OBJ

    smartpins   : "core.con.smartpins"
    streamer    : "core.con.streamer"

VAR

    long _palette[256]
    long _cog, _params[6]
    long _ptr_dispbuff
    byte _vsync_pin

PUB Start(BASEPIN, WIDTH, HEIGHT, ptr_dispbuff): okay

    _ptr_palette := @_palette
    _params[HSYNC_PAR] := BASEPIN
    _params[RED_PAR] := BASEPIN+1
    _params[GREEN_PAR] := BASEPIN+2
    _params[BLUE_PAR] := BASEPIN+3
    _params[VSYNC_PAR] := BASEPIN+4
    _params[PTR_FB_PAR] := ptr_dispbuff

    _disp_width := WIDTH
    _disp_height := HEIGHT
    _disp_xmax := _disp_width-1
    _disp_ymax := _disp_height-1
    _bytesperln := 320
    _buff_sz := (WIDTH * HEIGHT)
    Address(ptr_dispbuff)
    _cog := okay := coginit(16, @DisplayEntry, @_params) + 1
    return

PUB Stop()

    if _cog
        cogstop(_cog-1)

PUB Defaults()
' Default timings for 640x480 signalling
    SetTimings(10, 33, 16, 96, 48, 640)

PUB Address(addr)
' Set address of display buffer
'   NOTE: Also sets address of (optional) offscreen buffer to the same address
    _ptr_dispbuff := addr
    _ptr_drawbuffer := addr

PUB CharAttrs(attrs)
' Set character attributes
    _char_attrs := attrs

PUB Clear()
' Clear the display
    longfill(_ptr_drawbuffer, _bgcolor, _buff_sz/4)

PUB DrawTo(addr)
' Set address of (optional) draw/render buffer
'   NOTE: This is typically used as an offscreen buffer,
'       to subsequently be copied to the display or "live" buffer,
'       once a complete frame is rendered.
    _ptr_drawbuffer := addr

PUB MirrorH(state)
' dummy method

PUB MirrorV(state)
' dummy method

PUB PalettePtr(): addr
' Pointer to palette data
    return @_palette

PUB Plot(x, y, color)
' Plot pixel at (x, y) in color
    if (x < 0 or x > _disp_xmax) or (y < 0 or y > _disp_ymax)
        return                                  ' coords out of bounds, ignore
#ifdef GFX_DIRECT
' direct to display
'   (not implemented)
#else
    byte[_ptr_drawbuffer][x + (y * _disp_width)] := color
#endif

#ifndef GFX_DIRECT
PUB Point(x, y): pix_clr
' Get color of pixel at x, y
    x := 0 #> x <# _disp_xmax
    y := 0 #> y <# _disp_ymax

    return byte[_ptr_drawbuffer][x + (y * _disp_width)]
#endif

PUB SetTimings(vfront, vback, hfront, hsync, hback, hvisible)
' Set video timings
'   vfront:     Vertical front porch
'   vback:      Vertical back porch
'   hfront:     Horizontal front porch
'   hsync:      Horizontal sync pulse
'   hback:      Horizontal back porch
'   hvisible:   Horizontal visible lines
    _vf := vfront
    _vb := vback
    _hf := STREAMER_SETUP | (1 << streamer.LUTBASE) + hfront/2
    _hs := STREAMER_SETUP | (1 << streamer.LUTBASE) + hsync/2
    _hb := STREAMER_SETUP | (1 << streamer.LUTBASE) + hback/2
    _hv := STREAMER_SETUP | (1 << streamer.LUTBASE) + hvisible/2

PUB Update()
' Write the draw buffer to the display
'   NOTE: This is only required when using double-buffering
    longmove(_ptr_dispbuff, _ptr_drawbuffer, _buff_sz/4)

PUB WaitVSync()
' Wait for vertical sync signal to be high
    repeat until _pinr(_params[VSYNC_PAR]) == 0
    repeat until _pinr(_params[VSYNC_PAR]) == 1

#ifndef GFX_DIRECT
PRI memFill(xs, ys, val, count)
' Fill region of display buffer memory
'   xs, ys: Start of region
'   val: Color
'   count: Number of consecutive memory locations to write
    bytefill(_ptr_drawbuffer + (xs + (ys * _bytesperln)), val, count)
#endif

DAT
                        orgh
DisplayEntry
                        org     0
'
'
' Setup
'
'l          c           i       o           e               c

                        ' calculate streamer frequency
                        rdlong  pa, #@clkfreq
                        qfrac   ##PIX_CLK, pa
                        getqx   pa
                        shr     pa, #2
                        setxfrq pa

                        rdfast  #0, _ptr_palette
                        rep     @.end, #$100
                        rflong  y
                        shl     y, #8
                        wrlut   y, x
                        add     x, #1
.end

                        rdlong  hsync_pin, ptra++
                        rdlong  red_pin, ptra++
                        rdlong  green_pin, ptra++
                        rdlong  blue_pin, ptra++
                        rdlong  vsync_pin, ptra++
                        rdlong  framebuff_addr, ptra++

'the next 4 lines may be commented out to bypass level scaling

                        setcy   ##INTENSITY << 24           'r  set colorspace for rgb
                        setci   ##INTENSITY << 16           'g
                        setcq   ##INTENSITY << 08           'b
                        setcmod #%01_0_000_0                'enable colorspace conversion

'RJA dacmodes changed for real P2
                        cogid   mycogid
                        shl     mycogid, #8
                        or      dacmode_s, mycogid
                        or      dacmode_c, mycogid

'RJA dacmodes changed for real P2
                        wrpin   dacmode_s, hsync_pin        'enable dac modes in pins 0..3
                        wrpin   dacmode_c, red_pin
                        wrpin   dacmode_c, green_pin
                        wrpin   dacmode_c, blue_pin
                        dirh    hsync_pin
                        dirh    red_pin
                        dirh    green_pin
                        dirh    blue_pin

'
' Field loop
'
field                   mov     x, _vb                      'top blanks
                        call    #blank
                        mov     m_buf, framebuff_addr
                        mov     x, #480/2                   'set visible lines

lineloop                call    #hsync                      'do horizontal sync
                        rdfast  ##640*1/64/2, m_buf         ' D=64 byte units (5 here, so 5*64 = 320)
                        xcont   m_rf, #0                    'visible line
                        call    #hsync                      'do horizontal sync
                        xcont   m_rf, #0                    'visible line
                        add     m_buf, #320
                        djnz    x, #lineloop                'another line?

                        mov     x, _vf                      'bottom blanks
                        call    #blank

                        drvnot  vsync_pin                   'sync on

                        mov     x, #2                       'sync blanks
                        call    #blank

                        drvnot  vsync_pin                   'sync off

                        jmp     #field                      'loop
'
' Subroutines
'
blank                   call    #hsync                      'blank lines
                        xcont   _hv, #0
            _ret_       djnz    x, #blank

hsync                   xcont   _hf, #0                    'horizontal sync
                        xcont   _hs, #1
            _ret_       xcont   _hb, #0

'
' Initialized data
'
dacmode_s               long    smartpins.DAC_123OHM_3V3 | smartpins.OUTPUT_ENABLED ' HSync
dacmode_c               long    smartpins.DAC_75OHM_2V0 | smartpins.OUTPUT_ENABLED  ' R, G, B

_vf                     long    0
_vb                     long    0
_hf                     long    0   ' Before sync
_hs                     long    0   ' Sync
_hb                     long    0   ' Before visible
_hv                     long    0   ' Visible

m_rf                    long    STREAMER_SETUP | (8 << streamer.LUTBASE) + 640/2    ' Visible RLONG 8BPP LUT

framebuff_addr          long    0
hsync_pin               long    0
red_pin                 long    0
green_pin               long    0
blue_pin                long    0
vsync_pin               long    0

x                       long    0
y                       long    0
m_buf                   long    0
_ptr_palette            long    0
mycogid                 long    0

CON

    STREAMER_SETUP  = streamer.RFLONG_LUT_8BIT | streamer.X3X2X1X0 | streamer.OUT_DISABLE

{
    --------------------------------------------------------------------------------------------------------
    TERMS OF USE: MIT License

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
    associated documentation files (the "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
    following conditions:

    The above copyright notice and this permission notice shall be included in all copies or substantial
    portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    --------------------------------------------------------------------------------------------------------
}

