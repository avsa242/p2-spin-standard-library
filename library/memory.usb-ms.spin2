'------------------------------------------------------------------------------
' Low/full speed Minimal USBHost & mass storage class driver.
' garryj 01/2019
' TABs as space, width: 8.
' Serial terminal: Tera Term, Parallax Serial Terminal (set the dterm_type
' register to the appropriate TERM_* constant).
' P2-ES Evaluation Board:
'   The USB D-/D+ data lines must be an adjacent even/odd pin pair, with the
'   lower (even) pin# assigned to DM constant and the upper (odd) pin assigned
'   to the DP constant.
'   Host activity is shown on the P56 LED.
'   Class driver activity is shown on the P57 LED.
'------------------------------------------------------------------------------
' Generic loader for the USB host/driver cog pair:
'  The host and driver cogs use LUT sharing, so they must be started as an
'  adjacent even/odd pair. The usb_start subroutine will attempt to locate and
'  start a free cog pair, so you'll want to ensure that all of cog resources
'  have been allocated.
' Integration of the USB boot mouse/keyboard code into your own program should
'  be relatively simple.
'  1 - Adapt the HubExec "usb_start" subroutine call into your startup code.
'  2 - Copy USB code and append to your program.
'  3 - Fix up any constant/label name collisions.
'  4 -
'------------------------------------------------------------------------------
dat
                org
loader_entry
'                hubset  #$ff                            ' Prop123-A9 FPGA: P2v26+ fixed at 80MHz
                hubset  #0                              ' Set 20MHz+ mode
                hubset  ##_FRQ_180 | _XOSC<<2           ' Configure oscillator to desired SYSCLOCK constant
                waitx   ##20_000_000/10                 ' Wait ~20ms for crystal + PLL to stabilize
                hubset  ##_FRQ_180 | _XOSC<<2 |_XSEL    ' Switch to PLL running at SYSCLOCK
                call    #usb_start                      ' Hub subroutine that attempts to locate a free even/odd cog pair
                tjz     pa, #.continue                  ' PA will be zero if free cogs found
.error
' Handle USB cog pair start error here.
.continue
' The loading program can continue on, or not.
                cogid   pa
                cogstop pa
'------------------------------------------------------------------------------
' vvvvvvvvvvvvvvvvvvvvvvvv Copy code from below to EOF vvvvvvvvvvvvvvvvvvvvvvvv
'------------------------------------------------------------------------------
' #region (Basics of P2 USB SmartPins)
{
  USB references:
  Universal Serial Bus Specification, Revision 2.0
    www.usb.org/developers/docs/usb20_docs/
  Device Class Definition for Human Interface Devices (HID), Version 1.11
    www.usb.org/developers/hidpage/
  Universal Serial Bus Mass Storage Class Bulk-Only Transport, Revision 1.0
    www.usb.org/developers/docs/devclass_docs/

  SCSI references:
    Seagate: SCSI Commands Reference Manual (SPC-5 and SBC-4)

  FAT file system reference:
    Microsoft Extensible Firmware Initiative
    FAT32 File System Specification
    Version 1.03, December 6, 2000

Smart pin configuration bits:
  D/# = %AAAA_BBBB_FFF_PPPPPPPPPPPPP_TT_MMMMM_0

USB smart pin modes (FPGA, test chip v1):
  %11000 = USB host, low-speed
  %11001 = USB host, full-speed
  %11010 = USB device, low-speed
  %11011 = USB device, full-speed

USB smart pin modes (scheduled for test chip v2):
  %11010 = USB host
  %11011 = USB device
  Low/Full speed is selected using X[15] of the NCO WXPIN value
  
These modes require that two adjacent pins be configured together to form a USB pair, whose OUTs
will be overridden to control their output states. These pins must be an even/odd pair, having
only the LSB of their pin numbers different. For example: pins 0 and 1, pins 2 and 3, pins 4
and 5, etc., can form USB pairs. They can be configured via WRPIN with identical D data of
%1_110xx_0. Using D data of %0_110xx_0 will disable output drive and effectively create a USB
'sniffer'. A new WRPIN can be done to effect such a change without resetting the smart pin.

NOTE: in the current FPGA, there are no built-in 1.5k and 15k resistors, which the final silicon
smart pins will contain, so it is up to you to insert these yourself on the DP and DM lines.

The upper (odd) pin is the DP pin. This pin's IN is raised whenever the output buffer empties,
signaling that a new output byte can be written via WYPIN to the lower (even) pin. No
WXPIN/WYPIN instructions are used for this pin.

The lower (even) pin is the DM pin. This pin's IN is raised whenever a change of status occurs in
the receiver, at which point a RDPIN can be used on this pin to read the 16-bit status word.
WXPIN is used on this pin to set the NCO baud rate.

These DP/DM electrical designations can actually be switched by swapping low-speed and full-speed
modes, due to USB's mirrored line signaling.

To start USB, clear the DIR bits of the intended two pins and configure them each via WRPIN. Use
WXPIN on the lower pin to set the baud rate, which is a 16-bit fraction of the system clock. For
example, if the main clock is 80MHz and you want a 12MHz baud rate (full-speed), use
12,000,000 / 80,000,000 * $10000 = 9830. Then, set the pins' DIR bits. You are now ready to read
the receiver status via RDPIN and set output states and send packets via WYPIN, both on the
lower pin.

To affect the line states or send a packet, use WYPIN on the lower pin. Here are its D values:
 0 = output IDLE        - default state, float pins, except possible resistor(s) to 3.3V or GND
 1 = output SE0         - drive both DP and DM low
 2 = output K           - drive K state onto DP and DM (opposite)
 3 = output J           - drive J state onto DP and DM (opposite), like IDLE, but driven
 4 = output EOP         - output end-of-packet: SE0, SE0, J, then IDLE
 $80 = SOP              - output start-of-packet, then bytes, automatic EOP when buffer runs out

To send a packet, first do a 'WYPIN #$80, lowerpin'. Then, after each IN rise on the upper pin,
do a 'AKPIN upperpin', followed by a 'WYPIN byte,lowerpin' to buffer the next byte. Bits 31..8
of your data bytes are ignored, but by keeping those upper bits clear, WYPIN will be able to do
the fastest transfer to the smart pin, which takes only 4 clocks. The transmitter will automatically
send an EOP when you stop giving it bytes. To keep the output buffer from overflowing, you should
always verify that the upper pin's IN was raised after each WYPIN, before issuing another
WYPIN, even if you are just setting a state. The reason for this is that all output activity is
timed to the baud generator and even state changes must wait for the next bit period before being
implemented, at which time the output buffer empties.

There are separate state machines for transmitting and receiving. Only the baud generator is common
between them. The transmitter was just described above. Below, the receiver is detailed. Note that
the receiver receives not just input from another host/device, but all local output, as well.

At any time, a RDPIN/RQPIN can be executed on the lower pin to read the current 16-bit status of the
receiver, with the error flag going into C. The lower pin’s IN will be raised whenever a change
occurs in the receiver’s status. This will necessitate A WRPIN/WXPIN/WYPIN/RDPIN/AKPIN before IN can
be raised again, to alert of the next change in status.

NOTE that after the pin is acknowledged, it will take at least two clocks for IN to drop, before it
can be polled again:
    AKPIN    pin                   ' Acknowledge smart pin, releases IN from high
    NOP                            ' Elapse two clocks (or more)
    TESTP    pin         WC        ' IN  can now be polled again

The receiver's status bits are as follows:
 [31:16] <unused>                - $0000
 [15:8]  byte                    - last byte received
 [7]     byte toggle             - cleared on SOP, toggled on each byte received
 [6]     error                   - cleared on SOP, set on bit-unstuff error, EOP SE0 > 3 bits, or SE1
 [5]     EOP in                  - cleared on SOP or 7+ bits of J or K, set on EOP
 [4]     SOP in                  - cleared on EOP or 7+ bits of J or K, set on SOP
 [3]     steady-state indicator  - cleared on line change, set on 7+ bits of no line change
 [2]     SE0 in         (RESET)  - cleared on !SE0, set on 1+ bits of SE0
 [1]     K in           (RESUME) - cleared on !K, set on 1+ bits of K
 [0]     J in           (IDLE)   - cleared on !J, set on 1+ bits of J
The result of a RDPIN can be bit-tested for events of interest. It can also be shifted right by 8
bits to LSB-justify the last byte received and get the byte toggle bit into C, in order to determine
if you have a new byte.
'------------------------------------------------------------------------------
' USB References:
' Universal Serial Bus Specification, Revision 2.0
'   www.usb.org/developers/docs/usb20_docs/
' Device Class Definition for Human Interface Devices (HID), Version 1.11
'   www.usb.org/developers/hidpage/
' Universal Serial Bus (USB) HID Usage Tables, Version 1.12
'   www.usb.org/developers/hidpage/Hut1_12v2.pdf
'------------------------------------------------------------------------------
}
' #endregion (Basics of P2 USB SmartPins)
' #region CON (USB Host)
con
' /* Constants specific to the development environment and P2 clock speed
' P2-ES board user LEDs tied to pins:
        #56, LED56, LED57, LED58, LED59, LED60, LED61, LED62, LED63
'        #40, LED56, LED57               ' Prop123-A9 FPGA user LED pin remapping
' USER_LEDs to show host feedback:
        HOST_ACTIVE_LED   = LED56       ' Blinks while in the host's main processing loop
' USER_LEDs to show driver feedback:
        DRIVER_ACTIVE_LED = LED57       ' Pulses during mouse activity
' Smart pin pair used for the USB transceiver:
'        DP           = 33                       ' DP is passive
'        DM           = 32                       ' DM is "The Brain"
        DP           = 27                       ' DP is passive
        DM           = 26                       ' DM is "The Brain"
'------------------------------------------------------------------------------
' Time units converted to clock cycles for the given P2 Mhz clock speed
' Clock Generator: %0000_000E_DDDDDD_MMMMMMMMMM_PPPP_CCSS
'        _XTALFREQ     = 20_000_000 ' Crystal frequency
'        _XDIV_500KHz  = 40
'        _XDIV_1MHz    = 20
'        _XDIV_2MHz    = 10
'        _XDIV_1_25MHz = 16
'        _XDIV_2_5MHz  = 8 
'        _XDIV_4MHz    = 5 
'        _XDIV_5MHz    = 4 
'------------------------------------------------------------------------------
'        _XPPPP = ((_XDIVP >> 1) + 15) & $f ' (_XDIVP = 1)->15, 2->0, 4->1, 6->2...30->14
'       _FRQ_*  = 1 << 24 | (_XDIV - 1) << 18 | (_XMUL - 1) << 8 | _XPPPP << 4 | _XOSC << 2
'       _CLK    = _XTALFREQ / _XDIV * _XMUL / _XDIVP
'------------------------------------------------------------------------------
'        _FRQ_80    = 1<<24|(20-1)<<18|(160-1)<<8|((2>>1+15)&$f)<<4
'        _FRQ_84    = 1<<24|(20-1)<<18|(168-1)<<8|((2>>1+15)&$f)<<4
'        _FRQ_96    = 1<<24|(20-1)<<18|(192-1)<<8|((2>>1+15)&$f)<<4
'        _FRQ_108   = 1<<24|(20-1)<<18|(108-1)<<8|((1>>1+15)&$f)<<4 
'        _FRQ_120   = 1<<24|(20-1)<<18|(120-1)<<8|((1>>1+15)&$f)<<4 
'        _FRQ_132   = 1<<24|(20-1)<<18|(132-1)<<8|((1>>1+15)&$f)<<4 
'        _FRQ_144   = 1<<24|(20-1)<<18|(144-1)<<8|((1>>1+15)&$f)<<4 
' My USB analyzer flags the full-speed 1ms start-of-frame packets as having timing
' jitter if a fractional SYSCLOCK is set, e.g. 148.5Mhz. If the device type that's
' connected ignores the full-speed 1ms start-of-frame packets (it looks like mass
' storage devices do), they will likely work.
'        _FRQ_148_5 = 1<<24|(40-1)<<18|(297-1)<<8|((1>>1+15)&$f)<<4 ' Frame timing jitter
'        _FRQ_150   = 1<<24|(20-1)<<18|(150-1)<<8|((1>>1+15)&$f)<<4
'        _FRQ_156   = 1<<24|(20-1)<<18|(156-1)<<8|((1>>1+15)&$f)<<4
'        _FRQ_160   = 1<<24|(20-1)<<18|(160-1)<<8|((1>>1+15)&$f)<<4
'        _FRQ_168   = 1<<24|(20-1)<<18|(168-1)<<8|((1>>1+15)&$f)<<4
        _FRQ_180   = 1<<24|(20-1)<<18|(180-1)<<8|((1>>1+15)&$f)<<4
'        _FRQ_192   = 1<<24|(20-1)<<18|(192-1)<<8|((1>>1+15)&$f)<<4
'        _FRQ_200   = 1<<24|(20-1)<<18|(200-1)<<8|((1>>1+15)&$f)<<4
'        _FRQ_216   = 1<<24|(10-1)<<18|(108-1)<<8|((1>>1+15)&$f)<<4
'        _FRQ_240   = 1<<24|(10-1)<<18|(120-1)<<8|((1>>1+15)&$f)<<4
'        _FRQ_250   = 1<<24|(10-1)<<18|(125-1)<<8|((1>>1+15)&$f)<<4
'        _FRQ_260   = 1<<24|(20-1)<<18|(260-1)<<8|((1>>1+15)&$f)<<4
'        _FRQ_300   = 1<<24|(10-1)<<18|(150-1)<<8|((1>>1+15)&$f)<<4
'        _FRQ_360   = 1<<24|(10-1)<<18|(180-1)<<8|((1>>1+15)&$f)<<4
'------------------------------------------------------------------------------
        _XOSC      = %10        ' OSC:    %00=OFF, %01=OSC, %10=15pF, %11=30pF
        _XSEL      = %11        ' XI+PLL: %00=rcfast(20+MHz), %01=rcslow(~20KHz), %10=XI(5ms), %11=XI+PLL(10ms)
        SYSCLOCK   = 180_000_000.0 ' Don't forget to set SYSCLOCK to match the above MHz rate being used!
'------------------------------------------------------------------------------
        _12Mbps      = round((12_000_000.0 / SYSCLOCK) * 65536.0) ' = 4369 NCO @180MHz, 9830 @80MHz
        _1_5Mbps     = round((1_500_000.0 / SYSCLOCK) * 65536.0)  ' = 546 NCO @180MHz, 1229 @80Mhz
        _1ms         = round(SYSCLOCK / 1_000.0)
        _1us         = round(float(_1ms) / 1_000.0)
        _100ns       = round(float(_1us) / 1_000.0 * 100.0)
        LSBTns       = 667.0                    ' Low-Speed bit period, in nanoseconds
        FSBTns       = 83.54                    ' Full-Speed bit period, in nanoseconds
        _1LSBT       = round(SYSCLOCK / 1_000_000_000.0 * LSBTns)' = 53 clocks @ 80Mhz, 80 clocks @ 120Mhz
        _1FSBT       = round(SYSCLOCK / 1_000_000_000.0 * FSBTns)' = 7 clocks @ 80Mhz, 10 clocks @ 120Mhz

' /* Time delays and intervals
' Useful USB constants and wait intervals:
        CONNECT_WAIT    = _1ms * 250            ' Connect/disconnect verification delay
        RESET_HOLD      = _1ms * 15             ' Host reset state hold time
        XFER_RETRIES    = 12                    ' Maximum retries before retiring a transfer
        TXN_RETRIES     = 12                    ' Maximum retries before retiring a transaction
        NAK_NOLIMIT     = 0                     ' Unlimited NAK retries
        IN_NAK_RETRIES  = 50000                 ' Control transfer IN-NAK retry limit (0 = unlimited)
        OUT_NAK_RETRIES = 50000                 ' Control transfer OUT-NAK retry limit (0 = unlimited)
        XFER_WAIT       = _1ms * 5              ' Transfer retry wait timespan
' Standard Device request maximum timeout periods:
        TO_STANDARD  = _1ms * 5000              ' Non-specific maximum timout period
        TO_DATA      = _1ms * 500               ' Standard Device requests with a data stage
        TO_NODATA    = _1ms * 50                ' Standard Device requests without a data stage
        TO_SETADDR   = _1ms * 50                ' Device SetAddress() command processing maximum
        TO_CHGADDR   = _1ms * 2                 ' Device SetAddress() period allowed to change its address before next request sent
'------------------------------------------------------------------------------
' Low-Speed inter-packet delay, in bit periods (Section 7.1.18). For the host,
' the range is a minimum of two bit periods and a maximum of 7.5 bit periods:
'------------------------------------------------------------------------------
        IP_DELAY_LS  = round(3.5 * LSBTns * float(_1us) / 1000.0) ' Range @180MHz: 240 to 901 clocks (1.334us to 5.003us)
        IP_DELAY_FS  = round(3.5 * FSBTns * float(_1us) / 1000.0) ' Range @180MHz: 30 to 112  clocks (0.166us to 0.623us)
'------------------------------------------------------------------------------
' End-to-end signal delay, in bit periods (Section 7.1.19), measured at the
' data pins of the device from the SE0-to-J transition at the end of the EOP.
' For example, when a device transmits the data for an IN transaction, it will
' wait at least 16 bit periods for the host handshake response, but no more
' than 18 bit periods:
'   Low-Speed:  10.672us..12.006us (@80MHz: 853.8 to 960.5 clocks).
'   Full-Speed: 1.238us..1.494us (@80MHz: 106.2 to 119.5 clocks).
' When the host transmits data e.g. an OUT transaction, it must wait at least
' 18 bit periods before it will timeout the response and start a new transaction.
'------------------------------------------------------------------------------
        TAT_WAIT_LS  = round(22.0 * LSBTns * float(_1us) / 1000.0)
        TAT_WAIT_FS  = round(28.0 * FSBTns * float(_1us) / 1000.0)
'------------------------------------------------------------------------------
' Interrupt service routine timespans for 1ms interval frame generation.
' Target resolution is 1.00ms +/- 0.0005ms. At full-speed, a numbered
' start-of-frame packet is issued. At low-speed, a single EOP is issued as a
' "keep-alive" strobe to prevent a device from entering suspend mode.
'------------------------------------------------------------------------------
        TXN_OK_LS    = _1us * 667 - 6           ' All USB transactions must be started within this timespan
        NO_TXN_LS    = _1us * 333 - 7           ' Low-speed needs ~33% bandwidth per max packet of 8 bytes
        TXN_OK_FS    = _1us * 825 - 6           ' Full-speed needs ~10% bandwidth per max packet of 64 bytes
        NO_TXN_FS    = _1us * 175 - 7
' Non-USB related time intervals:
        PULSE_TIME   = _1ms * 750               ' LED-blinking heartbeat interval
' */
' /* PID tokens
'------------------------------------------------------------------------------
' Token packet format.
'------------------------------------------------------------------------------
'                       CRC5  ENDP ADDRESS PID
        CRC_MASK     = %11111_0000_0000000_00000000
        EP_MASK      = %00000_1111_0000000_00000000
        ADDR_MASK    = %00000_0000_1111111_00000000
        EP_ADDR_MASK = %00000_1111_1111111_11111111
        EP_ADDR_ZERO = %00010_0000_0000000_00000000     ' CRC5 = $02 for addr zero, ep zero
'------------------------------------------------------------------------------
' Packet Identifier Bytes (PID). Notice that the first two LSBits are
' identical for each group.
'------------------------------------------------------------------------------
' Token:
        PID_OUT   = %1110_0001                  ' $e1
        PID_IN    = %0110_1001                  ' $69
        PID_SOF   = %1010_0101                  ' $a5
        PID_SETUP = %0010_1101                  ' $2d

' Data:
        PID_DATA0 = %1100_0011                  ' $c3
        PID_DATA1 = %0100_1011                  ' $4b
        PID_DATA2 = %1000_0111                  ' $87
        PID_MDATA = %0000_1111                  ' $0f

' Handshake:
        PID_ACK   = %1101_0010                  ' $d2
        PID_NAK   = %0101_1010                  ' $5a
        PID_STALL = %0001_1110                  ' $1e
        PID_NYET  = %1001_0110                  ' $96
' Special:
        PID_PRE   = %0011_1100                  ' $3c
        PID_ERR   = %0011_1100                  ' $3c
        PID_SPLIT = %0111_1000                  ' $78
        PID_PING  = %1011_0100                  ' $b4
        PID_RESVD = %1111_0000                  ' $f0
' */
' /* Tx, rx and host related constants
' USB transmitter WYPIN D line state options:
        OUT_IDLE = 0
        OUT_SE0  = 1
        OUT_K    = 2
        OUT_J    = 3
        OUT_EOP  = 4
        OUT_SOP  = $80
' USB receiver RDPIN status bit positions:
        #0, J_IDLEB, K_RESUMEB, SE0_RESETB, SE1_BADB, SOPB, EOPB, BUS_ERRB, BYTE_TGLB
' USB receiver RDPIN status bitflags:
        J_IDLEF    = |< J_IDLEB
        K_RESUMEF  = |< K_RESUMEB
        SE0_RESETF = |< SE0_RESETB
        SE1_BADF   = |< SE1_BADB
        SOPF       = |< SOPB
        EOPF       = |< EOPB
        BUS_ERRF   = |< BUS_ERRB
        BYTE_TGLF  = |< BYTE_TGLB
' USB CRC constants:
        USB5_POLY      = %0_0101 >< 5           ' USB5 polynomial is reflected when calculating CRC
        USB5_RESIDUAL  = %0_1100 >< 5           ' Expected CRC5 residual value when checking received data
        USB16_POLY     = $8005 >< 16            ' USB16 polynomial is reflected when calculating CRC
        USB16_RESIDUAL = $800d >< 16            ' Expected CRC16 residual value when checking received data
' Host->class driver USB connect speed:
        #0, USB_SPEED_UNKNOWN, USB_SPEED_LOW, USB_SPEED_FULL
' Protocol error codes:
        #0, ERR_NONE, ERR_URX, ERR_SE1, ERR_PACKET, ERR_TAT, ERR_TXN_RETRY, ERR_XFER_RETRY
        ERR_NAK, ERR_ACK_RETRY, ERR_EMPTY_PKT, ERR_RX_CRC, ERR_DATAX_SYNC, ERR_END
' Debug stuff:
        DBG_FEEDBEEF = $efbeedfe                ' Handy byte sequence for hex search in .obj files
        DBG_C0DEDEAD = $addedec0                ' End of cog/lut code marker
        DBG_DADADEAD = $addedada                ' End of data marker
' Host status bit positions. Bit4 and bit5 use the receiver status constants for SOP and EOP:
        #0, IDLEB, CONNECTEDB, LOW_SPEEDB, DATAx_TGLB, TXN_LIMITB[4], DWNSTRM_HUBB
' Host status bitflags. Unless otherwise noted, bit states are active high:
        IDLEF        = |< IDLEB                 ' Set when USB in idle state
        CONNECTEDF   = |< CONNECTEDB            ' USB device connected
        LOW_SPEEDF   = |< LOW_SPEEDB            ' Low-speed device connected, clear if full-speed
        DATAx_TGLF   = |< DATAx_TGLB            ' Cleared if sending DATA0 packet, set if sending DATA1 packet
        TXN_LIMITF   = |< TXN_LIMITB            ' No-go area to prevent transactions from spanning frame boundary
'       EOPF         = |< EOPB                  ' Same bit position as the USB receiver RDPIN constant defined above
'       BUS_ERRF     = |< BUS_ERRB              ' Same bit position as the USB receiver RDPIN constant defined above
'       BYTE_TGLF    = |< BYTE_TGLB             ' Same bit position as the USB receiver RDPIN constant defined above
        DWNSTRM_HUBF = |< DWNSTRM_HUBB          ' Not yet implemented
' */
' /* LUT allocation:
'------------------------------------------------------------------------------
' LUT sharing between the host cog and the class driver cog is enabled. There
' is no address partitioning, so both cogs must be aware of all LUT address
' ranges that are in use. The host cog and class driver cogIDs must be an
' adjacent even/odd pair.
'------------------------------------------------------------------------------
' LUT locations tied to selectable-events:
'------------------------------------------------------------------------------
        H_EVENT       = $1fc            ' Class driver cog writes to this host LUT address
        H_EVENT_WR1FC = %000_00_1100    ' Setup bits for host POLLSE1/WAITSE1 selectable-event
        D_EVENT       = $1fd            ' Host cog writes to this class driver LUT address
        D_EVENT_WR1FD = %000_00_1101    ' Setup bits for class driver POLLSE1/WAITSE1 selectable-event
' Bits used in SETWRL/SETRDL setup:
        LSHARE_READ   = 0               ' The other cog can read this LUT
        LSHARE_WRITE  = 1               ' The other cog can write this LUT
' LUT locations 0..255 are free to be used by the class driver cog.
' LUT locations 256..LSHARE_BASE - 1 are free to be used by the host cog.
        DLUT_BASE     = $000
        DLUT_TOP      = $0ff
        HLUT_BASE     = $100
        HLUT_TOP      = LSHARE_BASE - 1 ' Reserve the remaining LUT locations for the LUT shared interface
        LSHARE_BASE   = H_EVENT - 6     ' Base LUT location for command/request processing via LUT sharing
        #LSHARE_BASE                    ' Start of the host/driver LUT shared interface
        H_PAR1, H_PAR2, H_PAR3          ' Host/driver ommand/request parameter locations
        D_PAR1, D_PAR2, D_PAR3
'------------------------------------------------------------------------------
' USB I/O request events from the class driver that are recognized by the host
' cog. At this time there is no event queueing, so the class driver must
' poll/wait until for the host driver to post H_READY before it can post a new
' event. The event mechanism is asynchronous. It works, but the implementation
' in its current form is somewhat clumsy. For both cogs, a POLLSE1 event is
' triggered when its odd/even partner posts an eventID to its assigned LUT
' location.
'
' When the class driver posts a USB I/O request to the host's eventID LUT
' location, the transaction is not considered to be complete until the host
' posts a DTXN_RESULT event to the class driver. The event parameters contain
' the transaction type executed and its result code. Since all event postings
' are asynchronous, the class driver assigns the address of a routine that
' understands the context of the posted IRP, making a fairly simple callback
' mechanism to handle the IRP result.
'------------------------------------------------------------------------------
'       Class Driver->Host        H_PAR1        H_PAR2          H_PAR3          Description
        #0, H_READY             ' n/a           n/a             n/a             Host ready to process event
        HCTRL_READ              ' ctrlep/addr   SETUP addr      IN data addr    ControlRead()
        HCTRL_WRITE             ' ctrlep/addr   SETUP addr      OUT data addr   ControlWrite()
        HINT_IN                 ' epN/addr      IN data addr    max_pkt|DATAx   InterruptIN(), word1 max_pkt, word0 DATAx to expect
        HINT_OUT                ' epN/addr      OUT data addr   pkt_len|DATAx   InterruptOUT(), word1 pkt_len, word0 DATAx to tx
        HBULK_IN                ' addr of IN transfer parameter block struct    H_PAR2 and H_PAR3 unused
        HBULK_OUT               ' addr of OUT transfer parameter block struct   H_PAR2 and H_PAR3 unused
' Last event in the jump table, useful when testing/debugging:
        H_END = HBULK_OUT
'------------------------------------------------------------------------------
' Events recognized by the class driver cog. At this time there is no event
' queueing, The host must poll/wait for the class driver to post D_READY before
' it can post a new event. These events don't require a post-event response to
' the host, so they are implemented as a jump table.
'------------------------------------------------------------------------------
'       Host->Class Driver        D_PAR1        D_PAR2          D_PAR3          Description
        #0, D_READY             ' n/a           n/a             n/a             Driver ready to process event
        DREQ_ASCIIZ             ' ASCIIZ addr   n/a             n/a             Output zero-terminated string at addr
        DREQ_BREAK              ' debug long    n/a             n/a             Debug breakpoint (host and driver halt)
        DREQ_DBG_DATA           ' debug long    n/a             n/a             Arbitrary debug value (host and driver continue)
        DREQ_HEXDUMP            ' start addr    end addr        _BYTE_/_LONG_   16 bytes or four longs per line, one line if end addr = 0
        DINF_CONNECT            ' speed         n/a             n/a             Device connected, not yet configured, at given speed
        DINF_DISCONNECT         ' ctrlep/addr   n/a             n/a             Device at ep0/addr disconnected
        DINF_DEV_DESC           ' ctrlep/addr   buff addr       result code     Device descriptor available at buff_addr
        DINF_CON_DESC           ' ctrlep/addr   buff addr       result code     Configuration descriptor available at buff addr
'------------------------------------------------------------------------------
' The below event is posted by the host to notify the class driver that the
' USB I/O request event that had been previously posted by the class driver has
' completed. If the result is an error that the class driver cannot recover
' from, it should put itself into an idle state.
'------------------------------------------------------------------------------
        DTXN_RESULT
' Control transfer result:      ' CRC/ep/addr   overall result  context result
' IN transaction result:        ' CRC/ep/addr   result code     bytes received
' OUT transaction result:       ' CRC/ep/addr   result code     bytes sent
'------------------------------------------------------------------------------
' The below event is a mechanism the host cog can use to notify the class
' driver (or end user) that the host has completed a USB I/O action that was
' NOT requested by the class driver. In general, if the result code is not
' "ACK", it is likely that the host has encountered an error that it could not
' recover from, and it has entered an idle state. Given this, the class driver
' routine that processes this event will send the result details to the
' terminal and put itself into an idle state also.
'
' NOTE: once the class driver has configured the device and is issuing USB
' I/O requests, this event should no longer be used, as the host reports I/O
' results through the above DTXN_RESULT event.
'------------------------------------------------------------------------------
        DTXN_HRESULT            ' ASCIIZ addr   result code     n/a             Addr of result description string, ACK/NAK/STALL result code
'------------------------------------------------------------------------------
' Last event in the jump table, useful when testing/debugging:
        D_END = DTXN_HRESULT
' */
' #endregion CON (USB Host)
' #region DAT (Host Cog)
'------------------------------------------------------------------------------
' When an even/odd cog pair are started using (coginit %1_1_0001, addr), both
' cogs initially have this load address (usb_host). Choose the even (lower) cog
' ID to be the host, and load/restart the odd (upper) cog using the class
' driver address.
'------------------------------------------------------------------------------
dat
                org
usb_host
                cogid   hr0                             ' This cogID could be either even or odd
                testb   hr0, #0                 wc      ' Which one are we (NC==even, C==odd)?
        if_c    coginit hr0, ##@class_driver            ' Odd cog loads driver code and restarts itself
' Now the host can get going...
' vvvvvvvvvvvvvvvvvvvvvvvvvv
' /* usb_host_start
'------------------------------------------------------------------------------
' The USB host cog.
'------------------------------------------------------------------------------
usb_host_start
' FIXME: kludge to set a USB tx byte write AKKPIN<->WRPIN delay. It looks like
' it might be an off-clock rise of the DP tx buffer ready flag or maybe PLL
' jitter mangling a data byte, causing the packet CRC to fail.
                mov     utx_tweak, #utx_byte
                mov     htmp, ##round(SYSCLOCK)
                cmp     htmp, ##168_000_000     wcz
        if_be   mov     utx_tweak, #3
        if_a    mov     utx_tweak, #20
                drvl    #HOST_ACTIVE_LED
                waitx   ##_1ms * 5000                   ' Delay to allow time for the driver and serial output to start
                setluts #LSHARE_WRITE                   ' Allow class driver cog to write this LUT
                setse1  #H_EVENT_WR1FC                  ' Class driver write to LUT location H_EVENT triggers this event
                call    #hload_lut                      ' Host & driver LUT space is shared; load lut code/data from hub RAM, if any
                wrlut   #H_READY, #H_EVENT              ' Initialize shared LUT eventID
                mov     ijmp1, #isr1_frame              ' Set the USB 1ms frame handler ISR routine
                jmp     #host_reset                     ' Initialize host and enter main processing loop
' */
' /* do_hevent
'------------------------------------------------------------------------------
' Handler jump table for events posted to the host by the class driver cog.
'------------------------------------------------------------------------------
do_hevent
                incmod  hactive, ##1000         wc
        if_c    drvnot  #HOST_ACTIVE_LED
                rdlut   hevent, #H_EVENT
                fle     hevent, #H_END
                push    #end_hevent                     ' All jump table entries are CALL targets
                mov     context_retval, #ERR_NONE       ' Assume overall operation success
                jmprel  hevent
hevent_jmp
                ret                                     ' EventID zero is a NOP
                jmp     #do_ctrl_read
                jmp     #do_ctrl_write
                jmp     #do_int_in
                jmp     #do_int_out
                jmp     #do_bulk_in
                jmp     #do_bulk_out
end_hevent
        _ret_   wrlut   #H_READY, #H_EVENT              ' Ready for next event posting
' */
' /* post_devent
'------------------------------------------------------------------------------
' Post an eventID to be handled by the class driver cog. These are "push"
' events that do not require a response from the driver cog.
'------------------------------------------------------------------------------
' On entry:
'   hevent - eventID to post.
'   hpar1, hpar2, hpar3 - eventID parameters, if needed.
' On exit:
'------------------------------------------------------------------------------
post_devent
                rdlut   htmp, #D_EVENT          wz      ' Wait for any pending class driver event to complete
        if_nz   jmp     #post_devent
                wrlut   hpar1, #D_PAR1
                wrlut   hpar2, #D_PAR2
                wrlut   hpar3, #D_PAR3
        _ret_   wrlut   hevent, #D_EVENT                ' This driver LUT location is the write event trigger for the event request
' */
' /* txn_setup
'------------------------------------------------------------------------------
' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
' special because the receiving function must not respond with either STALL or
' NAK, and must accept the DATAx packet that follows the SETUP token. If a
' non-control endpoint receives a SETUP token, or the function receives a
' corrupt packet, it must ignore the transaction
'------------------------------------------------------------------------------
' On entry:
'   PTRA - start address of the SETUP data struct.
' On exit:
'   retval - PID_ACK on success, otherwise error code.
'------------------------------------------------------------------------------
txn_setup
                setbyte ep_addr_pid, #PID_SETUP, #0
                mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
                bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
                mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
                mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
.setup
                call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
                cmp     retval, #PID_ACK        wz
        if_z    ret
                call    #retry_wait
                cmp     retval, #ERR_TXN_RETRY  wz
        if_z    ret
                mov     ptra, pa                        ' Restore SETUP's DATAx pointer
                jmp     #.setup
' */
' /* txn_in
'------------------------------------------------------------------------------
' IN/INTERRUPT transaction.
' Possible function response: STALL or NAK handshake, or DATAx packet.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - PID_IN(b0..7), address(b8..b14), endpoint(b15..18) and
'     CRC(b19..23).
' On exit:
'------------------------------------------------------------------------------
txn_in
                call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
                setbyte ep_addr_pid, #PID_IN, #0
                call    #utx_token                      ' Put IN request on the bus
' Fall through to urx_packet
' vvvvvvvvvvvvvvvvvvvvvvvvvv
' */
' /* urx_packet
'------------------------------------------------------------------------------
' Wait for a packet from a device/function. As host, the only two packet types
' received are handshakes and IN DATAx.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   retval - the ID of the packet. If a PID fails validation, ERR_PACKET is
'     returned.
'------------------------------------------------------------------------------
urx_packet
                rqpin   urx, #DM                        ' Wait until start-of-packet signal appears on the USB.
                testb   urx, #SOPB              wc
        if_c    jmp     #urx_packet
                getct   hct2
                addct2  hct2, tat_wait                  ' Start the response turn-around timer
                bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
                mov     newb_flg, #0                    ' Initialize for multi-byte read
.wait_sop
                rdpin   urx, #DM
                testb   urx, #SOPB              wc
        if_c    jmp     #.get_pid
                jnct2   #.wait_sop
        _ret_   mov     retval, #ERR_TAT
.get_pid
                call    #urx_next
                testb   urx, #BUS_ERRB          wc
        if_nc   jmp     #.chk_pid
        _ret_   mov     retval, #ERR_URX
.chk_pid
                cmp     retval, #PID_ACK        wz
        if_nz   cmp     retval, #PID_NAK        wz
        if_nz   cmp     retval, #PID_STALL      wz
        if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
                testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
                cmp     retval, #PID_DATA0      wz
   if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
   if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the device must have missed
                cmp     retval, #PID_DATA1      wz
   if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
   if_z_and_nc  jmp     #.ack_resend
        _ret_   mov     retval, #ERR_PACKET             ' Some other bus error...
.ack_resend
                rqpin   urx, #DM
                testb   urx, #EOPB              wc
        if_nc   jmp     #.ack_resend
                mov     retval, #PID_ACK
                call    #utx_handshake                  ' Send handshake PID and return to caller
        _ret_   mov     retval, #ERR_DATAX_SYNC
.chk_eop
                testb   hstatus, #LOW_SPEEDB    wc
        if_nc   jmp     #.idle                          ' Full-speed doesn't need an additional read to get EOP status
                call    #urx_next                       ' Low-speed requires an additional read to get EOP status
                testb   hstatus, #EOPB          wc
        if_c    jmp     #.idle                          ' Low-speed EOP seen
                testb   urx, #BUS_ERRB          wz
        if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
        if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
                ret
.idle
                rqpin   urx, #DM
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
                ret
' */
' /* utx_token
'------------------------------------------------------------------------------
' Send a token packet with CRC5 checksum of address and endpoint. It is the
' responsibility of the caller to append the appropriate inter-packet delay,
' if one is required.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - packed with the PID, address and endpoint.
' On exit:
'------------------------------------------------------------------------------
utx_token
                rqpin   urx, #DM
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #utx_token
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync byte
                mov     htmp, ep_addr_pid               ' Preserve the PID and destination
                mov     pkt_cnt, #3
.next_byte
                getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
                shr     htmp, #8                        ' Shift to next byte to send
.wait
                testp   #DP                     wc
        if_nc   jmp     #.wait
                akpin   #DP
                wypin   utx, #DM
        _ret_   djnz    pkt_cnt, #.next_byte
' */
' /* txn_out
'------------------------------------------------------------------------------
' SETUP/OUT/INTERRUPT transaction.
' Possible function response in order of precedence: STALL, ACK, NAK.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - PID_OUT(b0..7), address(b8..b14), endpoint(b15..18) and
'     CRC(b19..23).
'   PTRA - start address of the data buff/struct that has the bytes to send.
'   pkt_data - count of DATAx payload bytes to send.
' On exit:
'------------------------------------------------------------------------------
txn_out
                call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
                call    #utx_token                      ' Put SETUP/OUT token on the bus
                rdfast  ##(|< 31), ptra                 ' Use hub RAM FIFO interface to read the tx buffer
                mov     pkt_cnt, pkt_data
' Fall through to utx_data
' vvvvvvvvvvvvvvvvvvvvvvvv
' */
' /* utx_data
'------------------------------------------------------------------------------
' Transmit a DATAx packet with USB-16 checksum of payload. The payload CRC is
' calculated while the data byte is being shifted out. Since data stage
' success/fail is not determined until the status stage of the transaction,
' this routine is only concerned about the current DATAx packet.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - hub start address of the data to read.
'   pkt_cnt - data payload size.
' On exit:
'------------------------------------------------------------------------------
utx_data
                rqpin   urx, #DM
                testb   urx, #SOPB              wc
        if_c    jmp     #utx_data
                mov     hctwait, ip_delay
                call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync
                bmask   crc, #15                        ' Prime the CRC16 pump
                testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
        if_nc   mov     utx, #PID_DATA0
        if_c    mov     utx, #PID_DATA1
                call    #utx_byte                       ' No CRC calc done on PID
                cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
        if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
.read_byte
                rfbyte  utx                             ' Fetch data byte
                call    #utx_byte
'               rdpin   hpar1, #DM
'               testb   hpar1, #BUS_ERRB        wc
'       if_c    call    #dbg_data
                rev     utx                             ' Calculate CRC while the data is shifting out
                setq    utx                             ' SETQ left-justifies the reflected data byte
                crcnib  crc, ##USB16_POLY               ' Run CRC calc on the data nibs
                crcnib  crc, ##USB16_POLY
                djnz    pkt_cnt, #.read_byte
.send_crc
                xor     crc, ##$ffff                    ' Final XOR, and send the calculated CRC16
                getbyte utx, crc, #0
                call    #utx_byte
                getbyte utx, crc, #1
                call    #utx_byte                       ' Last CRC byte out
                jmp     #urx_packet                     ' Handle function response/error and back to caller
' */
' /* urx_data
'------------------------------------------------------------------------------
' Receive a DATAx_ payload with USB-16 checksum. The CRC is calculated as the
' payload bytes are received. The routine reads bytes until EOP is detected and
' expects that the packet includes at least the CRC word.
'
' In control transfers, it's possible to recieve fewer data bytes than what
' was requested, which makes it difficult to determine where the data stops
' and the CRC word begins. So the CRC calculation is done on every byte of the
' packet, including the CRC word. The CRC value should then be equal to the
' USB-16 expected residual value of 0xB001.
'
' The routine writes the IN packet data to a static max_packet_size buffer
' so the caller can verify IN success before writing the data to its final
' destination.
'------------------------------------------------------------------------------
' On entry:
'   pkt_data - max byte count expected to be in the packet.
'   newb_flg - signals new byte ready when toggled.
' On exit:
'   pkt_cnt - actual number of bytes read.
'------------------------------------------------------------------------------
urx_data
                wrfast  ##(|< 31), ##urx_buff           ' Use hub RAM FIFO interface to buffer bytes received
                bmask   crc, #15                        ' Prime the CRC16 pump
                mov     pkt_cnt, #0                     ' Keep track of payload bytes received
                mov     pkt_tmp, pkt_data
                add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
.wait_byte
' In-line rx for max speed
                rqpin   urx, #DM
                mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
                and     utx, urx
                cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
        if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
        if_nz   jmp     #.get_byte                      ' New byte!
                testb   urx, #EOPB              wc
        if_c    jmp     #.chk_crc                       ' At end-of-packet
                jmp     #.wait_byte
.get_byte
                getbyte retval, urx, #1                 ' New byte from smartpins
                wfbyte  retval                          ' Add it to the data buffer
                rev     retval                          ' Calculate CRC while next byte is shifting in
                setq    retval                          ' SETQ left-justifies the reflected data byte
                crcnib  crc, ##USB16_POLY               ' Run CRC calc on the data nibs
                crcnib  crc, ##USB16_POLY
.end_crc
                add     pkt_cnt, #1
                cmp     pkt_cnt, pkt_tmp        wcz
        if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
        if_a    ret
' For full-speed at 80MHz, the time it takes to do the final byte write and
' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
' to miss it, so cheat a bit and look for SOP clear here.
                rqpin   urx, #DM
                testb   urx, #SOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
        if_c    jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
.chk_crc
                sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
                xor     crc, ##USB16_RESIDUAL           ' CRC of (data + transmitted CRC) XOR residual should equal zero
                tjz     crc, #.ack                      ' If we jump, the CRCs matched
                jmp     #urx_packet                     ' CRC fail; discard data and wait until data re-sent or transfer timeout
.ack
                mov     retval, #PID_ACK
                mov     hctwait, ip_delay
                call    #poll_waitx
' Fall through to utx_handshake
' vvvvvvvvvvvvvvvvvvvvvvvvvvvvv
' */
' /* utx_handshake
'------------------------------------------------------------------------------
' Transmit a handshake PID. The routine assumes that the bus is IDLE and
' the appropriate IP delay has been inserted.
'------------------------------------------------------------------------------
' On entry:
'   retval - handshake PID to send.
' On exit:
'   retval unchanged.
'------------------------------------------------------------------------------
utx_handshake
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync
                mov     utx, retval
                call    #utx_byte                       ' Send handshake PID
.idle
                rqpin   urx, #DM
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #.idle                          ' Wait for IDLE to ensure the PID tx is complete
                mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
                jmp     #poll_waitx
' */
' /* utx_byte
'------------------------------------------------------------------------------
' Wait for the USB tx buffer to empty and feed it a new byte.
'------------------------------------------------------------------------------
' On entry:
'   utx - byte to transmit.
' On exit:
'------------------------------------------------------------------------------
utx_byte
                testp   #DP                     wc
        if_nc   jmp     #utx_byte
                akpin   #DP
                waitx   utx_tweak       ' Wait #3 if < 180MHz, wait #20 if 180MHz+
'                waitx   #3              ' 108MHz..168MHz mostly OK, some 3.x parts flaky
'                waitx   #13             ' minimum clean @300MHz
'                waitx   #20             ' clean 180MHz..360MHz 
        _ret_   wypin   utx, #DM
' /* urx_next
'------------------------------------------------------------------------------
' Fetch the next data byte of a packet. Always check receiver status for EOP.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   retval - the byte read.
'   urx - the receiver status. The caller must check the hstatus reg EOP flag
'     on return. If EOP is set, the byte in reg retval remains as the last byte
'     received.
'------------------------------------------------------------------------------
urx_next
                rdpin   urx, #DM
                mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
                and     utx, urx
                cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
        if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
        if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
        if_nz   ret                                     ' New byte is priority, so return now
                testb   urx, #SOPB              wc
                testb   urx, #BUS_ERRB          wz
        if_10   jmp     #urx_next                       ' If SOP still raised and !BUS_ERRB a new byte should be coming
        if_0x   bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
                ret
' */
' /* poll_waitx
'------------------------------------------------------------------------------
' The one millisecond frame timer is implemented as an interrupt service
' routine. Since this timing is critical, care must be taken to avoid any
' instructions that can delay the interrupt branch, which will likely upset
' the timer. WAITX is among those instructions, so any time you're inside
' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
'------------------------------------------------------------------------------
' On entry:
'   hctwait - wait interval in sysclocks.
' On exit:
'------------------------------------------------------------------------------
poll_waitx
                getct   hct2
                addct2  hct2, hctwait
.wait
                jnct2   #.wait
                ret
' */
' /* wait_txn_ok
'------------------------------------------------------------------------------
' Wait for a window within the 1ms frame boundary that will ensure that a
' transaction can complete without spanning the frame.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
wait_txn_ok
                mov     lmm_c, #0
.wait
                testb   hstatus, #TXN_LIMITB    wc
        if_c    add     lmm_c, #1
        if_c    jmp     #.wait                          ' In "no transaction" zone, so wait for the next frame
                cmp     lmm_c, #0               wz
        if_z    ret
                mov     hctwait, ip_delay
                jmp     #poll_waitx                     ' In the "transaction OK" zone, so good to go
' */
' /* isr1_frame
'------------------------------------------------------------------------------
' Full-speed/low-speed frame timing interrupt service routine.
'------------------------------------------------------------------------------
isr1_frame
                testb   hstatus, #TXN_LIMITB    wc
        if_nc   jmp     #.no_txn_zone                   ' Timer "txn OK" expired, go set "no txn" timer
                addct1  hct1, txn_ok_zone               ' Refresh the "txn OK zone" timespan
                testb   hstatus, #LOW_SPEEDB    wc
        if_nc   jmp     #.fullspeed
                mov     utx, #OUT_EOP                   ' Timer "no txn" expired, so it's end-of-frame
                call    #utx_byte                       ' EOP is the low-speed keep-alive strobe
                mov     isr_tmp, ip_delay               ' Normal inter-packet delay works when low-speed
                jmp     #.wait
.fullspeed
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync byte
                mov     icrc, #$1f                      ' Prime the CRC5 pump
                mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
                rev     sof_pkt                         ' Input data reflected
                mov     utx, #PID_SOF
                call    #utx_byte                       ' Send token PID byte
                setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
                crcnib  icrc, #USB5_POLY
                crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
                getbyte utx, frame, #0                  ' Send the low byte of the frame number
                call    #utx_byte
                shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
                rep     #2, #3                          ' Three data bits left to process
                shl     sof_pkt, #1             wc
                crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
                xor     icrc, #$1f                      ' Final XOR value
                getbyte utx, frame, #1                  ' Send remaining frame number bits
                shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
                or      utx, icrc
                call    #utx_byte                       ' Last start-of-frame byte is on the wire
                mov     isr_tmp, ##IP_DELAY_FS          ' Use normal inter-packet delay when full-speed
.wait
                rqpin   utx, #DM
                testb   utx, #SOPB              wc
        if_c    jmp     #.wait
                waitx   isr_tmp                         ' Make sure bus is idle before
                add     frame, #1                       ' Calculate number for next frame
                and     frame, ##$7ff
                bitl    hstatus, #TXN_LIMITB            ' Bus ready for traffic
                reti1
.no_txn_zone
                addct1  hct1, no_txn_zone               ' Refresh the "no txn zone" timespan
                bith    hstatus, #TXN_LIMITB
                reti1
' */
' /* hmemcpy
'------------------------------------------------------------------------------
' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - source address.
'   PB - destination address.
'   hr0 - length of copy, in bytes.
' On exit:
'------------------------------------------------------------------------------
hmemcpy
                rdbyte  htmp, ptra++
                wrbyte  htmp, pb
                add     pb, #1
                djnz    hr0, #hmemcpy
                ret
' */
' /* Host common registers
htmp            long    0                               ' Scratch registers whose context remains within the same code block
utx_tweak       long    0                               ' When sysclock speed above ~120MHz, need some fairy dust for USB tx
isr_tmp         long    0
pkt_tmp         long    0                               ' Tmp storage for routines that deal with datax packets
' This register block is reset to zero when a USB device connects
hreg_init_start
hr0             long    0                               ' Multi-purpose registers
hr1             long    0
hpar1           long    0                               ' Routine entry/exit parameters
hpar2           long    0
hpar3           long    0
hct1            long    0                               ' Timer for the 1ms frame generator interrupt service routine
hct2            long    0                               ' Function response bus turn-around timer
hct3            long    0                               ' DEBUG: used to do the blinky thing on Prop123-A9 USER_LEDs
hactive         long    0
hstatus         long    0                               ' Host status flags
hctwait         long    0                               ' Poll-based wait clocks
ip_delay        long    0                               ' Inter-packet delay in bit periods for connected device speed
tat_wait        long    0                               ' Maximum bus turn-around time in bit periods for connected device speed
nak_retry       long    0                               ' NAK retry count, unlimited retries if zero
txn_ok_zone     long    0                               ' Timespan that packets can be put on the bus
no_txn_zone     long    0                               ' Timespan in which packets must wait for bus to become available
xfer_retry      long    0                               ' Control transfer retry count
retry           long    0                               ' Transaction retry count
utx             long    0                               ' Byte to transmit on USB
urx             long    0                               ' Written by ISR only. LSByte receiver status flags, MSByte received data
newb_flg        long    0                               ' Receive "new byte" bit toggle detector
hevent          long    0                               ' Command/request eventID posted by the driver cog
max_pkt_size    long    0                               ' Maximum payload bytes allowed, likely to change on device connect.
total_data      long    0                               ' Total bytes to tx/rx in a transfer data stage
stage_data      long    0                               ' Count of bytes sent/received so far during a data stage.
pkt_data        long    0                               ' Payload size of an OUT packet or bytes received on IN
frame           long    0                               ' USB 1ms frame counter value
sof_pkt         long    0                               ' ISR frame# packet and CRC5
icrc            long    0                               ' Only used by the 1ms frame output ISR routine
pkt_cnt         long    0                               ' Count of DATAx packet payload bytes
dbgc            long    0                               ' Debug count/index
crc             long    0                               ' Used for CRC16 calculation
ep_addr_pid     long    0                               ' Endpoint and device addresses for connected device
retval          long    0                               ' Global success/fail return parameter
context_retval  long    0                               ' Operation contextual return parameter
hreg_init_end
' Fast Block Move start (registers must be kept in this order!)
uio_ep_addr     res     1                               ' IN/OUT transfer parameter block
uio_next_datax  res     1
uio_max_pkt     res     1
uio_total_bytes res     1
uio_buff_ptr    res     1
' Fast Block Move end
' /* Cog variables for the P2 monitor in ROM
''============[ COG VARIABLES - MONITOR]========================================
                org     $1E0              ' place the variables in cog $1E0-$1EF
''-------[ LMM parameters, etc ]------------------------------------------------
                res     5
''-------[ LMM additional workareas ]-------------------------------------------
                res     11
' */
                long    -1[$1f4 -1 - $]                 ' Fill remaining free cog space with $FFs
                long    DBG_FEEDBEEF                    ' End of used cog/lut space marker
                fit     $1f4
'------------------------------------------------------------------------------
' P2 standard register addresses:
'------------------------------------------------------------------------------
'$1F0           RAM / IJMP3                             interrupt call   address for INT3
'$1F1           RAM / IRET3                             interrupt return address for INT3
'$1F2           RAM / IJMP2                             interrupt call   address for INT2
'$1F3           RAM / IRET2                             interrupt return address for INT2
'$1F4           RAM / IJMP1                             interrupt call   address for INT1
'$1F5           RAM / IRET1                             interrupt return address for INT1
'$1F6           RAM / PA                                CALLD-imm return, CALLPA parameter, or LOC address
'$1F7           RAM / PB                                CALLD-imm return, CALLPB parameter, or LOC address
'$1F8           PTRA                                    pointer A to hub RAM
'$1F9           PTRB                                    pointer B to hub RAM
'$1FA           DIRA                                    output enables for P31..P0
'$1FB           DIRB                                    output enables for P63..P32
'$1FC           OUTA                                    output states for P31..P0
'$1FD           OUTB                                    output states for P63..P32
'$1FE           INA *                                   input states for P31..P0
'$1FF           INB **                                  input states for P63..P32
' * also debug interrupt call address
'** also debug interrupt return address
'------------------------------------------------------------------------------
' #endregion DAT (Host Cog)
' #region DAT (Host LUT)
                org     HLUT_BASE + $200                ' Host "owns" LUT cells starting here
hlut_start
' /* do_int_in
'------------------------------------------------------------------------------
' Execute an IN interrupt transaction on behalf of the class driver via the
' event mechanism.
' FIXME: The function address, endpoint and data toggle info should be cached
'        and maintained by the host and not the class driver.
'        Need to handle IN data lengths > max_pkt_size.
'------------------------------------------------------------------------------
' On entry:
'   hevent - HDATA_IN eventID.
' On exit:
'   Reports the result of the transaction to the class driver via the
'   host<->driver event mechanism.
'------------------------------------------------------------------------------
do_int_in
                rdlut   ep_addr_pid, #H_PAR1            ' Function address and endpoint
                rdlut   hpar3, #H_PAR3                  ' Word1 max_pkt, word0 DATAx to expect
                testn   ep_addr_pid, ##EP_ADDR_MASK wz
        if_z    call    #calc_crc5                      ' Calculate CRC5 if not yet done
                getword htmp, hpar3, #0
                cmp     htmp, #PID_DATA0        wz
                bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
                mov     retry, #TXN_RETRIES
.retry
                getword pkt_data, hpar3, #1             ' IN max packet length
                call    #txn_in
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.commit
                cmp     retval, #PID_NAK        wz
        if_nz   cmp     retval, #PID_STALL      wz
        if_z    jmp     #.post_ret                      ' IRP poster must handle NAK or STALL
                call    #retry_wait
                cmp     retval, #ERR_TXN_RETRY  wz
        if_z    jmp     #.post_ret
                jmp     #.retry
.commit
                cmp     pkt_cnt, #0             wz
        if_z    jmp     #.post_ret                      ' Skip copy if it's an empty packet
                loc     ptra, #@urx_buff                ' Copy DATAx in rx buffer to dest buffer
                rdlut   pb, #H_PAR2                     ' Start address of buffer for the IN data
                mov     hr0, pkt_cnt
                call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
.post_ret
                mov     hevent, #DTXN_RESULT
                mov     hpar1, ep_addr_pid              ' Confirm USB target
                mov     hpar2, retval                   ' Transaction result
                mov     hpar3, pkt_cnt                  ' IN bytes actually received
                jmp     #post_devent                    ' Post results to the class driver and return to caller
' */
' /* do_int_out
'------------------------------------------------------------------------------
' Execute an OUT interrupt transaction on behalf of the class driver via the
' event mechanism.
'------------------------------------------------------------------------------
do_int_out
                ret
' */
' /* do_bulk_in
'------------------------------------------------------------------------------
' Execute an IN transaction on behalf of the class driver via the event
' mechanism.
'------------------------------------------------------------------------------
' On entry:
'   hevent - HDATA_IN eventID.
'   LUT cell H_PAR1 - hub address of an IN transfer parameter block structure.
' On exit:
'   Reports the result of the transaction to the class driver via the
'   host<->driver event mechanism.
'------------------------------------------------------------------------------
do_bulk_in
                rdlut   hpar1, #H_PAR1                  ' Get start of IN parameter block from LUT
                setq    #UIO_PARAMS_READ                ' Use fast block copy to read all IN parameters
                rdlong  uio_ep_addr, hpar1              ' Read parameters from hub into uio_* cog registers
                mov     ep_addr_pid, uio_ep_addr
                test    ep_addr_pid, ##CRC_MASK wz
        if_z    call    #calc_crc5                      ' Calculate CRC5 if not yet done
                mov     uio_ep_addr, ep_addr_pid
                mov     hpar3, #0                       ' All data received when hpar3 == uio_total_bytes
                mov     nak_retry, #NAK_NOLIMIT         ' DEBUG: technically should retry on NAK until ACK or STALL received
                cmp     uio_next_datax, #PID_DATA0 wz
                bitnz   hstatus, #DATAx_TGLB            ' Set/clear flag for which DATAx PID to apply
.data
                mov     pkt_data, hpar3
                subr    pkt_data, uio_total_bytes       ' Calculate bytes remaining to be received
                fle     pkt_data, uio_max_pkt           ' Ensure expected payload byte count <= max packet size
.set_retry
                mov     retry, #TXN_RETRIES             ' Waiting for a new data xfer, so reset retry count
.send_in
                call    #txn_in
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.commit
                cmp     retval, #PID_STALL      wz
        if_z    jmp     #.done
                cmp     retval, #ERR_DATAX_SYNC wz
        if_z    jmp     #.wait                          ' Should be back in sync, so we're ready for next IN
                call    #retry_wait                     ' If NAK or other, we can try again
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.send_in
                jmp     #.done
.commit
                bitnot  hstatus, #DATAx_TGLB            ' Toggle the DATAx sync bit to match PID
                cmp     pkt_cnt, #0             wz      ' If no data bytes, the host must assume there is no more IN data coming
        if_z    jmp     #.done
                loc     ptra, #@urx_buff                ' Copy DATAx in rx buffer to dest buffer
                mov     pb, uio_buff_ptr                ' Start address of buffer for the IN data
                mov     hr0, pkt_cnt
                call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
                add     hpar3, pkt_cnt                  ' Update bytes received on commit
                add     uio_buff_ptr, pkt_cnt           ' and bump the rx buffer pointer
                cmp     pkt_cnt, uio_max_pkt    wcz     ' Short packet is considered a completed transfer
        if_b    jmp     #.done
                cmp     hpar3, uio_total_bytes  wcz
        if_ae   jmp     #.done                          ' Total bytes is a multiple of max packet
.wait
                mov     hctwait, tat_wait               ' More data to receive, but wait a bit before next IN request
                shl     hctwait, #1                     ' 2x turn-around timespan sounds good...
                call    #poll_waitx
                jmp     #.send_in
.done
                testb   hstatus, #DATAx_TGLB    wc      ' Set appropriate DATAx PID for the next IN transfer
        if_nc   mov     uio_next_datax, #PID_DATA0
        if_c    mov     uio_next_datax, #PID_DATA1
                jmp     #hio_post_res                   ' Result posting to driver is the same for IN & OUT
' */
' /* do_bulk_out
'------------------------------------------------------------------------------
' Execute an OUT transaction on behalf of the class driver via the event
' mechanism.
'------------------------------------------------------------------------------
' On entry:
'   hevent - HBULK_OUT eventID.
'   LUT cell H_PAR1 - hub address of an OUT transfer parameter block structure.
' On exit:
'   Reports the result of the transaction to the class driver via the
'   host<->driver event mechanism.
'------------------------------------------------------------------------------
do_bulk_out
                rdlut   hpar1, #H_PAR1                  ' Get start of OUT parameter block from LUT
                setq    #UIO_PARAMS_READ                ' Use fast block copy to read all OUT parameters
                rdlong  uio_ep_addr, hpar1              ' Read parameters from hub into uio_* cog registers
                mov     ep_addr_pid, uio_ep_addr
                test    ep_addr_pid, ##CRC_MASK wz
        if_z    call    #calc_crc5                      ' Calculate CRC5 if not yet done
                mov     uio_ep_addr, ep_addr_pid
                mov     hpar3, #0                       ' All data transmitted when hpar3 == uio_total_bytes
                mov     nak_retry, ##OUT_NAK_RETRIES
                cmp     uio_next_datax, #PID_DATA0 wz
                bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for which DATAx PID to send
.set_retry
                mov     retry, #TXN_RETRIES
.send_out
                mov     pkt_data, hpar3
                subr    pkt_data, uio_total_bytes       ' Calculate bytes remaining to be transmitted
                fle     pkt_data, uio_max_pkt           ' Ensure packet byte count is <= max packet size
                mov     ptra, uio_buff_ptr
                call    #txn_out                        ' Put OUT token and data on the USB
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.commit
                cmp     retval, #PID_STALL      wz      ' STALL always requires an endpoint reset
        if_z    jmp     #.done
                call    #retry_wait                     ' If NAK or other, we can try again
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   cmp     retval, #ERR_NAK        wz
        if_z    jmp     #.done
                jmp     #.send_out
.commit
                bitnot  hstatus, #DATAx_TGLB            ' Toggle the DATAx sync bit
                add     hpar3, pkt_data
                add     uio_buff_ptr, pkt_data
                cmp     hpar3, uio_total_bytes  wcz
        if_b    jmp     #.set_retry                     ' More data to transmit
.done
                testb   hstatus, #DATAX_TGLB    wc      ' Set appropriate DATAx PID for the next OUT transfer
        if_nc   mov     uio_next_datax, #PID_DATA0
        if_c    mov     uio_next_datax, #PID_DATA1
' Posting event results is the same for both IN & OUT
hio_post_res
                rdlut   hpar1, #H_PAR1                  ' Get start of IN/OUT parameter block from LUT
                setq    #UIO_PARAMS_WRITE               ' Only the first two parameters need to be updated
                wrlong  uio_ep_addr, hpar1
                mov     hevent, #DTXN_RESULT
                mov     hpar1, ep_addr_pid
                mov     hpar2, retval
              ' hpar3 has actual data IN/OUT byte count
                jmp     #post_devent
' */
hlut_end        long    0[HLUT_TOP + $200 -1 - $]
                long    DBG_FEEDBEEF
                fit     HLUT_TOP + $200                 ' Reserve space for the host/driver shared LUT interface
' #endregion DAT (Host LUT)
' #region DAT (Host HubExec)
' /* usb_start
'------------------------------------------------------------------------------
' Subroutine to start the USB host/driver by using the COGINIT option to locate
' and start an unused even/odd cog pair.
' README: Call this subroutine to start the USB host and device driver code
' from your program.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   PA - zero on success, non-zero if COGINIT error.
'------------------------------------------------------------------------------
dat
                orgh
                alignl
usb_start
                mov     pa, #%0_1_0001                  ' COGINIT option to find even/odd stopped/unallocated cog pair
                coginit pa, ##@usb_host         wc
        if_nc   mov     pa, #0                          ' Clear PA to signal COGINIT success
                ret                                     ' Return to whatever loader called us.
' */
' /* host_reset
host_reset
                setint1 #0
                dirl    #DP                             ' Put smartpins into reset
                dirl    #DM
                wrpin   #%1_11001_0, #DP                ' The host is also the root hub, so full-speed is its native speed
                wrpin   #%1_11001_0, #DM
                wxpin   ##_12Mbps, #DM                  ' Default to Full-Speed
                wypin   #OUT_IDLE, #DM                  ' Float pins with D-/D+ line resistors according to host/device mode
                dirh    #DM                             ' Crank them smartpins up
                dirh    #DP
                mov     pa, #hreg_init_start            ' Reset all host common registers
.loop
                altd    pa
                mov     0-0, #0
                add     pa, #1
                cmp     pa, #hreg_init_end      wz
        if_nz   jmp     #.loop
                loc     ptra, #@usb_cache_start         ' USB descriptor buffer area
                mov     hr0, ##usb_cache_end
                sub     hr0, ptra
                mov     hr1, #0                         ' Buffer area zero fill
                call    #memset                         ' (PTRA, hr0, hr1)
                call    #hpulse_led
                wrlut   #H_READY, #H_EVENT
'-----------------------------------------------------------------------------------------------------------------
' Device connect handling (Section 7.1.7.3).
'-----------------------------------------------------------------------------------------------------------------
' The 15K pull-down resistors on D+ and D- allow the host to passively monitor the bus lines while waiting for a
' device to connect (Section 7.1.7.3).
'-----------------------------------------------------------------------------------------------------------------
disconnected
                pollct3                         wc
        if_c    call    #hpulse_led                     ' Toggle the host wait for connect USER_LED
                rqpin   urx, #DM
                testb   urx, #J_IDLEB           wc      ' Wait for rise of J or K, mutually exclusive
                testb   urx, #K_RESUMEB         wz
        if_00   jmp     #disconnected                   ' J and K still low, so keep waiting for connect
        if_10   jmp     #.connect_test                  ' J high is FS connect state and K high is LS
        if_01   jmp     #.connect_test
.se1_test
                waitx   ##_1ms * 100                    ' In illegal SE1 state, so wait and retest
                rqpin   urx, #DM
                testb   urx, #J_IDLEB           wc
                testb   urx, #K_RESUMEB         wz
        if_11   jmp     #.se1                           ' Still in illegal SE1 state, so throw error and stop
                mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
                jmp     #disconnected                   ' Back to connect detection loop
.se1            loc     ptra, #@sz_err_se1
                mov     retval, #ERR_SE1
                ' DEBUG: SE1 is error condition
                call    #htx_result_to_con
                waitx   ##_1ms * 100
                mov     retval, hstatus
                jmp     #dbg_break                      ' Seeing SE1 for any length of time is not good...
.connect_test                                           ' Test lines until stable J/K state seen
                waitx   ##_1ms * 100                    ' Total of 100ms debounce interval (Section 7.1.7.3)
                rqpin   urx, #DM
                testb   urx, #J_IDLEB           wc
                testb   urx, #K_RESUMEB         wz
        if_00   jmp     #disconnected                   ' DP and DM low
        if_11   jmp     #.se1_test                      ' DP and DM high
connected
                bith    hstatus, #CONNECTEDB            ' Device plugged in
                call    #on_connect                     ' Initial device configuration
' Fall through to idle/processing loop
' vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
hidle
                pollct3                         wc
        if_c    call    #hpulse_led                     ' Toggle the main loop activity indicator USER_LED
                pollse1                         wc
        if_c    call    #do_hevent
                rqpin   urx, #DM
                testb   urx, #SE0_RESETB        wc
        if_c    jmp     #.se0_test
                jmp     #hidle
' Check for extended SE0 state on the bus
.se0_test
                mov     hctwait, ##_1ms
                call    #poll_waitx                     ' Wait a bit and test for SE0 again
                rqpin   urx, #DM
                testb   urx, #SE0_RESETB        wc
        if_nc   jmp     #hidle                          ' Bus still IDLE
                setint1 #0                              ' Turn off frame strobe interrupt
                flth    #HOST_ACTIVE_LED                ' DEBUG
                mov     hevent, #DINF_DISCONNECT
                mov     hpar1, ep_addr_pid
                call    #post_devent                    ' Inform HID driver of reset/disconnect
                waitx   ##_1ms * 500
                jmp     #host_reset                     ' Device disconnected
' */
' /* dev_reset
'------------------------------------------------------------------------------
' A device connection was detected. Set the appropriate smartpin FS/LS speed
' mode to match the device and perform a reset sequence prior to device
' enumeration.
'------------------------------------------------------------------------------
dev_reset
                rqpin   urx, #DM
                testb   urx, #K_RESUMEB         wc      ' K differential "1" in FS mode signals low-speed
' Back-to-back CALLs that are predicated on C/Z flag state can be a real
' "gotcha" minefield, so define our own pseudoCALL->RET path.
                push    ##reset
        if_c    jmp     #set_speed_low
        if_nc   jmp     #set_speed_full
reset
                setint1 #0                              ' Don't want frame interrupt at reset
                wypin   #OUT_SE0, #DM                   ' Assert bus reset
                waitx   ##RESET_HOLD                    ' Spec is >= 10ms
                wypin   #OUT_IDLE, #DM
                bitl    hstatus, #TXN_LIMITB            ' Reset the frame txn OK/!OK flag
                mov     frame, #0                       ' Reset the frame count
                getct   hct1                            ' Reset the frame timer
                addct1  hct1, ##TXN_OK_ZONE
                setint1 #1                              ' Set ISR event trigger to CT1-equals-CT
                mov     hctwait, ##_1ms * 21
                call    #poll_waitx                     ' Allow reset recovery time (Section 9.2.6.2)
                ret
' */
' /* on_connect
'------------------------------------------------------------------------------
' Perform configuration stuff required when a device intitially connects.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
on_connect
                mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
                call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
.retry
                mov     hevent, #DINF_CONNECT           ' Prepare to inform driver a device has connected
                testb   hstatus, #LOW_SPEEDB    wc
        if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
        if_nc   mov     hpar1, #USB_SPEED_FULL
                call    #post_devent
                mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
                loc     ptra, #@get_dev_desc            ' Hub start address of GetDeviceDescriptor SETUP struct
                wrword  #$40, ptra[wLength]             ' Request IN data stage max of 64 bytes will test actual < requested logic
                loc     pb, #@dev_desc_buff             ' Start address of DeviceDescriptor struct for IN data
                call    #control_read                   ' Execute GetDeviceDescriptor()
                loc     ptra, #@sz_getdev_result
                call    #htx_result_to_con              ' Route results to terminal
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.get_dev_desc
                mov     hctwait, ##_1ms * 1000          ' If the first GetDescriptor() fails, reset and try again
                call    #poll_waitx
                sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
        if_z    pop     htmp                            ' This POP should empty the hardware stack
        if_z    jmp     #host_reset                     ' Re-initialize everything if reset retry limit exceeded
                call    #reset                          ' Try another reset to see if the device responds
                jmp     #.retry
.get_dev_desc
                loc     pa, #@dev_desc_buff             ' Fetch the max packet size for control transactions from the
                add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
                rdbyte  max_pkt_size, pa
                mov     hctwait, ##_1ms
                call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
                call    #reset
                loc     ptra, #@set_address             ' Hub start address of SetAddress SETUP struct
                wrword  #1, ptra[wValue]                ' Only support one device port at this time
                call    #control_write                  ' Execute SetAddress()
                loc     ptra, #@sz_setaddr_result
                call    #htx_result_to_con              ' Route results to terminal
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to idle if not ACK
                mov     hctwait, ##_1ms * 8
                call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
                mov     ep_addr_pid, ##1 << 8           ' Device ep/addr now #1 and endpoint zero
                call    #calc_crc5
                loc     ptra, #@get_dev_desc            ' Repeat SETUP for GetDeviceDescriptor()
                loc     pb, #@dev_desc_buff             ' Start address of DeviceDescriptor struct has exact descriptor length
                rdbyte  total_data, pb
                wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
                call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.ack0
                loc     ptra, #@sz_getdev_result
                jmp     #htx_result_to_con              ' Route error result to terminal and back to idle state
.ack0
                mov     hevent, #DINF_DEV_DESC          ' Notify driver cog that the device descriptor is cached
                mov     hpar1, ep_addr_pid
                mov     hpar2, ##dev_desc_buff
                mov     hpar3, retval
                call    #post_devent
                mov     hctwait, ##_1us * 500
                call    #poll_waitx
                loc     ptra, #@get_config_desc         ' Hub start address of GetConfigurationDescriptor SETUP struct
                wrword  #$ff, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
                loc     pb, #@con_desc_buff             ' Hub start address of ConfigurationDescriptor structure
                call    #control_read                   ' Execute GetConfigurationDescriptor()
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.ack1
                loc     ptra, #@sz_getconf_result
                jmp     #htx_result_to_con              ' Route error result to terminal and go back to idle state
.ack1
                loc     ptra, #@con_desc_buff           ' Check the config descriptor struct for expected data
                rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
                rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
                rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
                cmp     hr0, #CON_DESC_LEN      wcz
        if_ae   cmp     hr1, #TYPE_CONFIG       wcz
        if_z    cmp     htmp, total_data        wcz
        if_b    jmp     #.err_config
                mov     hevent, #DINF_CON_DESC          ' Notify driver cog that the configuration descriptor is cached
                mov     hpar1, ep_addr_pid
                mov     hpar2, ##con_desc_buff
                mov     hpar3, retval
                jmp     #post_devent                    ' From now on the host idles and waits for class driver IRPs
.err_config
                loc     ptra, #@sz_getconf_result
                mov     retval, #ERR_PACKET
                jmp     #htx_result_to_con              ' Error to terminal and back to idle state
' */
' /* control_read
'------------------------------------------------------------------------------
' Perform a control read transaction (Section 8.5.3, Figure 8-37).
' Status reporting is always in the function-to-host direction.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - start address of the SETUP data in hub.
'   PB - start address of the buffer/struct to be written to during the IN data
'     stage.
'   ep_addr_pid - device address, endpoint and CRC5.
' On exit:
'   retval - PID_ACK on success, otherwise error. If successful, reg total_data
'     contains the count of data stage bytes actually received, which must
'     always be <= the count requested.
'   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'     more specific USB operation error code.
'------------------------------------------------------------------------------
control_read
                mov     hpar1, ep_addr_pid
                mov     hpar2, ptra
                mov     hpar3, pb
                mov     xfer_retry, #XFER_RETRIES
.xfer_start
                rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
                call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to caller to handle error
                cmp     total_data, #0          wz
        if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
                mov     stage_data, #0                  ' Prepare for data stage
                mov     nak_retry, ##IN_NAK_RETRIES
                bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
.data
                mov     pkt_data, total_data
                sub     pkt_data, stage_data
                cmp     pkt_data, max_pkt_size  wcz
        if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
.nak_retry
                mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
.in_retry
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' Commit on ACK
        if_z    jmp     #.commit
                cmp     retval, #PID_STALL      wz
        if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #PID_NAK        wz
        if_z    jmp     #.nak_retry                     ' Function not ready to send data
                cmp     retval, #ERR_NAK        wz
        if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.in_retry                      ' Bus error retry
                ret                                     ' The transfer has failed
.commit
                cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
        if_z    jmp     #.pre_status                    ' and also end-of-data
                loc     ptra, #@urx_buff                ' Copy DATAx in rx buffer to dest struct
                mov     hr0, pkt_cnt
                call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
                add     stage_data, pkt_cnt             ' Update bytes received on commit
                cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
        if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
                cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
        if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
        if_a    mov     retval, #ERR_PACKET
        if_a    mov     context_retval, retval          ' In this case overall and context are the same
        if_a    ret                                     ' Caller must handle ERR_PACKET
                bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
                jmp     #.data                          ' Start next IN transaction
.pre_status
                mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
                setbyte ep_addr_pid, #PID_OUT, #0
                mov     pkt_data, #0
                bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
                mov     nak_retry, ##OUT_NAK_RETRIES
.out_retry
                call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
                cmp     retval, #PID_ACK        wz
        if_z    ret                                     ' All is good when ACK
                cmp     retval, #PID_STALL      wz
        if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #ERR_NAK        wz
        if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
                ret                                     ' Caller must handle transfer retirement
' I've encountered transfer STALL, even though the data looks correct, and
' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
' ControlRead() transfer gets things unstuck most of the time...
.xfer_retry
                mov     hctwait, ##XFER_WAIT
                call    #poll_waitx
                call    #wait_txn_ok
                mov     ep_addr_pid, hpar1
                mov     ptra, hpar2
                mov     pb, hpar3
                djnz    xfer_retry, #.xfer_start
                mov     context_retval, retval          ' Preserve the USB error code
        _ret_   mov     retval, #ERR_XFER_RETRY
' */
' /* do_ctrl_read
'------------------------------------------------------------------------------
' Execute a ControlRead transaction on behalf of the class driver via the
' event mechanism and post the result.
' TODO: The function address should really be cached by the host and not the
'       class driver.
'------------------------------------------------------------------------------
' On entry:
'   hevent - H_CTRL_READ eventID.
' On exit:
'   Reports the result of the transaction to the class driver via the event
'   mechanism.
'------------------------------------------------------------------------------
do_ctrl_read
                rdlut   ep_addr_pid, #H_PAR1            ' Function address and control endpoint zero
                rdlut   ptra, #H_PAR2                   ' Start address of the SETUP struct to use
                rdlut   pb, #H_PAR3                     ' Start address of the IN data buffer
                call    #control_read                   ' Execute ControlRead() txn
                mov     hevent, #DTXN_RESULT
                mov     hpar1, ep_addr_pid              ' Confirm USB target
                mov     hpar2, retval                   ' Transaction overall result
                mov     hpar3, context_retval           ' If non-zero, an error code for the specific error encountered
                jmp     #post_devent                    ' Post results to the class driver and return to caller
' */
' /* control_write
'------------------------------------------------------------------------------
' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
' reporting is always in the function-to-host direction. It is assumed that
' the SETUP data struct is filled with the required values.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - points to the start of the struct for the SETUP data.
'   PB - the start address of the struct/buffer to be read for the OUT data
'     stage.
'   ep_addr_pid - the proper CRC'd address and endpoint to use.
' On exit:
'   retval - used to convey the success/failure of each stage.
'   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'     more specific USB operation error code.
'------------------------------------------------------------------------------
control_write
                mov     hpar1, ep_addr_pid
                mov     hpar2, ptra
                mov     hpar3, pb
                mov     xfer_retry, #XFER_RETRIES
.xfer_start
                mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
                rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
                call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to caller to handle error
                cmp     total_data, #0          wz
        if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
                mov     stage_data, #0                  ' Prepare for data stage
                setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
                bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
.data
                mov     pkt_data, total_data
                sub     pkt_data, stage_data
                cmp     pkt_data, max_pkt_size  wcz
        if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
.out_retry
                mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
                call    #txn_out
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.commit                        ' Function got the data
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
        if_nz   jmp     #.out_retry
                ret                                     ' Caller must handle transfer retirement
.commit
                mov     pb, ptra                        ' Save the current buffer/struct location
                add     stage_data, pkt_data
                cmp     stage_data, total_data  wz
        if_nz   bitnot  hstatus, #DATAX_TGLB            ' Toggle DATAx sync bit
        if_nz   jmp     #.data                          ' More data to send
pre_status_in
                bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
.status_retry
                mov     pkt_data, #0
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
        if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
        if_z    ret                                     ' Control Write finished
                call    #retry_wait                     ' NAK or bus error, so delay a bit
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.status_retry
                ret                                     ' Caller must handle transfer retirement
' */
' /* do_ctrl_write
'------------------------------------------------------------------------------
' Execute a ControlWrite transaction on behalf of the class driver via the
' event mechanism.
'------------------------------------------------------------------------------
' On entry:
'   hevent - HCTRL_WRITE eventID.
' On exit:
'   Reports the result of the transaction to the class driver via the event
'   mechanism.
'------------------------------------------------------------------------------
do_ctrl_write
                rdlut   ep_addr_pid, #H_PAR1            ' Device address and control endpoint zero
                rdlut   ptra, #H_PAR2                   ' Start address of the SETUP struct to use
                rdlut   pb, #H_PAR3                     ' Start address of the OUT data buffer
                call    #control_write                  ' Execute ControlWrite() txn
                mov     hevent, #DTXN_RESULT
                mov     hpar1, ep_addr_pid              ' Confirm USB target
                mov     hpar2, retval                   ' Transaction overall result
                mov     hpar3, context_retval           ' If non-zero, an error code for the specific error encountered
                jmp     #post_devent                    ' Post results to the class driver and return to caller
' */
' /* retry_wait
'------------------------------------------------------------------------------
' Transaction retry handling for NAK/STALL or bus error.
'------------------------------------------------------------------------------
' On entry:
'   retval - transaction response PID or error code.
' On exit:
'------------------------------------------------------------------------------
retry_wait
                cmp     retval, #PID_STALL      wz
        if_z    ret                                     ' STALL is special case
                cmp     retval, #PID_NAK        wz
        if_z    jmp     #.nak
                mov     hctwait, ##_1us * 250           ' Transaction error wait...
                call    #poll_waitx
.dec
                sub     retry, #1               wz
        if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
                ret                                     ' Retry result to caller
.nak
                mov     hctwait, ##_1us * 33            ' Seems to be a reasonable NAK delay
                call    #poll_waitx
                cmp     nak_retry, #NAK_NOLIMIT wz
        if_z    ret                                     ' Indefinite NAK retries
                sub     nak_retry, #1           wz
        if_z    mov     retval, #ERR_NAK
                ret
' */
' /* calc_crc5
'------------------------------------------------------------------------------
' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
' the data used for the USB-5 CRC lookups. The token packet is three bytes in
' length, and the PID is not included in the CRC calculation:
'  CRC5  FRAME_NUMBER SOF (full-speed)
'  CRC5  ENDP ADDRESS PID
' %00000_1111_1111111_xxxxxxxx
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - stuffed with the function endpoint, address and
'     SETUP/IN/OUT/SOF PID according to the USB standard.
' On exit:
'   ep_addr_pid - CRC value appended to the packet.
'------------------------------------------------------------------------------
calc_crc5
                and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
                mov     htmp, ep_addr_pid
                shr     htmp, #8                        ' PID not included in CRC calc
                mov     crc, #$1f                       ' Initial CRC5 value
                rev     htmp                            ' Input data reflected
                setq    htmp                            ' CRCNIB setup for data bits 0..7
                crcnib  crc, #USB5_POLY
                crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
                shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
                crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
                shl     htmp, #1                wc
                crcbit  crc, #USB5_POLY
                shl     htmp, #1                wc
                crcbit  crc, #USB5_POLY
                xor     crc, #$1f                       ' Final XOR value
                shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
        _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home
' */
' /* set_speed_full
'------------------------------------------------------------------------------
' Full-speed is the host's native speed, so all that is needed is to set the FS
' settings to startup defaults.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
set_speed_full
                mov     txn_ok_zone, ##TXN_OK_FS        ' Set FS bandwidth usage limits
                mov     no_txn_zone, ##NO_TXN_FS
                mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
                mov     tat_wait, ##TAT_WAIT_FS         ' Bus turn-around time in full-speed bit periods
        _ret_   mov     ip_delay, ##IP_DELAY_FS         ' Inter-packet delay in full-speed bit periods
' */
' /* set_speed_low
'------------------------------------------------------------------------------
' When a low-speed device connects, the D-/D+ signalling is inverted. If there
' is a downstream hub connected (not yet implemented), the baud generator
' remains set at the full-speed rate, but signalling is switched to low-speed,
' which reverses the D-/D+ polarity. The polarity can be changed without
' putting the smartpins into reset.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
set_speed_low
                test    hstatus, #DWNSTRM_HUBF wc       ' If no downstream hub connected, set low-speed baudrate
        if_nc   dirl    #DP
        if_nc   dirl    #DM
                wrpin   #%1_11000_0, #DP                ' Low-speed signalling is always used
                wrpin   #%1_11000_0, #DM
        if_nc   wxpin   ##_1_5Mbps, #DM                 ' Set 1.5Mbs baudrate if no downstream hub
        if_nc   dirh    #DP
        if_nc   dirh    #DM
                mov     txn_ok_zone, ##TXN_OK_LS        ' Set low-speed bandwidth usage limits
                mov     no_txn_zone, ##NO_TXN_LS
                mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
                mov     tat_wait, ##TAT_WAIT_LS         ' Bus turn-around time in low-speed bit periods
                mov     ip_delay, ##IP_DELAY_LS         ' Inter-packet delay in low-speed bit periods
        _ret_   bith    hstatus, #LOW_SPEEDB            ' DM pulled high, so it's a Low-Speed device
' */
' /* hload_lut
'------------------------------------------------------------------------------
' Load host code/data from hub RAM to LUT, if any
'------------------------------------------------------------------------------
hload_lut
                mov     htmp, ##@hlut_end - 4           ' Will be copying SETQ2 N - 1 longs
                subs    htmp, ##@hlut_start     wc
        if_c    ret                                     ' If < 0 no LUT code/data
                shr     htmp, #2                        ' Adjust count for longs
                setq2   htmp
        _ret_   rdlong  HLUT_BASE, ##@hlut_start        ' Copy and return
' */
' /* htx_result_to_con
'------------------------------------------------------------------------------
' Send USB transaction or other event results to the serial terminal via the
' host->class driver event mechanism. If the "verbose" output option is active,
' output is unfiltered, otherwise ACK/SUCCESS result codes are suppressed.
'
' NOTE: only call this routine prior to the class driver being notified that
'       the device and configuration descriptors have been successfully read.
'       After that happens, all USB I/O is done using the class driver->host
'       IRP mechanism, which does its own transaction result handling.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - address of the transaction/event zero-terminated description string.
'     If zero, a generic description will be used.
'   retval - value of the result.
' On exit:
'------------------------------------------------------------------------------
htx_result_to_con
                mov     hpar1, ptra
                mov     hpar2, retval
                mov     hpar3, #BUS_ERRF
                and     hpar3, hstatus                  ' BUS_ERRF is never good
                mov     hevent, #DTXN_HRESULT
                jmp     #post_devent
' */
' /* memset
'------------------------------------------------------------------------------
' Write a single byte value to sequential hub memory locations.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - start address.
'   hr0 - length of the memory block, in bytes.
'   hr1 - byte value to write.
' On exit:
'------------------------------------------------------------------------------
memset
                wrbyte  hr1, ptra++
                djnz    hr0, #memset
                ret
' */
' /* dbg_break
'------------------------------------------------------------------------------
' Output a debug value and stop the host.
'------------------------------------------------------------------------------
' On entry:
'   retval - whatever debug info that fits into a long.
' On exit:
'   You can check in any time you like, but you will never leave...
'------------------------------------------------------------------------------
dbg_break
                mov     hpar1, retval
                mov     hevent, #DREQ_BREAK
                call    #post_devent
                stalli
' Wait a bit for driver to read the event before we hang up
                waitx   ##_1ms * 500
.halt           jmp     #.halt
' */
' /* dbg_hexdump
'------------------------------------------------------------------------------
' Dump hex byte data to the terminal.
'------------------------------------------------------------------------------
' On entry:
'   hpar1 - start address of data.
'   hpar2 - length of data, in bytes.
'------------------------------------------------------------------------------
dbg_hexdump
                mov     hevent, #DREQ_HEXDUMP
                jmp     #post_devent
' */
' /* dbg_data
'------------------------------------------------------------------------------
' Dump hex long data to the terminal.
'------------------------------------------------------------------------------
' On entry:
'   hpar1 - arbitrary debug value.
' On exit:
'------------------------------------------------------------------------------
dbg_data
                mov     hevent, #DREQ_DBG_DATA
                jmp     #post_devent
' */
' /* hpulse_led
'------------------------------------------------------------------------------
' Toggle a Prop123-A9 USER_LED when the host is the connect wait loop or the
' main USB processing loop.
'------------------------------------------------------------------------------
hpulse_led
                getct   hct3
                addct3  hct3, ##PULSE_TIME
                drvnot  #HOST_ACTIVE_LED
                ret
' */
' #endregion DAT (Host HubExec)
' #region CON (Class Driver)
con
'------------------------------------------------------------------------------
' Monitor in ROM entry addresses of utility routines
'------------------------------------------------------------------------------
        _Start_SDcard   = $FC560
        _Run_SDfile     = $FC578
        _SDcard_Init    = $FC5A4
        readFILE        = $FC900
        search_dir      = $FC840
        _reset_booter   = $FCA78
        _Start_Monitor  = $FCA88
        _Enter_Monitor  = $FCA8C
        _Redo_Monitor   = $FCA9C
        _SerialAddr     = $FCAA8
        _SerialBaud     = $FCAB0
        _SerialInit     = $FCAB8
        _HubTxCR        = $FCAE4
        _HubTxRev       = $FCAEC
        _HubTx          = $FCAF0
        _HubRx          = $FCB10
        _HubHexRev      = $FCB24
        _HubHex8        = $FCB28
        _HubHex         = $FCB2C
        _HubTxStrVer    = $FCB9C
        _HubTxString    = $FCBA4
        _HubListA2H     = $FCBC4
        _HubList        = $FCBC8
        _RdLongCogHub   = $FCF34
        _HubRxStrMon    = $FCCC4
        _HubRxString    = $FCCCC
        _HubMonitor     = $FCD78
        _ParseHex       = $FCF68
        _Download       = $FCEA4
        _HUBBUF         = $FC000                ' Default address for the monitor's rx buffer
'------------------------------------------------------------------------------
' Monitor CALL modes for hexadecimal values and memory/long hex listings
' Format example (indented values are optional): #_HEX_[+_REV_][+_SP][+N digits]
'------------------------------------------------------------------------------
        _HEX_           = 2 << 5                ' Output as hexadecimal
          _REV_         = 1 << 4                ' Reverse byte order
          _SP           = 1 << 3                ' Space between hex output pairs
         '_DIGITS       = 7..0                    Where 0 = 8 digits
        _LIST           = 3 << 5                ' LIST memory line (1/4 longs) from cog/hub
          _ADDR2        = 1 << 4                ' 1= use lmm_p2 as to-address
          _LONG_        = 1 << 1                ' 1=display longs xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
          _BYTE_        = 0
'------------------------------------------------------------------------------
' Serial I/O, if required, is part of the class driver. Default output text
' newline behavior is that every carriage return (CR) code encountered implies
' that a line feed character will follow.
' NOTE: The Parallax Serial Terminal (PST) treats the carriage return character
' as newline. In the Preferences->Functions Tab you can deselect the Line Feed
' character to prevent the double spacing of output text lines if you prefer
' to use CR+LF as a newline sequence.
'------------------------------------------------------------------------------
        _3M_8b       = round(SYSCLOCK / 3_000_000.0 * 65536.0) & $fffffc00 | 7
        _2M_8b       = round(SYSCLOCK / 2_000_000.0 * 65536.0) & $fffffc00 | 7
        _1_5M_8b     = round(SYSCLOCK / 1_500_000.0 * 65536.0) & $fffffc00 | 7
        _1M_8b       = round(SYSCLOCK / 1_000_000.0 * 65536.0) & $fffffc00 | 7
        _115_200_8b  = round(SYSCLOCK / 115_200.0 * 65536.0) & $fffffc00 | 7
        TX_PIN       = 62       ' Standard P2 tx/rx pins
        RX_PIN       = 63
' ASCII control codes:
        #7, BELL, BSP, TAB, LF, VT, FF, CR
'        BELL      = $07
'        BSP       = $08
'        TAB       = $09
'        LF        = $0a
'        CR        = $0d         ' PST: single CR is newline
        PST_GOTOX = $0e         ' PST: position cursor to column X
        PST_GOTOY = $0f         ' PST: position cursor to row Y
        PST_CLS   = $10         ' PST: clear screen cmd
        ESC       = $1b
' Console command prompt constants:
        CMD_PROMPT_SIZE   = 4                       ' Character count of the command line prompt only "A:\>"
        CMD_NAME_MAX_SIZE = 16                      ' Size to longest terminal command character count + 1
        CMD_LINE_MAX_SIZE = LONGNAME_PATH_SIZE + CMD_NAME_MAX_SIZE ' Maximum command line characters
'------------------------------------------------------------------------------
' Terminal types supported for clearing the screen and setting the cursor
' position to the first column of the current line.
'------------------------------------------------------------------------------
        #0, TERM_DUMB, TERM_PST, TERM_VT100, TERM_END
'------------------------------------------------------------------------------
' Various status bitflags and their position, grouped by function.
'------------------------------------------------------------------------------
' Group1 - serial text output option bit positions:
        #0, SHOW_POS_SIGNB, APPEND_NLB, PREPEND_0XB, IN_PARENSB, UNI_TXTB, TX_VERBOSEB, MSCROLLB
' Option bitflags (active high unless stated otherwise):
        SHOW_POS_SIGNF = |< SHOW_POS_SIGNB      ' 32-bit decimal output shows the "+" sign for posititive values
        APPEND_NLF     = |< APPEND_NLB          ' Value->text append CR char
        PREPEND_0XF    = |< PREPEND_0XB         ' Prepend "0x" to hexadecimal output, "0b" to binary output
        IN_PARENSF     = |< IN_PARENSB          ' Enclose the value in parentheses
        UNI_TXTF       = |< UNI_TXTB            ' Unicode text word
        TX_VERBOSEF    = |< TX_VERBOSEB         ' Parse connected device descriptor and config descriptor chain
        MSCROLLF       = |< MSCROLLB            ' Enable line scrolling of mouse button states and X/Y direction/velocity
' Group2 - bulk-only mass storage (BOMS) status bit positions:
        #8, BOMS_STALLB, BOMS_REMOVABLEB, BOMS_REMOVEDB, BOMS_PTN_ACTIVEB
' BOMS status bitflags (active high unless stated otherwise):
        BOMS_STALLF      = |< BOMS_STALLB
        BOMS_REMOVABLEF  = |< BOMS_REMOVABLEB
        BOMS_REMOVEDF    = |< BOMS_REMOVEDB
        BOMS_PTN_ACTIVEF = |< BOMS_PTN_ACTIVEB
' Group3 - SCSI/USB error identification bit positions:
        #0, ERR_SRC_SCSIB, ERR_SRC_USBB
' Error ID bitflags (active high unless stated otherwise):
        ERR_SRC_SCSIF = |< ERR_SRC_SCSIB
        ERR_SRC_USBF  = |< ERR_SRC_USBB
' SKIP values for various console output options:
        #0, DECIMALU, DECIMALS                  ' Use unsigned/signed decimal output
'------------------------------------------------------------------------------
' Pushbutton option startup defaults:
'        OPT_VERBOSE = TX_VERBOSEF               ' Set to TX_VERBOSEF for verbose output to the terminal, zero for off
        OPT_VERBOSE = 0                         ' Set to TX_VERBOSEF for verbose output to the terminal, zero for off
'        OPT_MSCROLL = MSCROLLF                  ' Set to MSCROLLF to scroll mouse button & X/Y data, zero to inhibit scrolling
        OPT_MSCROLL = 0                         ' Set to MSCROLLF to scroll mouse button & X/Y data, zero to inhibit scrolling
'------------------------------------------------------------------------------
' USB Mass Storage Class driver using bulk-only transport.
' Constants specific to the Mass Storage Class driver:
'------------------------------------------------------------------------------
' A task progression list that is specific to this type of class driver. When
' the host cog enumerates a device, the class driver is notified when the
' Device Descriptor and the Configuration Descriptor have been read, always in
' that order. After both notifications have been received, the class driver
' must define the tasks that will parse the descriptor(s) to determine if the
' device is compatible with the class driver. If not, the host should be
' notified that the device is "unknown" FIXME: unknown not yet handled.
'
' If the device is compatible, the task list is used as a way for the class
' driver to do what is necessary to configure the device for its intended
' function. Each task routine in the list is responsible for setting the task
' that follows it, if there is one. The final task in the list is typically
' akin to a "main" processing routine that calls other routines which post the
' relevant USB transactions needed to implement the device's functions. This
' task runs until the host cog notifies the class driver that the device has
' been reset or disconnected.
'------------------------------------------------------------------------------
        #0, DT_IDLE, DT_SET_CONF, DT_BOMS_INQUIRY, DT_SRCH_FILESYS, DT_GET_CON_INPUT
        'DT_INT_IN, DT_INT_OUT
' Mark end of task list.
        DT_END = DT_GET_CON_INPUT
' #endregion CON (Class Driver)
' #region DAT (Class Driver Cog)
dat
                orgh
                alignl
                org
' /* class_driver
'------------------------------------------------------------------------------
' The USB class driver cog.
'------------------------------------------------------------------------------
class_driver
                drvl    #DRIVER_ACTIVE_LED
                waitx   ##_1ms * 5000                   ' Delay to allow time to get the serial terminal ready to receive
                call    #serial_init                    ' Init serial output and send startup splash text to terminal
                setluts #LSHARE_WRITE                   ' Allow host cog to write this LUT
                setse1  #D_EVENT_WR1FD                  ' Host write to LUT location D_EVENT triggers this event
                call    #dload_lut                      ' Load lut code/data from hub RAM, if any
                wrlut   #D_READY, #D_EVENT              ' Initialize shared LUT eventID
                mov     dpar1, #OPT_VERBOSE             ' Default verbose terminal output option flag
                or      dtxopts, dpar1
                mov     dpar1, #TX_VERBOSEB
                loc     ptra, #@sz_verbose_opt
                call    #dtx_opt_toggle
                call    #dpulse_led
                mov     dtask, #DT_GET_CON_INPUT
                call    #reset_cmd_prompt
'------------------------------------------------------------------------------
'------------------------------------------------------------------------------
driver_main
                pollct3                         wc
        if_c    call    #dpulse_led
                pollse1                         wc
        if_c    call    #do_devent                      ' The host cog has posted an event
                cmp     dtask, #DT_IDLE         wz
        if_nz   call    #do_task                        ' Process the current task
                jmp     #driver_main
' */
' /* post_hevent
'------------------------------------------------------------------------------
' Post an eventID to the host cog and wait for the host to signal that the
' event has been completed.
'------------------------------------------------------------------------------
' On entry:
'   devent - eventID to post.
'   dpar1, dpar2, dpar3 - parameters, depending on the event context.
' On exit:
'------------------------------------------------------------------------------
post_hevent_async
                rdlut   dtmp, #H_EVENT          wz      ' Wait for any pending host event to complete
        if_nz   jmp     #post_hevent_async
                wrlut   dpar1, #H_PAR1
                wrlut   dpar2, #H_PAR2
                wrlut   dpar3, #H_PAR3
        _ret_   wrlut   devent, #H_EVENT                ' Driver LUT location write triggers a host event
'------------------------------------------------------------------------------
post_hevent_sync
                rdlut   dtmp, #H_EVENT          wz      ' Wait for any pending host event to complete
        if_z    jmp     #.post
                cmp     dtmp, #H_END            wcz     ' FIXME: work-around for an invalid event code spin-lock issue
        if_be   jmp     #post_hevent_sync               ' It only happens at cold-start, but it looks like this LUT
                                                        ' location is getting initialized properly...
.post
                wrlut   dpar1, #H_PAR1
                wrlut   dpar2, #H_PAR2
                wrlut   dpar3, #H_PAR3
                wrlut   devent, #H_EVENT
' Wait for the host to execute the IRP and post that the results are ready
                waitse1
                rdlut   dpar1, #D_PAR1                  ' The CRC5/ep/addr for the txn
                rdlut   dpar2, #D_PAR2                  ' Txn result: PIDs ACK/NAK/STALL or error code
                rdlut   dpar3, #D_PAR3                  ' Context dependent value
        _ret_   wrlut   #D_READY, #D_EVENT              ' Ready for next event posting
' */
' /* do_devent
'------------------------------------------------------------------------------
' Jump table of class driver routines that will process data on behalf of the
' host or react to notifications that are posted by the host.
' IMPORTANT: this routine must be CALLed only from the driver_main loop, as it
' polls the P2 event that is triggered by a host write to its LUT. Since the
' handler routines are JMPed to, the devent_exit address is pushed to the
' hardware stack, so when the handler is at it's logical exit it can RET back
' to this routine so the host can be signaled that the handler has finished.
' This routine then RETs back to driver_main to close the loop:
'   [event->host->host exec->driver main->driver handler->driver main]
'------------------------------------------------------------------------------
do_devent
                rdlut   devent, #D_EVENT        wz
        if_z    ret                                     ' Zero is a nop
'                call    #dtx_dbg_stack_ret_addr
                rdlut   dpar1, #D_PAR1
                rdlut   dpar2, #D_PAR2
                rdlut   dpar3, #D_PAR3
                fle     dtmp, #D_END
                push    #devent_exit                    ' Event handlers return here
                jmprel  devent
devent_jmp
                ret                                     ' EventID zero is a NOP
                jmp     #htx_asciiz                     ' Host requested string output to terminal
                jmp     #htx_break                      ' Send host debug data to terminal, then halt
                jmp     #htx_dbg_data                   ' Send host debug data to terminal
                jmp     #htx_hexdump                    ' Dump raw data to terminal
                jmp     #connect_info
                jmp     #dev_disconnect
                jmp     #parse_dev_desc                 ' Parse string data in the device descriptor
                jmp     #parse_con_desc                 ' Parse config descriptor to determine if it's a known device class
                jmp     #get_dtxn_result                ' Host has posted results for a USB IRP that was posted by this driver
                jmp     #get_dtxn_hresult               ' Allows the host to send USB debug data to the serial terminal
devent_exit
        _ret_   wrlut   #D_READY, #D_EVENT              ' Event handled, so back to driver "main" loop
' */
' /* do_task
'------------------------------------------------------------------------------
' Handler jump table for tasks that this class driver understands. All jump
' targets are implemented as CALL targets.
'------------------------------------------------------------------------------
do_task
                fle     dtask, #DT_END
                jmprel  dtask
.dtask_jmp
                ret                                     ' TaskID zero is a NOP (DT_IDLE)
                jmp     #dset_config                    ' Configure (or not) a newly-connected device
                jmp     #boms_inquiry                   ' Query device capabilities
                jmp     #dsrch_fat_filesys              ' Check media for a valid FAT file system(s)
                jmp     #dget_con_input                 ' Check for and execute a console command
' */
' /* connect_info
'------------------------------------------------------------------------------
' Host notification that a device has connected. Initialize whatever is
' required prior to configuring the device.
'------------------------------------------------------------------------------
' On entry:
'   devent - eventID.
'   dpar1 - speed of the connected device.
' On exit:
'------------------------------------------------------------------------------
connect_info
                cmp     dpar1, #USB_SPEED_LOW   wz
        if_z    loc     ptra, #@sz_lowspeed
        if_nz   loc     ptra, #@sz_fullspeed
                call    #dtx_nl_asciiz
                mov     pa, #dreg_init_start            ' First cog register address of consecutive
.loop                                                   ' registers to reset to zero
                altd    pa                              ' Use pointer-based register indirection
                mov     0-0, #0                         ' Reset register content to zero
                add     pa, #1
                cmp     pa, #dreg_init_end      wz
        if_nz   jmp     #.loop                          ' Until end of register block reached
                ret
' */
' /* dev_disconnect
'------------------------------------------------------------------------------
' Host notification that a device was reset or has disconnected.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
dev_disconnect
                wrlut   #D_READY, #D_EVENT              ' Reset shared LUT eventID
                mov     device_base, #0                 ' Invalidate current device
                mov     drootdir_base, #0               ' Invalidate the BOMS device root directory location
                wrbyte  #"#", ##sz_cur_path
                wrbyte  #0, ##sz_cur_path + 3
                mov     dtask, #DT_GET_CON_INPUT        ' Back to command prompt
                loc     ptra, #@sz_disconnect
                call    #dtx_nl_asciiz                  ' Send disconnect message to the terminal
                jmp     #reset_cmd_prompt
' */
' /* get_dtxn_hresult
'------------------------------------------------------------------------------
' Retrieve the results of a USB transaction submitted via the event mechanism.
' IMPORTANT: The host must only use this eventID BEFORE the device has been
' configured.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   dpar1 - CRC5/ep/addr for the txn.
'   dpar2 - result code for the txn or error code.
'   dpar3 - content depends on the result context.
'------------------------------------------------------------------------------
get_dtxn_hresult
                rdlut   dpar1, #D_PAR1                  ' The CRC5/ep/addr for the txn
                rdlut   dpar2, #D_PAR2                  ' Txn result: PIDs ACK/NAK/STALL or error code
                rdlut   dpar3, #D_PAR3
                wrlut   #D_READY, #D_EVENT              ' Ready for next event posting
                mov     ptra, dpar1
                jmp     #dtx_result_to_con              ' Result routed to the terminal
' */
' /* get_dtxn_result
'------------------------------------------------------------------------------
' Retrieve the results of a USB transaction submitted via the event mechanism.
'------------------------------------------------------------------------------
' IMPORTANT: The host must NOT use this eventID until AFTER the device has been
' configured.
'------------------------------------------------------------------------------
' This routine is part of the class driver -> host -> class driver event
' mechanism, so care must be taken to ensure that the "parent" routine of the
' result handler exits properly. Since the result handler is entered via JMP,
' it must be the "parent" routine that assigned the dres_handler address to
' issue the RET when it has reached its logical exit. This will return to the
' do_devent routine, which closes the IRP event processing loop.
'------------------------------------------------------------------------------
' On entry:
'   dres_handler - the address of a routine that handles the USB IRP result.
' On exit:
'   dpar1 - CRC5/ep/addr for the txn.
'   dpar2 - result code for the txn.
'   dpar3 - content depends on the result context.
'------------------------------------------------------------------------------
get_dtxn_result
                rdlut   dpar1, #D_PAR1                  ' The CRC5/ep/addr for the txn
                rdlut   dpar2, #D_PAR2                  ' Txn result: PIDs ACK/NAK/STALL or error code
                rdlut   dpar3, #D_PAR3                  ' Context dependent value
                wrlut   #D_READY, #D_EVENT              ' Ready for next event posting
                jmp     dres_handler                    ' Off to the result handler
' */
' /* dexec_bulk_out
'------------------------------------------------------------------------------
' Post a bulk-OUT transfer IRP to the host. It is assumed that the caller has
' prepared the data buffer contents and that all bulk-OUT parameters have been
' populated with the values required to complete the transfer, and that the
' register dres_handler contains the address of the routine that will handle
' the transfer result returned by the host cog.
'------------------------------------------------------------------------------
' On entry:
'   bulkio_address: pointer to the first long of the bulk-OUT parameter block.
' On exit:
'------------------------------------------------------------------------------
dexec_bulk_out
                mov     devent, #HBULK_OUT
                mov     dpar1, bulkio_address
                jmp     #post_hevent_sync
' */
' /* dexec_bulk_in
'------------------------------------------------------------------------------
' Post a bulk-IN transfer on the USB. It is assumed that the IN transfer
' parameter block has been populated with all data required to complete the
' transfer.
'------------------------------------------------------------------------------
' On entry:
'   bulkio_address - pointer to the first long of the bulk-IN parameter block.
'   dres_handler - the address of a routine that will handle the transfer
'   result returned by the host cog.
' On exit:
'------------------------------------------------------------------------------
dexec_bulk_in
                mov     devent, #HBULK_IN
                mov     dpar1, bulkio_address
                jmp     #post_hevent_sync
' */
' #region SCSI Command Processing
' /* dexec_cbw
'------------------------------------------------------------------------------
' Perform a complete SCSI command CBW-OUT->data(in/out)->CSW-IN transfer
' sequence on the USB.
'------------------------------------------------------------------------------
' On entry:
'   cbw_xfer_len - the expected data phase bytes to receive/send.
'   cbw_flags - data transfer direction (BULK_DIR_IN/BULK_DIR_OUT).
'   cbw_io_data_ptr - the address of the buffer to be read/written in the data
'     transfer phase.
'   cbwcb_len - the length of the command's parameter block buffer. The caller
'     must have already populated the CBW structure CBWCB field with the
'     appropriate data for the SCSI command.
'   PA - address of the SCSI command "friendly name" string.
' On exit:
'   dpar2 - The USB result code for the transfer. PID_ACK on success else an
'     error code.
'   dpar3 - if no error, the data bytes sent/received, otherwise undefined.
'------------------------------------------------------------------------------
dexec_cbw
                incmod  dactive, ##500          wc
        if_c    drvnot  #DRIVER_ACTIVE_LED
                cmp     scsi_cmd_id, #CMD_REQUEST_SENSE wz
        if_z    mov     sense_status, #CBS_CMD_FAILED
        if_nz   mov     csw_status, #CBS_CMD_FAILED     ' Reset for new SCSI command
        if_nz   mov     sense_response, #0              ' Any existing sense data is no longer valid
                bitl    dtxopts, #BOMS_STALLB           ' Clear the BOMS STALL indicator
.rnd
                getrnd  stmp                            ' Generate a CBW tag for this command
                cmp     stmp, cbw_tag           wz      ' Could use a simple incrementing counter, but what's the fun in that
        if_z    jmp     #.rnd                           ' Not likely to happen, but ensure tag != prior tag
                mov     cbw_tag, stmp
                loc     ptra, #@CBWStruct
                wrlong  cbw_tag, ptra[lCBWTag]
                wrlong  cbw_xfer_len, ptra[lCBWDataXferLen]
                wrbyte  cbw_flags, ptra[bmCBWFlags]
                wrbyte  cbw_lun, ptra[bCBWLUN]
                wrbyte  cbwcb_len, ptra[bCBWCBLen]
                loc     ptra, #@CBWCB                   ' Get command parameters into the command block field
' The device shall ignore the content of the CBWCB field past (CBWCB + bCBWCBLen - 1)
                rep     #2, cbwcb_len
                rdbyte  stmp, ptrb++
                wrbyte  stmp, ptra++
                mov     ptra, pa                        ' Dump the command's CBW content to the terminal
                mov     lmm_p, ##CBWStruct
                mov     lmm_p2, #CBW_SIZE
                call    #dtx_dbg_hexbytes
                wrlong  #CBW_SIZE, ##dataout_total_bytes ' Size of the command block wrapper structure
                wrlong  ##CBWStruct, ##dataout_buff_ptr
                mov     bulkio_address, ##dataout_ep_addr ' Post the CBW transfer to the bulk OUT endpoint
                wrlong  ##CBWStruct, ##dataout_buff_ptr
                call    #dexec_bulk_out
.res_cmd
                cmp     dpar2, #PID_STALL       wz
        if_z    jmp     #stall_recovery                 ' Handle command block STALL
                cmp     dpar2, #PID_ACK         wz
        if_nz   ret                                     ' Any other USB fail regarding the CBW terminates the transfer
.data
                cmp     cbw_xfer_len, #0        wz
        if_z    jmp     #dreq_csw                       ' No data phase for this CBW
                waitx   ##_1us * 125                    ' Pause a bit before beginning the data phase
                test    cbw_flags, #BULK_DIR_IN wc
        if_nc   jmp     #.out
                mov     bulkio_address, ##datain_ep_addr ' Use bulk IN parameter block
                wrlong  cbw_xfer_len, ##datain_total_bytes
                wrlong  cbw_io_data_ptr, ##datain_buff_ptr
                call    #dexec_bulk_in
                jmp     #.res_data
.out
                mov     bulkio_address, ##dataout_ep_addr ' Use bulk OUT parameter block
                wrlong  cbw_xfer_len, ##dataout_total_bytes
                wrlong  cbw_io_data_ptr, ##dataout_buff_ptr
                call    #dexec_bulk_out
.res_data
' DEBUG: output actual data transferred if verbose option is active
                mov     data_actual_len, dpar3  wz      ' Get actual data phase bytes received/sent
                call    #dtx_cmd_data
                cmp     dpar2, #PID_STALL       wz
        if_z    jmp     #stall_recovery                 ' Handle data phase STALL
                cmp     dpar2, #PID_ACK         wz
        if_nz   ret                                     ' Let the caller deal with a USB fail
' Request the CSW from the device
dreq_csw
                mov     bulkio_address, ##datain_ep_addr
                wrlong  #CSW_SIZE, ##datain_total_bytes
                cmp     scsi_cmd_id, #CMD_REQUEST_SENSE wz
        if_z    wrlong  ##CSWRequestSense, ##datain_buff_ptr ' The REQUEST SENSE command has its own CSW
        if_nz   wrlong  ##CSWStruct, ##datain_buff_ptr  ' Normal CSW buffer
                call    #dexec_bulk_in
.dres_csw
                cmp     dpar2, #PID_ACK         wz
        if_nz   ret
                waitx   ##_1us * 333
' DEBUG: output CSW data if verbose option is active
                mov     csw_actual_len, dpar3
                loc     ptra, #@sz_csw
                rdlong  lmm_p, ##datain_buff_ptr
                mov     lmm_p2, #CSW_SIZE
                call    #dtx_dbg_hexbytes
' Ensure that the CSW is "valid and meaningful"
.validate_csw
                rdlong  ptra, ##datain_buff_ptr
                rdlong  dtmp, ptra++                    ' Is the CSW signature valid?
                rdlong  stmp, ptra++                    ' Did the device echo the CBW tag we trasmitted?
                rdlong  lmm_c, ptra++                   ' CSW residue and
                rdbyte  lmm_w, ptra++                   ' CSW status set to final registers later
' Tests for valid CSW:
                cmp     csw_actual_len, #CSW_VALID_LEN wz ' CSW actual size must match expected size
        if_nz   mov     lmm_w, #CBS_CSW_SIZE_ERROR
        if_nz   jmp     #.cb_error
                cmp     dtmp, ##CSWSignature    wz
        if_nz   mov     lmm_w, #CBS_BAD_SIGNATURE
        if_nz   jmp     #.cb_error
                cmp     stmp, cbw_tag           wz
        if_nz   mov     lmm_w, #CBS_TAG_MISMATCH
        if_nz   jmp     #.cb_error
' Tests for meaningful CSW
                cmp     lmm_w, #CBS_PHASE_ERROR wz
        if_z    jmp     #.cb_error                      ' Phase error gets handled as a special case
                cmp     lmm_c, cbw_xfer_len     wcz     ' Residue must be <= CBW's expected IN/OUT transfer length
        if_a    mov     lmm_w, #CBS_RESIDUE_ERROR
        if_a    jmp     #.cb_error                      ' Not meaningful if either is above its limit
                subr    lmm_c, cbw_xfer_len             ' A residue > zero is the count of relevant/processed data bytes
                cmp     lmm_w, #CBS_CMD_FAILED  wz      ' Final test is status PASS/FAIL
        if_z    jmp     #.cb_error
.exit
                cmp     scsi_cmd_id, #CMD_REQUEST_SENSE wz
        if_z    mov     sense_residue, lmm_c
        if_z    mov     sense_status, lmm_w
        if_nz   mov     csw_residue, lmm_c
        if_nz   mov     csw_status, lmm_w
                ret
.cb_error
' FIXME: gotta find a better way to do this...
                call    #.exit
                loc     ptra, #@sz_csw_status           ' We have a SCSI command status error
                call    #dtx_nl_asciiz
                loc     ptra, #@csw_error_ptr
                mov     stmp, csw_status
                shl     stmp, #2                        ' Accessing long-based pointer table
                add     ptra, stmp                      ' Address of the error code string to output
                rdlong  ptra, ptra
                jmp     #dtx_asciiz
' */
' /* stall_recovery
'------------------------------------------------------------------------------
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
stall_recovery
'                call    #dtx_stack_ret_addr
                cmp     cbw_flags, #BULK_DIR_IN wz      ' Determine which endpoint must be cleared
        if_z    loc     ptra, #@sz_bulkin_stall
        if_z    loc     pb, #@datain_next_datax
        if_nz   loc     ptra, #@sz_bulkout_stall
        if_nz   loc     pb, #@dataout_next_datax
                call    #dtx_nl_asciiz
.clear_endpoint
                call    #dreq_clear_endpoint
.res_clr_ep
                loc     ptra, #@sz_clr_endp_result
                call    #dtx_result_to_con
                cmp     dpar2, #PID_ACK         wz
        if_nz   ret
                wrlong  #PID_DATA0, pb                  ' Reset the DATAx sync PID
                bith    dtxopts, #BOMS_STALLB           ' This SCSI command triggered a STALL condition
                waitx   ##_1ms * 3
                jmp     #dreq_csw
' */
' /* dtx_cmd_data
' Output SCSI command read/write data to terminal if verbose option is active
dtx_cmd_data
                cmp     data_actual_len, #0     wz
        if_z    loc     ptra, #@sz_cmd_nodata
        if_z    jmp     #dtx_nl_asciiz
                loc     ptra, #@sz_cmd_data
                mov     lmm_p, cbw_io_data_ptr
                mov     lmm_p2, data_actual_len
                jmp     #dtx_dbg_hexbytes
' */
'------------------------------------------------------------------------------
' SCSI command routines.
'------------------------------------------------------------------------------
' /* read10
'------------------------------------------------------------------------------
'------------------------------------------------------------------------------
' On entry:
'   cbw0 - start physical block address for the read.
'   cbw1 - count of sectors to read.
'   cbw_io_data_ptr - buffer address for received data.
' On exit:
'   PTRB - address of the opcode CB buffer.
'------------------------------------------------------------------------------
read10
                mov     dtx, cbw0
                call    #dtx_dbg_nl_decimal
                mov     dtx, cbw1
                call    #dtx_dbg_nl_decimal
                mov     scsi_cmd_id, #CMD_READ10
                mov     cbw_flags, #BULK_DIR_IN
                mov     cbwcb_len, #READ10_CBLEN
                mov     cbw_xfer_len, cbw1              ' The SCSI READ command uses a sector count
                shl     cbw_xfer_len, dsec_shft         ' But the USB data transfer phase uses a byte count
                loc     ptrb, #@cb_read10
                ' SCSI opcode is defined in the CB buffer
                wrbyte  #0, ptrb[bmRD10_RDProtect]      ' FIXME: need to handle RDPROTECT field
                mov     stmp, cbw0                      ' Starting block address
                movbyts stmp, #%%0123                   ' LBA address goes on USB as big endian
                wrlong  stmp, ##cb_read10 + 2           ' FIXME
'                wrlong  stmp, ptrb[##2]
                wrbyte  #0, ptrb[bmRD10_GroupNumber]
                mov     stmp, cbw1                      ' Sector count word also big endian
                movbyts stmp, #%%3201
                wrword  stmp, ##cb_read10 + 7           ' FIXME
'                wrword  stmp, ptrb[##7]                 ' Transfer length also big endian
                ' Control
                loc     pa, #@sz_read10
                call    #dexec_cbw
                mov     ptra, pa
                call    #dtx_result_to_con
                cmp     dpar2, #PID_ACK         wz
        if_nz   ret                                     ' If it's a USB error, a REQUEST SENSE is not needed
                cmp     csw_status, #CBS_CMD_PASSED wz
                testb   dtxopts, #BOMS_STALLB   wc      ' STALLed end point may return a CSW with PASSED status
    if_z_and_nc ret
                call    #request_sense
        _ret_   mov     csw_status, #CBS_CMD_FAILED
' */
' /* write10
'------------------------------------------------------------------------------
'------------------------------------------------------------------------------
' On entry:
'   cbw0 - start physical block address for the write.
'   cbw1 - count of sectors to write.
'   cbw_io_data_ptr - buffer address of data to write.
' On exit:
'   PTRB - address of the opcode CB buffer.
'------------------------------------------------------------------------------
write10
                mov     dtx, cbw0
                call    #dtx_dbg_nl_decimal
                mov     dtx, cbw1
                call    #dtx_dbg_nl_decimal
                mov     scsi_cmd_id, #CMD_WRITE10
                mov     cbw_flags, #BULK_DIR_OUT
                mov     cbwcb_len, #WRITE10_CBLEN
                mov     cbw_xfer_len, cbw1              ' The SCSI WRITE command uses a sector count
                shl     cbw_xfer_len, dsec_shft         ' But the USB data transfer phase uses a byte count
                loc     ptrb, #@cb_write10
                ' SCSI opcode is defined in the CB buffer
                wrbyte  #0, ptrb[bmWR10_WRProtect]      ' FIXME: need to handle WRPROTECT field
                mov     stmp, cbw0                      ' Starting block address
                movbyts stmp, #%%0123                   ' LBA address goes on USB as big endian
                wrlong  stmp, ##cb_write10 + 2          ' FIXME
'                wrlong  stmp, ptrb[##2]
                wrbyte  #0, ptrb[bmWR10_GroupNumber]
                mov     stmp, cbw1                      ' Sector count word also big endian
                movbyts stmp, #%%3201
                wrword  stmp, ##cb_write10 + 7          ' FIXME
'                wrword  stmp, ptrb[##7]                 ' Transfer length also big endian
                ' Control
                loc     pa, #@sz_write10
                call    #dexec_cbw
                mov     ptra, pa
                call    #dtx_result_to_con
                cmp     csw_status, #CBS_CMD_PASSED wz
                testb   dtxopts, #BOMS_STALLB   wc      ' STALLed end point may return a CSW with PASSED status
    if_z_and_nc ret
                call    #request_sense
        _ret_   mov     csw_status, #CBS_CMD_FAILED
' */
' /* read_format_capacities
'------------------------------------------------------------------------------
' On entry:
'   cbw_xfer_len - expected size of the IN response data.
'   PB - address of the caller's handler routine for the result of the SCSI
'     command transfer.
' On exit:
'   PTRB - address of the opcode CB buffer.
'   cbw_xfer_len - actual size of the IN response data.
'------------------------------------------------------------------------------
{
read_format_capacities
'                call    #dtx_dbg_stack_ret_addr
                mov     scsi_retry, #3
.retry
                waitx   ##_1ms * 1000
                mov     scsi_cmd_id, #CMD_RDFMTCAPS
                mov     cbw_flags, #BULK_DIR_IN
                mov     cbwcb_len, #RDFMTCAPS_CBLEN
                mov     cbw_io_data_ptr, ##RdFmtCapacities ' DEBUG: keep results for now
                loc     ptrb, #@cb_rd_fmt_capacities
                ' SCSI opcode is defined in the CB buffer
                ' Bytes 1..6 reserved, must be zero
                getbyte stmp, cbw_xfer_len, #1          ' Transfer length word transmitted as big endian
                wrbyte  stmp, ptrb[bRFCap_AllocLen]
                getbyte stmp, cbw_xfer_len, #0
                wrbyte  stmp, ptrb[bRFCap_AllocLen + 1]
                ' Control
                loc     pa, #@sz_rd_fmt_capacities
                call    #dexec_cbw
'                call    #dtx_dbg_stack_ret_addr
                mov     ptra, pa
                call    #dtx_result_to_con
                cmp     dpar2, #PID_ACK         wz
        if_z    cmp     csw_status, #CBS_CMD_PASSED wz
                testb   dtxopts, #BOMS_STALLB   wc      ' STALLed end point may return a CSW with PASSED status
    if_z_and_nc jmp     #.get_data
' Command issue of some kind, so check sense data to see if we can handle it
                call    #request_sense
'                call    #dtx_dbg_stack_ret_addr
                cmp     sense_status, #CBS_CMD_PASSED wz
        if_nz   ret
                getword stmp, asc_ascq, #0
                cmp     stmp, #ASC_Q_MEDIUM_NOT_PRESENT wz
        if_z    cmp     scsi_retry, #2          wz
        if_z    jmp     #dtx_nl_asc_ascq
                cmp     sense_key, #S_NOT_READY wz
        if_nz   cmp     sense_key, #S_UNIT_ATTENTION wz
        if_z    jmp     #.again
                jmp     #dtx_nl_asc_ascq                ' Output sense code to terminal and return to caller
.get_data
                loc     ptra, #@RdFmtCapacities
                rdlong  dhighest_lba_plus1, ptra[lCapNumBlocks] ' Store capacity data
                movbyts dhighest_lba_plus1, #%%0123     ' Received as big endian, so reverse
                rdlong  dsec_size, ptra[lDescTypeBlockLen]
                movbyts dsec_size, #%%1230              ' Reverse so bytes 3..1 are sector length, byte 0 descriptor type
                getbyte stmp, dsec_size, #0             ' Isolate the descriptor type byte
                shr     dsec_size, #8                   ' and align sector length
' Output last lba and sector size if available
                loc     ptra, #@sz_format_info
                call    #dtx_nl_asciiz
                mov     dtx, stmp
                call    #dtx_hexbyte
                loc     ptra, #@sz_highest_lba
                call    #dtx_nl_asciiz
                mov     dtx, dhighest_lba_plus1
                call    #dtx_decimal
                loc     ptra, #@sz_sec_size
                call    #dtx_nl_asciiz
                mov     dtx, dsec_size
                jmp     #dtx_decimal
.again
                cmp     stmp, #ASC_Q_MEDIUM_NOT_PRESENT wz
        if_z    jmp     #dtx_nl_asc_ascq
                djnz    scsi_retry, #.retry
                jmp     #dtx_nl_asc_ascq
'        _ret_   mov     csw_status, CBS_CMD_FAILED
' */
}
' #endregion SCSI Commands
' /* Class driver registers
caller_ret_addr long    0
target_ret_addr long    0
dactive         long    0
dstr_ptr        long    0                               ' Used only by the dstr* string routines
dstr_idx        long    0
dstr_par1       long    0
dstr_par2       long    0
dstr_ret1       long    0
dstr_ret2       long    0
min_digits      long    1                               ' Suppress leading zeros of decimal output up to min_digits
dpad_char       long    0                               ' Character to use when applying a left/right format pad
didx            long    0                               ' Generic index
drep            long    0                               ' Repeat count
dr0             long    0                               ' Driver general purpose registers
dr1             long    0
dr2             long    0
dr3             long    0
dr4             long    0
stmp            long    0
dtmp            long    0
dpar1           long    0                               ' Routine entry parameters
dpar2           long    0
dpar3           long    0
dret1           long    0                               ' Routine return parameters
dret2           long    0
dret3           long    0
dpar_ptr        long    0                               ' Generic pointer register for parameter processing
dirp_results    long    0                               ' Byte0 USB result, byte1 CSW result, word1 
dct3            long    0                               ' Driver main loop blinking LED timer
dterm_type      long    TERM_DUMB                       ' TERM_VT100 or TERM_PST (Propeller Serial Terminal)
dtxopts         long    0                               ' Value->text conversion option bitflags
dtx             long    0                               ' Character to output
drx             long    0                               ' Terminal input character
devent          long    0                               ' Command/request eventID posted by the host cog
dres_handler    long    0                               ' Address of an IRP result handler routine
conf_chain_len  long    0                               ' Size of the complete config descriptor chain
hid_intf_idx    long    0                               ' Used during verbose descriptor terminal output
next_desc       long    0                               ' Offset from the config descriptor start address to
                                                        ' the next descriptor in the chain
langid          long    0                               ' Keep LangID sticky
ctrl_ep_addr    long    0                               ' Ep/addr for control transactions
' SCSI stuff
cbw0            long    0                               ' SCSI command block parameter registers
cbw1            long    0
scsi_retry      long    0
scsi_cmd_id     long    0                               ' The ID of the current SCSI command
msd_status      long    0                               ' MSB|Reserved|Bitflags|OUT EpAddr|IN EpAddr|LSB
cbw_tag         long    0                               ' A value that associates this CBW with the CSW that the device returns
cbw_xfer_len    long    0                               ' Bulk OUT/IN data bytes to send/expect to/from the device
csw_actual_len  long    0
csw_residue     long    0                               ' Status IN/OUT data residue
csw_status      long    0                               ' Command block transfer overall status
cbw_flags       long    0                               ' Direction of the data transport phase (BULK_DIR_IN or BULK_DIR_OUT)
cbw_lun         long    0                               ' LUN number for devices with multiple LUNs, otherwise zero
cbwcb_len       long    0                               ' CBW command descriptor block field length, valid values 1..16
cbw_io_data_ptr long    0                               ' Data buffer pointer for this bulk IN/OUT transfer
data_actual_len long    0                               ' Actual data bytes sent/received for a USB transfer
bulkio_address  long    0                               ' The device address and IN/OUT endpoint for this transfer
sense_key       long    0                               ' A generic look-up code
sense_residue   long    0
sense_status    long    0
sense_response  long    0                               ' Zero if no valid sense data, otherwise sense data buffer pointer
asc_ascq        long    0                               ' Packed code index and ASC/ASCQ sense codes: |Idx|Unused|ASCQ|ASC|
' Miscellaneous FAT file system stuff
ftmp            long    0
fr0             long    0                               ' Scratch registers
fr1             long    0
fr2             long    0
fpar1           long    0                               ' Routine entry parameters
fpar2           long    0
fpar3           long    0
fret1           long    0                               ' Routine return parameters
fret2           long    0
fret3           long    0
dirent_ptr      long    0                               ' Directory entry pointer
dirent_flgs     long    0                               ' Directory entry type flags
dirent_cnt      long    0                               ' Count of directory entry structs in the buffer
dir_next_clus   long    0
dis_rootdir     long    0                               ' Non-zero if root is the current directory
datpar1         long    0
datret1         long    0
next_data_clus  long    0                               ' Internal use
dnum_files      long    0
dtot_bytes_lo   long    0
dtot_bytes_hi   long    0
dfree_bytes     long    0
dnum_dirs       long    0
drd_bytes       long    0
dwr_bytes       long    0
dclus_offset    long    0                               ' FAT region offset to a cluster# entry
cmd_char_ptr    long    0                               ' Hub address of the current command character
cmd_len         long    0                               ' Length of the current console command line
promt_len       long    0                               ' Length of the current prompt e.g. A:\SOME\PATH>
dcur_path_len   long    0                               ' Length of the current file path string
dhighest_lba    long    0                               ' Highest LBA address (total sectors - 1) of the media
dsec_size       long    0                               ' Count of bytes per sector
dsec_shft       long    0                               ' Convert sectors to/from bytes
dclus_shft      long    0                               ' Convert sectors to/from clusters
dclus_size      long    0                               ' Count of bytes per cluster
'------------------------------------------------------------------------------
' Define registers you want initialized to zero at device reset/disconnect
' between labels dreg_init_start/dreg_init_end.
'------------------------------------------------------------------------------
dreg_init_start
' Directory registers:
ddir_last_entry long    0                               ' Last allocated directory entry#
' Registers to track cached volume resources
dcur_fat_sec    long    0                               ' Sector# of the current FAT region buffer
dcur_dir_sec    long    0                               ' Start sector# of the current directory buffer
dcur_dir_entry  long    0                               ' Offset of the current directory entry
dcur_data_sec   long    0                               ' Physical sector# of the current data region buffer content
dcur_data_clus  long    0                               ' Data cluster# associated with the above buffer contents
' Miscellaneous FAT file system stuff
dvol_base       long    0                               ' The sector# of the volume's first sector
dfat_base       long    0                               ' First sector of the FAT region
dfsinfo_base    long    0                               ' Sector# of the FSInfo structure
drootdir_base   long    0                               ' First sector of the root directory
drootdir_clus   long    0                               ' Cluster number of the root directory, zero if FAT16
dfile_dir_base  long    0                               ' Sector# of the first cluster of the data region
ddat_clus_cnt   long    0                               ' Count of data clusters
dfat_size       long    0                               ' Count of sectors in the FAT region of the volume
dnum_fats       long    0                               ' Count of FAT regions; must be at least 1 (+ N copies)
dptn_secs       long    0                               ' Total number of sectors in the partition
dptn_type       long    0                               ' Partition type code
dvol_secs       long    0                               ' Volume sectors must be <= partition sectors
drsvd_sec_cnt   long    0                               ' Count of reserved sectors
df16_dir_secs   long    0                               ' Count of directory sectors for FAT16, zero if FAT32
dfat_ofst_shft  long    0                               ' Used to calculate FAT cluster entry locations
dfsi_free_clus  long    0                               ' FSInfo count of free data clusters field
dfsi_clus_hint  long    0                               ' FSInfo next free cluster hint field
' Class task stuff
dtask           long    0                               ' Class driver's current task focus
device_base     long    0                               ' Base address for the device descriptor buffer
conf_base_addr  long    0                               ' Base address for config descriptor chain buffer
parse_result    long    0
dreg_init_end
'------------------------------------------------------------------------------
                long    -1[$1e0 -1 - $]                 ' Fill remaining free space with $FFs
                long    DBG_FEEDBEEF
                fit     $1e0
' */
' /* Cog variables for the P2 monitor in ROM
''============[ COG VARIABLES - MONITOR]========================================
                org     $1E0              ' place the variables in cog $1E0-$1EF
''-------[ LMM parameters, etc ]------------------------------------------------
lmm_x           res     1       ' parameter passed to/from LMM routine (typically a value)
lmm_f           res     1       ' parameter passed to      LMM routine (function options; returns unchanged)
lmm_p           res     1       ' parameter passed to/from LMM routine (typically a hub/cog ptr/addr)
lmm_p2          res     1       ' parameter passed to/from LMM routine (typically a 2nd hub/cog address)
lmm_c           res     1       ' parameter passed to/from LMM routine (typically a count)
''-------[ LMM additional workareas ]-------------------------------------------
lmm_w           res     1       ' workarea (never saved - short term use between calls, except _HubTx)
lmm_tx          res     1       ' _HubTx
lmm_hx          res     1       ' _HubHex/_HubString
lmm_hx2         res     1       ' _HubHex
lmm_hc          res     1       '   "
lmm_lx          res     1       ' _HubList
lmm_lf          res     1       '   "
lmm_lp          res     1       '   "
lmm_lp2         res     1       '   "
lmm_lc          res     1       '   "
lmm_bufad       long    _HUBBUF ' Monitor default rx buffer address
' */
                fit     $1f6                            ' Not using interrupt registers
' #endregion DAT (Class Driver Cog)
' #region DAT (Class Driver LUT)
                org     DLUT_BASE + $200                ' Class driver "owns" LUT cells starting here
dlut_start
' /* dtx_opt_toggle
'------------------------------------------------------------------------------
' Output an on/off state description to the serial terminal.
'------------------------------------------------------------------------------
' On entry:
'   ptra - the address of the option description string.
'   dpar1 - the bitflag state of the option.
' On exit:
'------------------------------------------------------------------------------
dtx_opt_toggle
                call    #dtx_nl_asciiz
                testb   dtxopts, dpar1          wc
        if_nc   loc     ptra, #@sz_off
        if_c    loc     ptra, #@sz_on
                jmp     #dtx_asciiz
' */
' /* dget_con_input
'------------------------------------------------------------------------------
' Process console input.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
dget_con_input
                call    #drx_char_nowait
        if_nc   ret
                cmp     lmm_x, #ESC             wz
        if_z    jmp     #reset_cmd_prompt
                cmp     lmm_x, #TAB             wz
        if_z    ret                                     ' Ignore key
                cmp     lmm_x, #CR              wz
        if_z    jmp     #.get_cmd
                cmp     lmm_x, #BSP             wz
        if_z    jmp     #.bs
                loc     ptra, #@con_rx_buff
                add     ptra, cmd_len
                wrword  lmm_x, ptra                     ' Add character and zero terminator in one write
                add     cmd_len, #1
                jmp     #_HubTx
.bs
                cmp     cmd_len, #0             wz
        if_z    ret                                     ' Ignore BS if no command characters
                loc     ptra, #@con_rx_buff
                sub     cmd_len, #1
                add     ptra, cmd_len
                wrbyte  #0, ptra                        ' FIXME: should be a better way to terminate BS
                mov     lmm_x, ##BSP | " " << 8 | BSP << 16
                jmp     #_HubTx
.get_cmd
                cmp     cmd_len, #0             wz
        if_z    jmp     #reset_cmd_prompt
                loc     ptra, #@con_rx_buff
                loc     ptrb, #@con_cmd_buff
                mov     dpar1, #" "                     ' Just want the command word if there are parameters
                call    #dstrcpybc_toupper              ' Make command word copy uppercase for comparison
.isws
                rdbyte  lmm_c, ptra                     ' Eat any command trailing whitespace
                call    #disspace                       ' NZ if lmm_c == whitespace
        if_nz   add     ptra, #1
        if_nz   jmp     #.isws
                loc     ptrb, #@con_par_buff
                call    #dstrcpy_toupper                ' Copy and convert to uppercase command parameters, if any
                mov     lmm_p, ##con_rx_buff
                mov     lmm_x, #0
                mov     lmm_c, cmd_len
                call    #dmemset                        ' Clear the serial rx buffer
                mov     fr0, #0                         ' Word list index is jump table index
                loc     ptra, #@con_cmd_list
.loop
' Command word list format: byte 3, "DIR", 0, 4, "COPY", 0, 6, "FORMAT", 0[2]
                rdbyte  stmp, ptra++            wz
        if_z    jmp     #.unknown
                loc     ptrb, #@con_cmd_buff            ' Input command word to compare
                call    #dstrcmp                        ' On exit dstr_ret1 has count of matched characters
        if_e    jmp     #exec_os_cmd
                sub     stmp, dstr_ret1
                add     ptra, stmp
                add     fr0, #1
                jmp     #.loop
.unknown
                loc     ptra, #@sz_cmd_unknown
                call    #dtx_newline
                call    #dtx_asciiz
reset_cmd_prompt
                call    #dtx_newline
                wrlong  #0, ##con_par_buff
                mov     cmd_len, #0
                wrbyte  cmd_len, ##con_rx_buff          ' Command buffer ready for new input
                call    #dtx_dbg_stack_ret_addr
                loc     ptra, #@sz_cur_path
                call    #dtx_nl_asciiz
                mov     dtx, #">"
                jmp     #dtx_char
exec_os_cmd
                rdbyte  drx, ##sz_cur_path              ' Pre-fetch the volume letter ("#" if no volume mounted)
                push    ##reset_cmd_prompt
                jmprel  fr0
                jmp     #dtx_cls
                jmp     #os_cmd_dir
                jmp     #os_cmd_dirw
                jmp     #os_cmd_tgldbg
                jmp     #os_cmd_cat
                jmp     #os_cmd_cat                     ' TYPE command is a CAT alias
                jmp     #rom_monitor
                jmp     #os_cmd_cd
                jmp     #os_cmd_scanfat
                jmp     #os_cmd_getsec
                jmp     #os_cmd_putsec
                jmp     #os_cmd_test
' */
' /* read_capacity10
'------------------------------------------------------------------------------
' On entry:
'   cbw_io_data_ptr - buffer address for received data.
' On exit:
'   PTRB - address of the opcode CB buffer.
'------------------------------------------------------------------------------
read_capacity10
                mov     scsi_retry, #0
.retry
                waitx   ##_1ms * 250
                mov     scsi_cmd_id, #CMD_READ_CAPACITY10
                mov     cbw_flags, #BULK_DIR_IN
                mov     cbwcb_len, #RD_CAP10_CBLEN
                mov     cbw_xfer_len, #RD_CAP10_DATA_LEN ' Static size for returned data
                mov     cbw_io_data_ptr, ##RdCapacity10 ' DEBUG: keep results for now
                loc     ptrb, #@cb_read_capacity10
                ' SCSI opcode is defined in the CB buffer
                'Partial Medium Indicator bit is obsolete, so remaining field bytes are zero
                ' Control
                loc     pa, #@sz_read_capacity10
                call    #dexec_cbw
                mov     ptra, pa
                call    #dtx_result_to_con
                cmp     csw_status, #CBS_CMD_PASSED wz
                testb   dtxopts, #BOMS_STALLB   wc      ' STALLed end point may return a CSW with PASSED status
    if_z_and_nc jmp     #.get_data
' Command issue of some kind, so check sense data to see if we can handle it
                call    #request_sense
                cmp     sense_status, #CBS_CMD_PASSED wz
        if_nz   ret
                getword stmp, asc_ascq, #0
                cmp     sense_key, #S_UNIT_ATTENTION wz
        if_z    cmp     stmp, #ASC_Q_NOTRDY_RDY_CHANGE wz
        if_z    jmp     #.again
                cmp     stmp, #ASC_Q_MEDIUM_NOT_PRESENT wz ' It's a mass storage device, but no media
        if_z    mov     drootdir_base, stmp             ' Tell the console loop there's a device, but no media
        _ret_   mov     csw_status, #CBS_CMD_FAILED
.again
                incmod  scsi_retry, #3          wc
        if_c    jmp     #.fail
                loc     ptra, #@sz_cmd_retry
                call    #dtx_nl_asciiz
                jmp     #.retry
.fail
'                djnz    scsi_retry, #.retry
                mov     csw_status, #CBS_CMD_FAILED
                jmp     #dtx_nl_asc_ascq
.get_data
                loc     ptra, #@RdCapacity10
                rdlong  dhighest_lba, ptra++            ' Store capacity data
                movbyts dhighest_lba, #%%0123           ' Received as big endian, so reverse
                rdlong  dsec_size, ptra
                movbyts dsec_size, #%%0123              ' Same with sector size
                encod   dsec_shft, dsec_size            ' Set up efficient sector->bytes conversion
' DEBUG: Output highest lba and sector size
                loc     ptra, #@sz_highest_lba
                call    #dtx_nl_asciiz
                mov     dtx, dhighest_lba
                call    #dtx_decimal
                loc     ptra, #@sz_sec_size
                call    #dtx_nl_asciiz
                mov     dtx, dsec_size
                jmp     #dtx_decimal
' */
' /* request_sense
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   sense_key - the response sense key code.
'   sense_ascq - packed code index and ASC/ASCQ sense codes:
'     |Idx|Unused|ASCQ|ASC|
'------------------------------------------------------------------------------
request_sense
                mov     scsi_cmd_id, #CMD_REQUEST_SENSE
                mov     cbw_flags, #BULK_DIR_IN
                mov     cbwcb_len, #REQ_SENSE_CBLEN
                mov     cbw_xfer_len, #SENSE_DATA_MIN_LEN ' DEBUG: for now always ask for max response data
                mov     cbw_io_data_ptr, ##RequestSenseData ' Want to keep sense data around
                loc     ptrb, #@cb_request_sense
                ' SCSI opcode is defined in the CB buffer
                ' Set bmRQSENS_DescFormat field to zero to retrieve the fixed format data
                ' wRQSENS_RS_Reserved always zero
                wrbyte  cbw_xfer_len, ptrb[bRQSENS_AllocLen]
                ' Control
                loc     pa, #@sz_request_sense
                call    #dexec_cbw
                mov     ptra, pa
                call    #dtx_result_to_con
                cmp     sense_status, #CBS_CMD_PASSED wz
        if_nz   ret
                subr    sense_residue, cbw_xfer_len     ' Data bytes we expected - bytes device considers "valid"
                loc     ptra, #@RequestSenseData
                rdbyte  sense_response, ptra            ' Verify the sense response code
                and     sense_response, #SENSE_RESPONSE_MASK
                cmp     sense_response, #SENSE_RESPONSE_70h wz
        if_nz   cmp     sense_response, #SENSE_RESPONSE_71h wz
        if_nz   mov     sense_response, #0              ' We only request fixed format sense, so something's wonky
                rdbyte  sense_key, ptra[bmF_E_I_R_SK]
                and     sense_key, #SENSE_KEY_MASK
                cmp     sense_key, #S_UNIT_ATTENTION wcz ' Cap the sense key at the highest one we know
        if_a    mov     sense_key, #S_KEY_UNKNOWN
' ASC/ASCQ code combination lookup
                rdword  asc_ascq, ptra[wASC_ASCQ]   wz  ' Get the ASC/ASCQ code combination
                loc     ptra, #@sz_asc                  ' Output ASC/ASCQ values
                call    #dtx_nl_asciiz
                getbyte dtx, asc_ascq, #0
                call    #dtx_hexbyte
                loc     ptra, #@sz_ascq
                call    #dtx_asciiz
                getbyte dtx, asc_ascq, #1
                call    #dtx_hexbyte
                loc     ptra, #@asc_ascq_codes
                mov     lmm_c, #0
.loop
                rdword  lmm_p, ptra++
                cmp     lmm_p, asc_ascq          wz
        if_nz   cmp     lmm_p, ##ASC_Q_UNKNOWN  wz
        if_z    jmp     #.packit
                add     lmm_c, #1
                jmp     #.loop
.packit
                shl     lmm_c, #2                       ' String pointers are hub longs, so adjust index
                setbyte asc_ascq, lmm_c, #3             ' Pack the list index with the code pair
' Output sense key and ASC/ASCQ code pair friendly name text
dtx_nl_asc_ascq
                call    #dtx_newline
dtx_asc_ascq
                mov     lmm_c, sense_key
                loc     ptra, #@sz_s_error_ptr
                call    #dtx_indexed_asciiz
                loc     ptra, #@sz_colon_space
                call    #dtx_asciiz
                loc     ptra, #@asc_error_ptr
                getbyte lmm_c, asc_ascq, #3             ' Get the friendly name string pointer from the table
                add     ptra, lmm_c
                rdlong  ptra, ptra
                jmp     #dtx_asciiz
' */
' /* test_unit_ready
'------------------------------------------------------------------------------
' Check if the logical unit is ready to accept medium access commands.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
test_unit_ready
                mov     scsi_cmd_id, #CMD_TEST_UNIT_READY
                mov     cbwcb_len, #TEST_UNIT_RDY_CBLEN
                mov     cbw_xfer_len, #0                ' No data stage for this command
                mov     cbw_flags, #0
                mov     cbw_io_data_ptr, #0
                loc     ptrb, #@cb_test_unit_ready
                ' SCSI opcode is defined in the CB buffer
                ' The command block is empty
                ' Control
                loc     pa, #@sz_test_unit_ready
                call    #dexec_cbw
                mov     ptra, pa
                jmp     #dtx_result_to_con              ' The caller must deal with the call result
' */
dlut_end        long    0[DLUT_TOP + $200 -1 - $]
                long    DBG_FEEDBEEF
                fit     DLUT_TOP + $200                 ' Reserve space for the host shared LUT interface
{
' /* dtx_cmd_data
' Output SCSI command read/write data to terminal if verbose option is active
dtx_cmd_data
                cmp     data_actual_len, #0     wz
        if_z    loc     ptra, #@sz_cmd_nodata
        if_z    jmp     #dtx_nl_asciiz
                loc     ptra, #@sz_cmd_data
                mov     lmm_p, cbw_io_data_ptr
                mov     lmm_p2, data_actual_len
                jmp     #dtx_dbg_hexbytes
' */
}
' #endregion DAT (Class Driver LUT)
' #region DAT (Class Driver HubExec)
'------------------------------------------------------------------------------
' USB Class Driver hub exec routines. Save the cog space for time critical
' stuff.
'------------------------------------------------------------------------------
dat
                orgh
                alignl
' /* parse_dev_desc
'------------------------------------------------------------------------------
' Parse the device descriptor. The descriptor members that need to be parsed
' are largely dependant on the class type of the connected device.
'------------------------------------------------------------------------------
' On entry:
'   devent - DINF_DEV_DESC.
'   dpar1 - device address and control the pipe endpoint (always 0).
'   dpar2 - start address of the cached device descriptor struct.
' On exit:
'------------------------------------------------------------------------------
parse_dev_desc
                call    #init_io_data                   ' Set the class driver I/O cog registers and RAM storage
                mov     ctrl_ep_addr, dpar1             ' Save the ctrlep/addr of the device
                mov     device_base, dpar2              ' Save start address of device descriptor
                loc     ptra, #@sz_getdev_result        ' This event is only posted by the host if has
                mov     dpar2, dpar3                    ' successfully retrieved the device descriptor,
                call    #dtx_result_to_con              ' so an ACK result can be assumed.
                mov     ptra, device_base
                rdbyte  dtmp, ptra[DEV_bMaxPktSize0]    ' Save the max payload size allowed for control data I/O
                wrbyte  dtmp, ##ctrl_io_max_pkt
                ret
' */
' /* parse_con_desc
'------------------------------------------------------------------------------
' Parse a configuration descriptor chain to see if the device is a recognized
' one. If it is, start the task progression that will configure the device for
' use.
'------------------------------------------------------------------------------
' On entry:
'   devent - DINF_CON_DESC.
'   dpar1 - device address and control pipe endpoint (0).
'   dpar2 - start address of the cached config descriptor chain.
' On exit:
'------------------------------------------------------------------------------
parse_con_desc
                mov     ctrl_ep_addr, dpar1             ' Get ctrlep/addr of the device
                mov     conf_base_addr, dpar2           ' Save start address of config chain
                loc     ptra, #@sz_getconf_result       ' This event is only posted by the host if it has
                mov     dpar2, dpar3                    ' successfully retrieved the configuration descriptor,
                call    #dtx_result_to_con              ' so an ACK result can be assumed.
                mov     dtmp, #CON_wTotalLen            ' to startup values
                add     dtmp, conf_base_addr
                rdword  conf_chain_len, dtmp            ' Keep config chain size handy
                call    #search_bbb_triad               ' The heavy lifting for device identification is done here
        _ret_   mov     dtask, #DT_SET_CONF             ' Direct to configuration decision
' */
' /* search_bbb_triad
'------------------------------------------------------------------------------
' Search the configuration descriptor chain looking for the interface
' Class/SubClass/Protocol "triad":
'       Mass storage class
'       SCSI transparent command set subclass
'       Bulk-only (BBB) transport protocol
'------------------------------------------------------------------------------
' On entry:
'   conf_base_addr - start address of the config descriptor chain.
'   conf_chain_len - total length of the config descriptor chain.
' On exit:
'   parse_result: set to value BBB_INTF_MATCH on success, otherwise zero.
'------------------------------------------------------------------------------
search_bbb_triad
                mov     ptrb, conf_base_addr
                rdbyte  dr4, ptrb[CON_bNumIntf]
                mov     sense_key, #TYPE_INTERFACE
.next_intf
                call    #search_desc_type
                cmp     ptrb, #0                wz
        if_z    ret                                     ' No interface match
                mov     parse_result, #0
                rdbyte  dr0, ptrb[INTF_bIntfClass]
                cmp     dr0, #CLASS_MASS_STORAGE wz     ' Only interested in mass storage class interface descriptors
        if_z    jmp     #.class_match
                djnz    dr4, #.next_intf
                ret
' Class is mass storage device
.class_match
                add     parse_result, #1                ' It's a mass storage class interface
                rdbyte  dr0, ptrb[INTF_bIntfNum]        ' Save this interface number
                wrbyte  dr0, ##bulk_io_intf_idx
                rdbyte  dr0, ptrb[INTF_bSubClass]       ' Look for bulk-only transport protcol
                cmp     dr0, #SUBCLASS_SCSI_CMD wz
        if_nz   jmp     #.next_intf
' Subclass is SCSI transparent command set
.subclass_match
                add     parse_result, #1                ' Uses the SCSI command set
                rdbyte  dr0, ptrb[INTF_bProtocol]       ' Protocol value must be non-zero
                cmp     dr0, #PROTO_BULK_ONLY  wz
        if_nz   jmp     #.next_intf
' Protocol is bulk-only transport, so we should find one IN and one OUT endpoint descriptor
.read_ep
                add     ptrb, next_desc
                rdbyte  next_desc, ptrb                 ' Save the offset to the next endpoint descriptor, if needed
                rdbyte  dr0, ptrb[ENDP_bmAttrs]         ' Sanity check that we're looking at a bulk endpoint
                cmp     dr0, #ENDP_ATTR_BULK    wz
        if_nz   jmp     #.next_intf
                rdbyte  dr1, ptrb[ENDP_bAddress]        ' Get bulk xfer address and max packet size to the right data members
                rdword  dr0, ptrb[ENDP_wMaxPktSize - 2] ' Get max size of IN/OUT packet
                mov     dr2, ctrl_ep_addr               ' Copy device address from the control ep/addr
                and     dr2, ##ADDR_MASK                ' Make sure only the device address remains
                testb   dr1, #BULKIO_DIRB       wc      ' Bit 7 of ENDP_bAddress set if it's an IN packet direction
        if_c    setbyte msd_status, dr1, #0             ' Stow Bulk IN endpoint address to use if an endpoint clear is required
        if_nc   setbyte msd_status, dr1, #1             ' Ditto for Bulk OUT
                shl     dr1, #8 + 7                     ' Shift endpoint address into position
                and     dr1, ##EP_MASK                  ' Make sure only the endpoint address remains
                or      dr1, dr2                        ' Add the device address and set appropriate IN/OUT ep_addr and PID
        if_nc   wrlong  dr0, ##dataout_max_pkt
        if_nc   or      dr1, #PID_OUT
        if_nc   wrlong  dr1, ##dataout_ep_addr
        if_c    wrlong  dr0, ##datain_max_pkt
        if_c    or      dr1, #PID_IN
        if_c    wrlong  dr1, ##datain_ep_addr
                add     parse_result, #1                ' We have a bulk-only IN or OUT endpoint
                cmp     parse_result, #BBB_INTF_MATCH wz
        if_z    setword msd_status, #0, #1              ' Reset device status bitflag area
        if_z    ret                                     ' All required interface elements found
                jmp     #.read_ep
' */
' /* search_desc_type
'------------------------------------------------------------------------------
' Search the configuration descriptor chain for a specific descriptor type.
'------------------------------------------------------------------------------
' On entry:
'   PTRB - on the first call to this routine PTRB must contain the address of
'     the first data member of the configuration descriptor.
'   sense_key - the descriptor type value for the search. If the sense_key
'     value is changed, it is up to the caller to ensure that PTRB contains the
'     proper configuration address for the new search.
' On exit:
'   PTRB - if a match is found the search descriptor start address, otherwise
'    zero.
'------------------------------------------------------------------------------
search_desc_type
                rdbyte  next_desc, ptrb
                add     ptrb, next_desc
                mov     dtmp, conf_base_addr
                subr    dtmp, ptrb
                cmp     dtmp, conf_chain_len    wcz
        if_ae   jmp     #.nomatch
                rdbyte  dtmp, ptrb[DESC_bDescType]
                cmp     dtmp, sense_key         wz
        if_z    ret
                jmp     #search_desc_type
.nomatch
                mov     ptrb, #0
                ret
' */
' /* dset_config
'------------------------------------------------------------------------------
' If a newly-connected device is recognized, do whatever is needed to configure
' it according to its function, or functions. In the case of this mass storage
' class driver: SetConfiguration(config_num).
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
dset_config
                mov     dtask, #DT_GET_CON_INPUT
                cmp     parse_result, #BBB_INTF_MATCH wz
        if_z    jmp     #.config
                loc     ptra, #@sz_bummer               ' Unknown device
                jmp     #dtx_nl_asciiz                  ' Don't bother to configure unknown device
.config
                loc     ptra, #@set_config
                mov     dtmp, #CON_bConfigVal           ' Get configuration value to set (always the default config in our case)
                add     dtmp, conf_base_addr
                rdbyte  dpar1, dtmp
                wrword  dpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
                mov     devent, #HCTRL_WRITE
                mov     dpar1, ctrl_ep_addr
                mov     dpar2, ptra                     ' SETUP struct addr
                mov     dpar3, #0                       ' SetConfiguration() has no data stage
                call    #post_hevent_sync               ' Post ControlWrite() event
                loc     ptra, #@sz_setcon_result
                call    #dtx_result_to_con
                cmp     dpar2, #PID_ACK         wz
        if_nz   ret                                     ' FIXME: should try to recover instead of punting to idle
                mov     dpar1, #0
                rdbyte  dpar2, ##bulk_io_intf_idx       ' Hub RAM address to receive max LUN
                call    #dreq_max_lun
                loc     ptra, #@sz_req_max_lun
                call    #dtx_result_to_con
                cmp     dpar2, #PID_ACK         wz
        if_nz   ret
                mov     dtask, #DT_BOMS_INQUIRY         ' Query device to see if it's compatible with our command set
                jmp     #dtx_newline
' */
' /* dexec_msd_reset
'------------------------------------------------------------------------------
'------------------------------------------------------------------------------
' On entry:
'   dpar1 - interface index for the target device.
'   dres_handler - the address of a routine that will handle the transfer
'     result returned by the host cog.
' On exit:
'------------------------------------------------------------------------------
{
dexec_boms_reset
                loc     ptra, #@req_boms_reset
                wrword  dpar1, ptra[wIndex]
                mov     devent, #HCTRL_WRITE
                mov     dpar1, ctrl_ep_addr
                mov     dpar2, ptra                     ' SETUP struct addr
                jmp     #post_hevent_sync               ' Post ControlWrite() event
}
' */
' /* dreq_max_lun
'------------------------------------------------------------------------------
' Request the maximum LUN number (zero-based) supported by the device.
'------------------------------------------------------------------------------
' On entry:
'   dpar1 - data to write to SETUP wValue.
'   dpar2 - interface index for the target device.
'   dres_handler - the address of a routine that will handle the transfer
'     result returned by the host cog.
' On exit:
'------------------------------------------------------------------------------
dreq_max_lun
                waitx   ##_1ms * 14
                loc     ptra, #@req_max_lun
                wrword  dpar1, ptra[wValue]
                wrword  dpar2, ptra[wIndex]
                mov     devent, #HCTRL_READ
                mov     dpar1, ctrl_ep_addr
                mov     dpar2, ptra                     ' SETUP struct addr
                mov     dpar3, ##msd_max_lun            ' IN payload target address
                jmp     #post_hevent_sync
' */
' /* dreq_dev_status
'------------------------------------------------------------------------------
' ControlRead() request to get endpoint status.
'------------------------------------------------------------------------------
' On entry:
'   dpar1 - the IN/OUT endpoint address to write to SETUP wIndex.
'   dres_handler - the address of a routine that will handle the transfer
'     result returned by the host cog.
' On exit:
'------------------------------------------------------------------------------
{
dreq_dev_status
                waitx   ##_1ms * 2
                loc     ptra, #@msd_dev_status
                wrword  dpar1, ptra[wIndex]
                mov     devent, #HCTRL_READ
                mov     dpar1, ctrl_ep_addr
                mov     dpar2, ptra
                mov     dpar3, ##urx_buff
                jmp     #post_hevent_sync
}
' */
' /* dreq_clear_endpoint
'------------------------------------------------------------------------------
' Execute a standard USB ClearFeature(Endpoint) command over the default pipe
' in reaction to a STALL received from a device. Note that if the host is
' accessing the msd via a hub, a ControlRead(GetPortStatus) request must be
' executed targeting the hub address prior to clearing the msd Bulk IN/OUT
' endpoint.
'------------------------------------------------------------------------------
' On entry:
'   bulkio_address - the address of the beginning of the current transfer's
'     IN/OUT parameter block.
'     msd_status - the bulk IN/OUT endpoint addresses that were gathered during
'       msd enumeration.
'     dres_handler - the address of a routine that will handle the transfer
'       result returned by the host cog.
' On exit:
'------------------------------------------------------------------------------
dreq_clear_endpoint
                cmp     cbw_flags, #BULK_DIR_IN
        if_z    getbyte dpar1, msd_status, #0           ' Target is Bulk-IN endpoint
        if_nz   getbyte dpar1, msd_status, #1           ' Target is Bulk-OUT endpoint
                loc     ptra, #@req_clear_endpoint
                wrword  dpar1, ptra[wIndex]
                wrword  #0, ptra[wLength]
                mov     dpar1, ctrl_ep_addr
                mov     dpar2, ptra                     ' SETUP struct addr
                mov     dpar3, #0                       ' No data stage
                mov     devent, #HCTRL_WRITE
                jmp     #post_hevent_sync               ' Post ControlWrite() event
' */
' /* inquiry
'------------------------------------------------------------------------------
' On entry:
'   cbw0 - EVPD bit state (%0000_0001 or %0000_0000).
'   cbw1 - Page code data to return
'   cbw_xfer_len - expected total size of the IN transfer.
' On exit:
'   PTRB - address of the opcode CB buffer.
'------------------------------------------------------------------------------
inquiry
                mov     scsi_cmd_id, #CMD_INQUIRY
                mov     cbw_flags, #BULK_DIR_IN
                mov     cbwcb_len, #INQUIRY_CBLEN
                mov     cbw_io_data_ptr, ##InquiryData
' Stage the command block to execute
                loc     ptrb, #@cb_inquiry
                ' SCSI opcode is defined in the CB buffer
                wrbyte  cbw0, ptrb[bmINQ_EVPD]
                wrbyte  cbw1, ptrb[bINQ_PageCode]
                mov     stmp, cbw_xfer_len              ' Transfer data length goes to USB as big endian
                movbyts stmp, #%%3201
                wrword  stmp, ##cb_inquiry + 3          ' FIXME
'                wrword  stmp, ptrb[##3]                 ' Max expected INQUIRY data bytes expected
                ' Control
' Execute the CBW transfer
                loc     pa, #@sz_inquiry
                call    #dexec_cbw
                mov     ptra, pa
                call    #dtx_result_to_con
                cmp     dpar2, #PID_ACK         wz
        if_z    cmp     csw_status, #CBS_CMD_PASSED wz
        if_nz   ret
' Pack the most interesting inquiry values into msd_status
                loc     ptra, #@InquiryData
                rdbyte  stmp, ptra[bmInq_PQ_PDT]        ' Peripheral Qualifier & Peripheral Type
                setbyte msd_status, stmp, #3
                rdbyte  stmp, ptra[bmInqVersion]        ' The SCSI version the device supports
                setbyte msd_status, stmp, #2
                rdbyte  stmp, ptra[bmInq_RMB]
                and     stmp, #INQ_RMB          wz
        if_nz   bith    dtxopts, #BOMS_REMOVABLEB       ' Set media removable flag
                ret
' */
' /* msd_inquery
'------------------------------------------------------------------------------
' Query the mass storage device's capabilities to see if it's compatible with
' our SCSI command set.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
boms_inquiry
                mov     dtask, #DT_GET_CON_INPUT
                mov     cbw0, #0                        ' For first INQUIRY, always use vanilla values
                mov     cbw1, #0
                mov     cbw_xfer_len, #STD_INQ_LEN
.query
                call    #inquiry
                cmp     csw_status, #CBS_CMD_PASSED wz
        if_nz   jmp     #mount_fail
' Output vendor ASCII fields
                loc     ptra, #@sz_vendor_id
                call    #dtx_nl_asciiz
                loc     ptrb, #@InquiryData
                add     ptrb, #bInqVendorID
                mov     drep, #INQ_VENDOR_ID_LEN
                call    #dtx_asciin
                loc     ptra, #@sz_product_rev
                call    #dtx_nl_asciiz
                add     ptrb, drep
                mov     drep, #INQ_PRODUCT_ID_LEN
                call    #dtx_asciin
                loc     ptra, #@sz_version_level
                call    #dtx_nl_asciiz
                add     ptrb, drep
                mov     drep, #INQ_VERSION_REV_LEN
                call    #dtx_asciin
                testb   dtxopts, #BOMS_REMOVABLEB wc
        if_c    loc     ptra, #@sz_removable
        if_nc   loc     ptra, #@sz_not_removable
                call    #dtx_nl_asciiz
                getbyte stmp, msd_status, #2
                cmp     stmp, #2                wcz
        if_be   loc     ptra, #@sz_not_spc
        if_a    loc     ptra, #@sz_is_spc
                call    #dtx_nl_asciiz
' If this driver ever wants to read media other than flash drives,
' READ FORMAT CAPACITIES may be needed.
{
.rfc
' Start by asking for just the current/maximum capacity descriptor
                mov     cbw_xfer_len, #RDFMTCAPS_DATA_MIN
                call    #read_format_capacities
                cmp     csw_status, #CBS_CMD_PASSED wz
        if_nz   jmp     #.exit
}
' Attempt to get the device capacity
.rc10
                mov     cbw_io_data_ptr, ##RdCapacity10
                call    #read_capacity10
                cmp     csw_status, #CBS_CMD_PASSED wz
        if_nz   jmp     #mount_fail
' Have highest logical block address and sector size, so look for a FAT file system
.exit
                loc     ptra, #@sz_srch_filesys
                call    #dtx_nl_asciiz
        _ret_   mov     dtask, #DT_SRCH_FILESYS
mount_fail
' BOMS device mount generic failure message
                loc     ptra, #@sz_msd_mount_fail
mount_fail_hdr
' Jump here when PTRA points to a more specific fail message
                mov     dtask, #DT_GET_CON_INPUT
                call    #dtx_nl_asciiz
                jmp     #reset_cmd_prompt
' */
' /* dsrch_fat_filesys
'------------------------------------------------------------------------------
' Read media sector starting at sector zero and look for a FAT16/32 file
' system. At this time the MBR partition table search stops at the first active
' FAT volume found. This code mostly follows Cluso99's SDCard FAT validation
' logic in the P2 monitor in ROM.
'------------------------------------------------------------------------------
' On entry:
'   dsec_size - the sector length returned by READ CAPACITY.
'   dhighest_lba - the highest LBA number returned by READ CAPACITY.
' On exit:
'   C = 0, Z = 1 on success.
'   C - 1, Z = 0 on error.
'------------------------------------------------------------------------------
dsrch_fat_filesys
                mov     cbw0, #0                        ' MBR is always at physical sector zero
                mov     cbw1, #1                        ' And always fits in a single sector
                mov     cbw_io_data_ptr, ##boms_sector_buff
                testb   dtxopts, #TX_VERBOSEB   wc
        if_nc   jmp     #.skip0
                loc     ptra, #@sz_mbr0
                call    #dtx_nl_asciiz
.skip0
                call    #read10
                cmp     csw_status, #CBS_CMD_PASSED wz
        if_nz   jmp     #mount_fail
' Read MBR parameters to determine if the volume has a FAT partition
' Note that all MBR typed data other than strings is little-endian
                mov     stmp, cbw_io_data_ptr
                add     stmp, #PTN_TBL_BASE
                mov     didx, #4                        ' Four potential 16-byte partition entries to scan
' Scan the physical sector zero partition table for a FAT file system
.ptn_entry
                mov     dr4, stmp                       ' Save the base address of the this partition entry
                rdbyte  dtmp, stmp                      ' Inactive/active byte is at offset zero of the entry
                and     dtmp, #$7f              wz      ' $80 or $00 are the only valid values
        if_nz   jmp     #.next_ptn
                add     stmp, #bPtnType
                rdbyte  dtmp, stmp
                cmp     dtmp, #F16_32MB_2GB     wz
        if_nz   cmp     dtmp, #F32_512MB_2TB    wz
        if_nz   cmp     dtmp, #F32_LBA_LE2TB    wz
        if_nz   cmp     dtmp, #F16_LBA_32MB_2GB wz
        if_nz   jmp     #.next_ptn
                mov     dptn_type, dtmp                 ' Save recognized partition type
                add     stmp, #lPtnBaseSector - bPtnType
                rdlong  dvol_base, stmp                 ' Sector# of the partition's first sector
                add     stmp, #lPtnTotalSectors - lPtnBaseSector
                rdlong  dptn_secs, stmp                 ' Total number of sectors in the partition
                mov     stmp, cbw_io_data_ptr
                add     stmp, #PTN_TBL_BASE + wMBRSignature0
                rdword  dtmp, stmp
                cmp     dtmp, ##MBR_55_AA       wz      ' Correct MBR signature?
        if_z    jmp     #.verify_volume                 ' FAT partition found
.next_ptn
                cmp     dtmp, #0                wz      ' Empty partition entry?
        if_z    jmp     #.no_ptn
                loc     ptra, #@sz_unknown_partition
                call    #dtx_nl_asciiz
                mov     dtx, dtmp
                call    #dtx_hexbyte
.no_ptn
                mov     stmp, dr4                       ' Restore partition entry base address
                add     stmp, #PTN_ENTRY_LEN            ' Bump to next entry
                djnz    didx, #.ptn_entry
                loc     ptra, #@sz_no_fat_ptn
                jmp     #mount_fail_hdr
.verify_volume
' Read the volume's BPB data using its physical sector#
                mov     cbw0, dvol_base
              ' cbw1 still has correct sector count
              ' and we're using the same data buffer for the read
                testb   dtxopts, #TX_VERBOSEB   wc
        if_nc   jmp     #.skip1
                loc     ptra, #@sz_ptn_bpb
                call    #dtx_nl_asciiz
.skip1
                call    #read10
                cmp     csw_status, #CBS_CMD_PASSED wz
        if_nz   jmp     #mount_fail
' All BPB FAT region sector numbers are defined as offsets from the volume's
' physical sector number, which now has become "LBA zero".
                mov     dfat_base, dvol_base
                mov     stmp, cbw_io_data_ptr
                add     stmp, #wBPB_BytsPerSec
                rdword  dtmp, stmp
                cmp     dsec_size, dtmp         wz      ' We already have bytes per sector reported by the device
        if_nz   jmp     #mount_fail                     ' so the volume's BPB value had better be the same...
                add     stmp, #bBPB_SecPerClus - wBPB_BytsPerSec
                rdbyte  dclus_shft, stmp        wz      ' Sectors per cluster must be a power of two, i.e. 1, 2, 4...
                encod   dclus_shft                      ' Use as shift value for efficient multiply/divide calcs
                mov     dclus_size, dsec_size
                shl     dclus_size, dclus_shft          ' For a FAT volume, cluster size > 32K is a no-no
                cmp     dclus_size, ##MAX_CLUSTER_SIZE wcz
        if_a    jmp     #mount_fail
                add     stmp, #wBPB_RsvdSecCnt - bBPB_SecPerClus
                rdword  drsvd_sec_cnt, stmp             ' We'll need the reserved sector count in several calculations
                add     dfat_base, drsvd_sec_cnt        ' LBA sector# of the FAT
                add     stmp, #bBPB_NumFATs - wBPB_RsvdSecCnt
                rdword  dnum_fats, stmp         wcz     ' Number of FATs (must be at least one)
        if_z    jmp     #mount_fail
                cmp     dnum_fats, #2           wcz     ' Technically more than one FAT copy is possible
        if_a    jmp     #mount_fail                     ' But for now fail if more than one copy is defined
' Sort the relevant fields if FAT16 or FAT32
                add     stmp, #wBPB_RootEntCnt - bBPB_NumFATs
                rdword  df16_dir_secs, stmp             ' Max directory entries if FAT16, zero if FAT32
' Calculate the count of sectors occupied by the root directory, if FAT16
                shl     df16_dir_secs, #5               ' #entries x 32 (size of one FAT directory entry, in bytes)
                mov     dtmp, dsec_size                 ' Add a short sector length to ensure
                sub     dtmp, #1                        ' that the sector count will round up
                add     df16_dir_secs, dtmp
                shr     df16_dir_secs, dsec_shft        ' And we end up with a FAT16 rootdir size or zero if FAT32
                add     stmp, #wBPB_TotSec16 - wBPB_RootEntCnt
                rdword  dvol_secs, stmp         wz      ' If zero we set dvol_secs to the 32-bit sector count later
                add     stmp, #wBPB_FATSz16 - wBPB_TotSec16
                rdword  dfat_size, stmp                 ' Sector count for ONE 16-bit FAT, if zero set 32-bit FAT size later
                encod   dfat_ofst_shft, #2              ' Use to calculate FAT16 data region cluster numbers
                add     stmp, #lBPB_TotSec32 - wBPB_FATSz16
        if_z    rdlong  dvol_secs, stmp                 ' Read 32-bit total sector count if 16-bit read was zero
                cmp     dfat_size, #0           wz
        if_z    jmp     #.isFAT32                       ' If dfat_size is zero we're looking at a 32-bit FAT size
.isFAT16
                add     stmp, #bBS16_BootSig - lBPB_TotSec32
                rdbyte  dtmp, stmp
                cmp     dtmp, #EXT_BOOT_SIG     wz
        if_nz   add     stmp, #wMBRSignature1 - bBS16_BootSig
        if_nz   jmp     #.chk_last_sig
' Cache the volume ID and label that are recorded in the volume boot sector
                add     stmp, #lBS16_VolID - bBS16_BootSig
                rdlong  dtmp, stmp
                wrlong  dtmp, ##vol_serial_num
                add     stmp, #nBS16_VolLab11 - lBS16_VolID
                mov     ptra, stmp
                loc     ptrb, #@sz_vol_label
                mov     lmm_c, #SHORTNAME_SIZE
                call    #dstrncpy
                add     stmp, #wMBRSignature1 - nBS16_VolLab11
                jmp     #.chk_last_sig
.isFAT32
                add     stmp, #lBPB_FATSz32 - lBPB_TotSec32
                rdlong  dfat_size, stmp                 ' Sector count for ONE 32-bit FAT
                encod   dfat_ofst_shft, #4              ' Use to calculate FAT32 data region cluster numbers
                add     stmp, #lBPB_RootClus - lBPB_FATSz32
                rdlong  drootdir_clus, stmp             ' Get the cluster# of the root directory, which should be
                mov     cbw0, drootdir_clus             ' two for the best compatibility, but it doesn't have to be
                call    #dget_data_clus_sec
                mov     drootdir_base, cbw0             ' Convert it to a sector LBA
                add     stmp, #wBPB_FSInfo - LBPB_RootClus
                rdword  dfsinfo_base, stmp              ' Read sector# for the FAT32 FSINFO structure
                add     dfsinfo_base, dvol_base         ' and calculate the FSInfo base LBA
                add     stmp, #bBS32_BootSig - wBPB_FSInfo
                rdbyte  dtmp, stmp
                cmp     dtmp, #EXT_BOOT_SIG     wz
        if_nz   add     stmp, #wMBRSignature1 - bBS32_BootSig
        if_nz   jmp     #.chk_last_sig
' Cache the volume ID and label that are recorded in the volume boot sector
                add     stmp, #lBS32_VolID - bBS32_BootSig
                rdlong  dtmp, stmp
                wrlong  dtmp, ##vol_serial_num
                add     stmp, #nBS32_VolLab11 - lBS32_VolID
                mov     ptra, stmp
                loc     ptrb, #@sz_vol_label
                mov     lmm_c, #SHORTNAME_SIZE
                call    #dstrncpy
                add     stmp, #wMBRSignature1 - nBS32_VolLab11
.chk_last_sig
                rdword  dtmp, stmp                      ' Last signature check...
                cmp     dtmp, ##MBR_55_AA       wz
        if_nz   jmp     #mount_fail
' Calc physical sector numbers for the root directory and the file/dir data region
                mov     fpar1, dnum_fats                ' Will need sector count for the FAT
                mul     fpar1, dfat_size                ' and its copy later
                add     drootdir_base, fpar1            ' FAT16 has a dedicated root directory region, but the FAT32
                mov     dfile_dir_base, fpar1           ' root is usually the first cluster of the file/dir data region
                add     drootdir_base, dfat_base        ' Physical sector# of the root directory
                add     dfile_dir_base, dfat_base
                add     dfile_dir_base, df16_dir_secs   ' Physical sector# of the file/dir data region
                cmp     df16_dir_secs, #0       wz
        if_nz   jmp     #.read_root                     ' FAT16 has no FSInfo structure
.read_fsinfo
' FAT32, so validate the FSInfo structure
                mov     cbw0, dfsinfo_base              ' FSInfo structure sector#
              ' cbw1 still has correct sector count
                mov     cbw_io_data_ptr, ##boms_fsinfo_buff
                testb   dtxopts, #TX_VERBOSEB   wc
        if_nc   jmp     #.skip2
                loc     ptra, #@sz_fsinfo
                call    #dtx_nl_asciiz
.skip2
                call    #read10
                cmp     csw_status, #CBS_CMD_PASSED wz
        if_nz   jmp     #mount_fail
                mov     stmp, cbw_io_data_ptr
                rdlong  dtmp, stmp
                cmp     dtmp, ##FSI_LEAD_SIG    wz
                add     stmp, #lFSI_StrucSig
                rdlong  dtmp, stmp
        if_z    cmp     dtmp, ##FSI_STRUC_SIG   wz
        if_nz   jmp     #mount_fail                     ' ID of FSInfo structure failed
                add     stmp, #lFSI_FreeCount - lFSI_StrucSig
                rdlong  dfsi_free_clus, stmp
                add     stmp, #lFSI_NxtFree - lFSI_FreeCount
                rdlong  dfsi_clus_hint, stmp
                add     stmp, #lFSI_TrailSig - lFSI_NxtFree
                rdlong  dtmp, stmp
                cmp     dtmp, ##FSI_TRAIL_SIG   wz
        if_nz   jmp     #mount_fail
.read_root
                mov     cbw0, #0                        ' Cluster# zero implies the root directory
                call    #dopen_dir                      ' Cache the root directory
        if_z    jmp     #mount_fail                     ' Z = (dirent_cnt == 0)
' Cache the volume label that's in the root directory if there is one
                loc     ptra, #@sz_dir_match_all
                loc     ptrb, #@match_pattern_buff
                call    #dstrcpy
                mov     dpar1, #DIR_VOL_LABELF
                call    #ddir_find_first
                mov     ptra, ptrb
                mov     lmm_c, #SHORTNAME_SIZE
                loc     ptrb, #@sz_vol_label
                cmp     dret1, #DIR_VOL_LABELB  wz
        if_z    call    #dstrncpy
' FAT type can always be identified by the count of clusters in the data region
' FirstDataSec = RsvdSecCnt + (FATSz * NumFATs) + RootDirSecs
' DataSecs = TotalSecs - FirstDataSec - (volume start physical sector#)
' CountOfClusters = DataSecs / BPB_SecPerClus
                mov     fpar2, dfile_dir_base           ' dvol_base + (RsvdSecCnt + (FATSz * NumFATs) + RootDirSecs)
                sub     fpar2, dvol_base
                subr    fpar2, dvol_secs                ' DataSecs = dvol_secs - (RsvdSecCnt + (FATSz * NumFATs) + RootDirSecs)
                mov     ddat_clus_cnt, fpar2
                shr     ddat_clus_cnt, dclus_shft       ' Total data clusters available
' DEBUG: show the significant FATx parameters...
                call    #dtx_newline
                loc     ptra, #@sz_ptn_type
                call    #dtx_nl_asciiz
                mov     dtx, dptn_type
                call    #dtx_hexbyte
                loc     ptra, #@sz_clus_size
                mov     dtx, dclus_size
                call    #dtx_nl_hdr_decimal             ' Cluster size
                loc     ptra, #@sz_vol_base
                mov     dtx, dvol_base
                call    #dtx_nl_hdr_decimal             ' Volume base sector#
                loc     ptra, #@sz_rsvd_sec_cnt
                mov     dtx, drsvd_sec_cnt
                call    #dtx_nl_hdr_decimal             ' Count of reserved sectors
                cmp     dfsinfo_base, #0        wz
        if_z    jmp     #.fat                           ' Skip FSInfo if FAT16
                loc     ptra, #@sz_fsinfo_base
                mov     dtx, dfsinfo_base
                call    #dtx_nl_hdr_decimal             ' FAT FSInfo region physical base sector#
.fat
                loc     ptra, #@sz_fat_base
                mov     dtx, dfat_base
                call    #dtx_nl_hdr_decimal             ' FAT region physical base sector#
                loc     ptra, #@sz_fat_size
                mov     dtx, dfat_size
                call    #dtx_nl_hdr_decimal             ' Size in sectors of ONE FAT
                loc     ptra, #@sz_fat_sec_cnt
                mov     dtx, fpar1
                call    #dtx_nl_hdr_decimal             ' Count of sectors of the FAT region
                loc     ptra, #@sz_root_dir_base
                mov     dtx, drootdir_base
                call    #dtx_nl_hdr_decimal             ' Root directory base physical sector# (FAT16/FAT32)
                cmp     df16_dir_secs, #0       wz
        if_nz   loc     ptra, #@sz_root_dir_sec_cnt
        if_nz   mov     dtx, df16_dir_secs              ' Count of sectors of the root directory (FAT16 only)
        if_z    loc     ptra, #@sz_root_clus_num
        if_z    mov     dtx, drootdir_clus              ' FAT32 root directory cluster#
                call    #dtx_nl_hdr_decimal
                loc     ptra, #@sz_dfd_base
                mov     dtx, dfile_dir_base
                call    #dtx_nl_hdr_decimal             ' Dir/file/data region physical base sector# (FAT16/FAT32)
                loc     ptra, #@sz_dfd_clus
                mov     dtx, ddat_clus_cnt
                call    #dtx_nl_hdr_decimal             ' Count of data region clusters
' We have enough parameters collected to assume it's a valid FAT file system.
' If it looks like it's FAT16, we need to scan the FAT region to calculate the
' free sector count. If it's FAT32, we have already read the fsinfo structure
' and have a free sector count. An entry value of $ffffffff indicates the free
' sector count is unknown, so we will calculate it and update FSInfo here. Any
' other value may or may not be an accurate free sector count. Since scanning
' a 32-bit FAT region can take a significant amount of time, go with the value
' that exists, for now. The user can execute the "SCANFAT" command at any time
' to scan the FAT region and update the FSInfo sector.
                cmp     df16_dir_secs, #0       wz
        if_nz   jmp     #.scan                          ' FAT16 doesn't persist a free cluster count, so always scan
                mov     ftmp, #0
                cmp     dfsi_free_clus, ddat_clus_cnt wcz ' Check that the free cluster count is <= total data sectors
        if_be   jmp     #.chk_hint
                loc     ptra, #@sz_force_fatscan
                call    #dtx_nl_asciiz
                mov     dfsi_free_clus, #0              ' Invalid/unknown free count, so clear the slate
.scan
                call    #dscan_fat
        if_nz   jmp     #mount_fail
                cmp     df16_dir_secs, #0       wz
        if_nz   jmp     #.report                        ' TODO: should persist this somewhere on the media?
                add     ftmp, #1
.chk_hint
                cmp     dfsi_clus_hint, ddat_clus_cnt wcz ' Check that the next free cluster hint is <= total data sectors
        if_be   jmp     #.update_test
                mov     dfsi_clus_hint, #2                ' Reset next free cluster hint to start of FAT region
                add     ftmp, #1
.update_test
                cmp     ftmp, #0                wz
        if_z    jmp     #.report                        ' FSInfo data is within expected limits, so don't need to update
                call    #dupdate_fsinfo
        if_z    loc     ptra, #@sz_fsinfo_updated
                call    #dtx_nl_asciiz
.report
                loc     ptra, #@sz_free_clus
                mov     dtx, dfsi_free_clus
                call    #dtx_nl_hdr_decimal             ' Count of clusters marked as free
                cmp     df16_dir_secs, #0       wz
        if_nz   jmp     #.nofsinfo
                loc     ptra, #@sz_fsi_nxt_free
                mov     dtx, dfsi_clus_hint
                call    #dtx_nl_hdr_decimal             ' FSInfo next free cluster# hint
.nofsinfo
                loc     ptra, #@sz_dfd_secs
                mov     dtx, fpar2
                call    #dtx_nl_hdr_decimal             ' Count of data region sectors
                loc     ptra, #@sz_vol_secs
                mov     dtx, dvol_secs
                call    #dtx_nl_hdr_decimal             ' Count of volume sectors
' The sector count of all regions should be <= the total volume sectors:
                mov     stmp, dfile_dir_base            ' Data region base physical sector#
                add     stmp, fpar2                     ' + data region sectors
                sub     stmp, dvol_base                 ' Establish LBA zero for the volume
                subs    stmp, dvol_secs                 ' And we see what the cat spits up...
                cmps    stmp, dvol_secs         wcz
        if_a    loc     ptra, #@sz_vol_overrun          ' Output if region sector sum exceeds volume sectors
        if_a    mov     dtx, stmp
        if_a    call    #dtx_nl_hdr_decimals
                cmp     fpar2, ##FAT12_MAGIC    wcz
        if_b    jmp     #mount_fail                     ' No support for FAT12
                cmp     ddat_clus_cnt, ##FAT16_MAGIC wcz
        if_b    loc     ptra, #@sz_vol_fat16            ' Volume is FAT16
        if_ae   loc     ptra, #@sz_vol_fat32            ' Volume is FAT32
                call    #dtx_nl_asciiz                  ' Last is the FAT type mounted announcement
' Set the current path to the volume root directory
                wrbyte  #"A", ##sz_cur_path
                mov     dtask, #DT_GET_CON_INPUT        ' Task loop to wait for terminal command input
                jmp     #reset_cmd_prompt               ' Reset the command line prompt and start the new task
' */
' /* dscan_fat
'------------------------------------------------------------------------------
' Scan the entire FAT region to count free clusters.
'------------------------------------------------------------------------------
' On entry:
'   dfsi_free_clus - free cluster count (maintained by the file system).
' On exit:
'   dfsi_free_clus - count of FAT cluster entries marked as free.
'   fret1 - calculated count of free clusters prior to the FAT scan.
'   didx, fret2, fret3 - trashed.
'   C = 0, Z = 1 if no error.
'   C = 1, Z = 0 on error.
'------------------------------------------------------------------------------
dscan_fat
                mov     cbw0, dfat_base
                mov     cbw1, #1                        ' Read the FAT one sector a time
                mov     cbw_io_data_ptr, ##boms_sector_buff
                mov     fret1, dfsi_free_clus
                mov     dfsi_free_clus, #0
                mov     didx, #0
                mov     fret2, dfat_size                ' Read the first FAT only
                mov     fret3, ddat_clus_cnt
                add     fret3, #2                       ' Include the 2 reserved clusters in the count
.secloop
                call    #dget_sectors
        if_z    jmp     #.scan
                jmp     #scsi_fail
.scan
                loc     ptra, #boms_sector_buff         ' Scan the entire sector
                mov     drd_bytes, #0
.chk_entry
                cmp     df16_dir_secs, #0       wz      ' FAT16 or FAT32?
        if_nz   rdword  drx, ptra++
        if_nz   add     drd_bytes, #2                   ' FAT16
        if_z    rdlong  drx, ptra++
        if_z    and     drx, ##FAT32_EOC_SET            ' Ignore the reserved high nibble when FAT32
        if_z    add     drd_bytes, #4
                cmp     drx, #0                 wz
        if_z    add     dfsi_free_clus, #1
                djz     fret3, #.exit                   ' Break if we see highest cluster# prior to end-of-sector
                cmp     drd_bytes, dsec_size    wcz     ' Check for end-of-sector
        if_b    jmp     #.chk_entry
                waitx   ##_1us * 100
                incmod  didx, dsec_size         wc
        if_c    mov     dtx, #"."
        if_c    call    #dtx_char
                add     cbw0, #1                        ' Next sector
                djnz    fret2, #.secloop
.exit
        _ret_   modcz   _clr, _set              wcz
' */
' /* dupdate_fsinfo
'------------------------------------------------------------------------------
' Write FAT32 FSInfo structure changes to the medium. The free sector count and
' next free cluster hint structure members are the only members that get
' updated. The remaining FSInfo sector data space is reserved for future use.
'------------------------------------------------------------------------------
' On entry:
'   dfsi_free_clus, dfsi_clus_hint - maintained by the file system.
' On exit:
'   C = 0, Z = 1 if no error.
'   C = 1, Z = 0 on error.
'------------------------------------------------------------------------------
dupdate_fsinfo
                mov     cbw_io_data_ptr, ##boms_fsinfo_buff
                mov     ftmp, cbw_io_data_ptr
                add     ftmp, #lFSI_FreeCount
                wrlong  dfsi_free_clus, ftmp            ' The free cluster count and next free cluster
                add     ftmp, #lFSI_NxtFree - lFSI_FreeCount
                wrlong  dfsi_clus_hint, ftmp            ' hint members are the only ones maintained
                mov     cbw0, dfsinfo_base              ' FSInfo structure sector#
                mov     cbw1, #1                        ' Only one sector to write
                jmp     #dput_sectors                   ' Write the change to media
' */
' /* dget_clus_entry_sec
'------------------------------------------------------------------------------
' Compute the FAT region sector# that contains the cluster N chain entry.
'------------------------------------------------------------------------------
' On entry:
'   cbw0 - the cluster# for the entry.
' On exit:
'   dclus_offset - the FAT region offset of the entry, in bytes.
'   cbw0 - the FAT region sector# that contains the cluster entry.
'------------------------------------------------------------------------------
dget_clus_entry_sec
                mov     dclus_offset, cbw0
                shl     dclus_offset, dfat_ofst_shft    ' FATOffset = N * 2 if FAT16, N * 4 if FAT32
                mov     cbw0, dclus_offset
                shr     cbw0, dsec_shft                 ' SectNum = FATOffset / SectBytes
                add     cbw0, dfat_base                 ' Sector# is relative to sector 0 of the FAT region
' Modulo of powers of two (thanks, Wikipedia!)
                mov     lmm_x, dsec_size                ' N mod 2^x == N & (2^x - 1)
                sub     lmm_x, #1
        _ret_   and     dclus_offset, lmm_x             ' FAT entry offset is the remainder
' */
' /* dget_data_clus_sec
'------------------------------------------------------------------------------
' Compute the data region sector# that contains cluster N.
'------------------------------------------------------------------------------
' On entry:
'   cbw0 - the data cluster number to locate.
' On exit:
'   cbw0 - the data region sector# that contains cluster N.
'------------------------------------------------------------------------------
dget_data_clus_sec
' FirstSecOfCluster = ((N - 2) * SecPerClus) + FirstDataSector
                sub     cbw0, #2
                shl     cbw0, dclus_shft
        _ret_   add     cbw0, dfile_dir_base
' */
' /* dget_cluster, dget_sectors
'------------------------------------------------------------------------------
' Read one cluster or N sectors.
'------------------------------------------------------------------------------
' On entry:
'   cbw_io_data_ptr - data buffer address for the read. It is the caller's
'     responsibility to ensure the buffer is properly sized.
'   cbw0 - start sector# for the read.
'   cbw1 - count of sectors to read (dget_sectors only).
' On exit:
'   cbw1 - unchanged (dget_sectors only).
'   C = 0, Z = 1 if no error.
'   C = 1, Z = 0 on error.
'------------------------------------------------------------------------------
dget_cluster
                mov     cbw1, #1
                shl     cbw1, dclus_shft
dget_sectors
                mov     dr4, dtxopts                    ' Suppress all debug output
                and     dr4, #TX_VERBOSEF
                bitl    dtxopts, #TX_VERBOSEB
                call    #read10
                or      dtxopts, dr4
                cmp     csw_status, #CBS_CMD_PASSED wz
        if_nz   jmp     #scsi_fail
        _ret_   modcz   _clr, _set              wcz
' */
' /* dput_cluster, dput_sectors
'------------------------------------------------------------------------------
' Write one cluster or N sectors.
'------------------------------------------------------------------------------
' On entry:
'   cbw_io_data_ptr - data buffer address for the write. It is the caller's
'     responsibility to ensure the buffer is properly sized.
'   cbw0 - start sector# for the write.
'   cbw1 - count of sectors to write (dput_sectors only).
' On exit:
'   C = 0, Z = 1 if no error.
'   C = 1, Z = 0 on error.
'------------------------------------------------------------------------------
dput_cluster
                mov     cbw1, #1
                shl     cbw1, dclus_shft
dput_sectors
                mov     dr4, dtxopts                    ' Suppress all debug output
                and     dr4, #TX_VERBOSEF
                bitl    dtxopts, #TX_VERBOSEB
                call    #write10
                or      dtxopts, dr4
                cmp     csw_status, #CBS_CMD_PASSED wz
        if_nz   jmp     #scsi_fail
        _ret_   modcz   _clr, _set              wcz
' */
' /* dopen_dir
'------------------------------------------------------------------------------
' Read as much of a directory cluster chain that fits into the buffer.
'------------------------------------------------------------------------------
' On entry:
'   cbw0 - start cluster number of the directory. A cluster number of zero
'     implies the start of the root directory.
' On exit:
'   dirent_cnt - the number of directory entry structures read into the buffer, 
'     zero if an error occured.
'   dir_next_clus - next directory cluster#, or #FILE_EOF if no more clusters.
'   Z = (dirent_cnt == 0).
'------------------------------------------------------------------------------
dopen_dir
                mov     dirent_cnt, ##DIR_BUFF_LEN
                shr     dirent_cnt, dsec_shft           ' See how many sectors the buffer will hold
                mov     dirent_ptr, ##boms_dir_buff
                cmp     cbw0, #0                wz      ' Root?
        if_nz   mov     dis_rootdir, #0
        if_nz   jmp     #.open
                mov     dis_rootdir, #1
                cmp     df16_dir_secs, #0       wz      ' FAT32?
        if_z    mov     cbw0, drootdir_clus
        if_z    jmp     #.open
' FAT16 root directory has its own region and is a fixed size
                mov     cbw0, drootdir_base
                mov     cbw1, df16_dir_secs             ' Usually 32 sectors, but doesn't have to be
                fle     cbw1, dirent_cnt        wc
        if_nc   mov     dirent_cnt, cbw1                ' Ensure it doesn't exceed the buffer size
                mov     cbw_io_data_ptr, dirent_ptr
                call    #dget_sectors                   ' Cache the root directory
        if_z    shl     dirent_cnt, dsec_shft           ' Convert sectors to bytes
        if_nz   mov     dirent_cnt, #0
                jmp     #.calc_entries
.open
                mov     didx, dirent_cnt                ' Calc the number of clusters the buffer will hold
                shr     didx, dclus_shft
                mov     dir_next_clus, ##FILE_EOF
                mov     dirent_cnt, #0
.loop
                mov     datpar1, cbw0                   ' datpar1 is input register for dget_next_clus_num
                call    #dget_data_clus_sec
                cmp     didx, #0                wz
        if_z    mov     dcur_dir_sec, cbw0
                mov     cbw_io_data_ptr, dirent_ptr
                call    #dget_cluster
        if_nz   jmp     #.calc_entries
                add     dirent_cnt, dclus_size
                call    #dget_next_clus_num
                mov     dir_next_clus, datret1
                cmp     dir_next_clus, ##FILE_EOF wz
        if_z    jmp     #.calc_entries                  ' FILE_EOF or error
                add     dirent_ptr, dclus_size
                mov     cbw0, dir_next_clus
                djnz    didx, #.loop                    ' Continue if room left in the buffer
.calc_entries
         _ret_  shr     dirent_cnt, #5          wz      ' Convert bytes read into count of directory entries
' */
' /* dget_data_clus, dget_next_data_clus
'------------------------------------------------------------------------------
' Read a data cluster from the media, if not aready cached.
'------------------------------------------------------------------------------
' On entry:
'   datpar1 - the first cluster# to read (dget_first_data_clus only).
' On exit:
'   datpar1 - cluster# read, or FILE_EOF if at the end of the cluster chain.
'------------------------------------------------------------------------------
dget_next_data_clus
                cmp     next_data_clus, ##FILE_EOF wz
        if_z    ret
                mov     datpar1, next_data_clus
dget_first_data_clus
                mov     cbw0, datpar1                   ' See if we have the requested cluster cached
                call    #dget_data_clus_sec
                cmp     dcur_data_sec, cbw0     wz
        if_z    ret
' Need to read the cluster from the media
                mov     dcur_data_sec, cbw0
                call    #dget_next_clus_num             ' Pre-fetch the next cluster# in the chain, if any
                mov     next_data_clus, datret1
                mov     cbw0, dcur_data_sec
                mov     cbw_io_data_ptr, ##boms_cluster_buff
                call    #dget_cluster                   ' Read the cluster from the media
        if_z    mov     dcur_data_sec, #0               ' Sector# is invalid
        if_z    ret
clus_chain_end
        _ret_   mov     datpar1, ##FILE_EOF
' */
' /* dget_next_clus_num
'------------------------------------------------------------------------------
' Read a cluster# entry in the FAT region to see if there are more clusters in
' the chain.
'------------------------------------------------------------------------------
' On entry:
'   datpar1 - cluster# of the entry to read.
' On exit:
'   datret1 - one of: next cluster# or FILE_EOF.
'------------------------------------------------------------------------------
dget_next_clus_num
                mov     datret1, ##FILE_EOF
                mov     cbw0, datpar1
                call    #dget_clus_entry_sec
                cmp     dcur_fat_sec, cbw0      wz
        if_z    jmp     #.get_entval
                mov     cbw_io_data_ptr, ##boms_fat_buff
                mov     cbw1, #1
                call    #dget_sectors
        if_nz   ret                                     ' FIXME: needs a real error code
.get_entval
                loc     pa, #@boms_fat_buff
                add     pa, dclus_offset
                cmp     df16_dir_secs, #0       wz
        if_z    rdlong  datret1, pa                     ' FAT32?
        if_z    and     datret1, ##FAT32_EOC_SET        ' FAT32 cluster entries are 28-bits and must ignore the high nibble
        if_z    jmp     #.chk_eoc
                rdword  datret1, pa                     ' FAT16?
                cmp     datret1, ##FAT16_BAD_CLUS wcz
        if_ae   setword datret1, ##$0fff, #1            ' If not a cluster# covert to 32-bit FAT_BAD_CLUS or FILE_EOF
.chk_eoc
                cmp     datret1, ##FAT_BAD_CLUS wcz
        if_ae   mov     datret1, ##FILE_EOF
                ret
' */
' /* dfopen
'------------------------------------------------------------------------------
' Opens a file. Currently limited to read only.
'------------------------------------------------------------------------------
' On entry:
'   PTRB - points to the directory entry of the file to open.
'   dcur_dir_entry - directory entry number of the file to open.
' On exit:
'------------------------------------------------------------------------------
dfopen
                ret
' */

' /* scsi_fail
'------------------------------------------------------------------------------
' Standard method to convey a SCSI command FAIL status to high-level callers.
' The caller just needs to read C and/or Z state after the CALL.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   C = 1, Z = 0 on error.
'------------------------------------------------------------------------------
scsi_fail
        _ret_   modcz   _set, _clr              wcz
' */
' /* dget_match_pattern
'------------------------------------------------------------------------------
' Take an 8.3 formatted name and construct a file/directory name search pattern.
' The name may include the dot separator and/or the "*" and "?" wildcard
' characters.
'------------------------------------------------------------------------------
' On Entry:
'   PTRA - points to an 8.3 format string.
' On Exit:
'   Hub address match_pattern_buff contains the name pattern string to use for
'     the directory search.
'   PTRA - unchanged.
'   C = 0, Z = 1 if successfully converted into an 8.3 search pattern.
'   C = 1, Z = 0 on error.
'------------------------------------------------------------------------------
dget_match_pattern
' Handle static patterns first.
                mov     pa, ptra
                call    #dstrlenr
                cmp     lmm_c, #SHORTNAME_SIZE + 1 wcz  ' Limited to 8.3 format for now
        if_b    jmp     #.start
        if_a    jmp     #.fail
                mov     lmm_c, #"."                     ' Input = 8.3, so if no dot found, it's too long
                call    #dstrchr                        ' Z = (PTRA == 0)
        if_z    jmp     #.fail                          ' No dot
                mov     ptra, pa
' Process "*" and "?" wildcards, if any.
.start
                loc     pb, #@match_pattern_buff        ' PB will stay anchored at start address
                mov     lmm_p, pb
                mov     lmm_x, #" "
                mov     lmm_c, #SHORTNAME_SIZE + 1
                call    #dmemset                        ' Initialize the pattern buffer
                mov     ptrb, pb
                mov     didx, pb
                add     didx, #11                       ' Fix the index at the end of the 11-byte field
.getchar
                rdbyte  dtx, ptra++             wz
        if_z    modcz   _clr, _set              wcz     ' Valid pattern processed
        if_z    ret
.dot
                cmp     dtx, #"."               wz
        if_nz   jmp     #.asterisk
                mov     ptrb, pb
                add     ptrb, #8                        ' Move to first byte of extension field
                mov     lmm_p, ptrb
                mov     lmm_c, #3                       ' Fill with spaces
                call    #dmemset                        ' but keep ptrb at start of extension field
                jmp     #.getchar                       ' and read next source character, if any
.asterisk
                cmp     dtx, #"*"               wz
        if_nz   jmp     #.chkptr
                mov     dtmp, ptrb
                sub     dtmp, pb
                subr    dtmp, #11               wz
        if_z    jmp     #.getchar                       ' ptrb is already at the end of the pattern
                mov     lmm_p, ptrb
                mov     lmm_x, #"?"
                mov     lmm_c, dtmp
                call    #dmemset                        ' Fill rest of pattern with "?"
                mov     ptrb, didx
                jmp     #.getchar
.chkptr
                cmp     ptrb, didx              wcz
        if_b    wrbyte  dtx, ptrb++
                jmp     #.getchar
.fail
        _ret_   modcz   _set, _clr              wcz     ' Unable to construct a valid search pattern
' */
' /* ddirname_compare
'------------------------------------------------------------------------------
' Compare a directory entry shortname to a name match pattern.
'------------------------------------------------------------------------------
' On entry:
'   PTRB - address of a directory entry shortname field.
' On exit:
'   PTRB - unchanged.
'   lmm_c - count of name characters matched.
'   C, Z = (CMP lmm_c, #SHORTNAME_SIZE).
'------------------------------------------------------------------------------
ddirname_compare
                mov     lmm_p, ptra                     ' Preserve registers
                mov     lmm_p2, ptrb
                mov     lmm_c, #0
                loc     ptra, #@match_pattern_buff
'                rep     @.exit, #SHORTNAME_SIZE
                rep     #7, #SHORTNAME_SIZE
                rdbyte  drx, ptra++             wz
        if_nz   rdbyte  dtx, ptrb++             wz
        if_z    jmp     #.exit
                cmp     drx, #"?"               wz      ' Wildcard?
        if_nz   cmp     drx, dtx                wz
        if_nz   jmp     #.exit
                add     lmm_c, #1                       ' Pattern char matched name char
.exit
                mov     ptra, lmm_p                     ' Restore registers
                mov     ptrb, lmm_p2
        _ret_   cmp     lmm_c, #SHORTNAME_SIZE  wcz     ' Z set if all characters were matched
' */
' /* os_cmd_test
'------------------------------------------------------------------------------
' Useful when developing a new terminal command or to test small code snippets.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
os_cmd_test
                cmp     drx, #"#"               wz
        if_nz   jmp     #.test
                cmp     drootdir_base, #0       wz
        if_z    jmp     #err_no_media
.test
                call    #test_unit_ready
                cmp     csw_status, #CBS_CMD_PASSED wz
        if_z    loc     ptra, #@sz_media_present
        if_z    jmp     #dtx_nl_asciiz
' FAIL status, so get the details regarding the media state
                call    #request_sense
                cmp     sense_status, #CBS_CMD_PASSED wz
        if_nz   ret
                getword stmp, asc_ascq, #0
                cmp     sense_key, #S_UNIT_ATTENTION wz
        if_z    cmp     stmp, #ASC_Q_MEDIUM_NOT_PRESENT wz
        if_z    ret                                     ' Still no media
                cmp     stmp, #ASC_Q_NOTRDY_RDY_CHANGE wz
        if_nz   ret                                     ' Something else going on...
' Media available, so see if we can mount it
                mov     drootdir_base, #0               ' Reset for new file system search
                mov     dtask, #DT_BOMS_INQUIRY
                ret
{
                loc     ptra, #@sz_vt100_save_cursor
                call    #dtx_asciiz
                loc     ptra, #@sz_vt100_set_cursor
                call    #dtx_asciiz
                loc     ptra, #@sz_vt100_query_curpos
                call    #dtx_asciiz
                loc     ptrb, #@con_par_buff
.loop
                call    #drx_char_wait
                mov     dtx, lmm_x
                cmp     dtx, #ESC               wz
        if_nz   wrbyte  dtx, ptrb++
                cmp     dtx, #"R"               wz
        if_nz   jmp     #.loop
                wrbyte  #0, ptrb
                loc     ptra, #@sz_vt100_unsave_cursor
                call    #dtx_asciiz
                loc     ptra, #@con_par_buff
                jmp     #dtx_nl_asciiz
}
' */
' /* os_cmd_tgldbg
'------------------------------------------------------------------------------
' Toggle verbose debug output to console ON/OFF.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
os_cmd_tgldbg
                bitnot  dtxopts, #TX_VERBOSEB
                loc     ptra, #@sz_verbose_opt
                mov     dpar1, #TX_VERBOSEB
                jmp     #dtx_opt_toggle
' */
{
' /* os_cmd_term
os_cmd_term
                loc     ptra, #@sz_termtype
                call    #dtx_nl_asciiz
                mov     didx, #0
                loc     ptra, #@termtype_list
.loop
                rdbyte  stmp, ptra++            wz
        if_z    loc     ptra, #@sz_notfound
        if_z    jmp     #.exit
                loc     ptrb, #@cmd_par_buff
                call    #dstrcmp                        ' On exit dstr_ret1 has count of matched characters
        if_e    jmp     #.set
                sub     stmp, dstr_ret1
                add     ptra, stmp
                add     didx, #1
                jmp     #.loop
.set
                mov     dterm_type, didx
                loc     ptra, #@sz_set
.exit
                jmp     #dtx_nl_asciiz
' */
}
' /* os_cmd_cat
'------------------------------------------------------------------------------
' Send the contents of a text file, or files, to the console.
'------------------------------------------------------------------------------
' On entry:
'   drx - set to the media volume ID (A-Z) or "#" if no media present.
' On exit:
'------------------------------------------------------------------------------
os_cmd_cat
                cmp     drx, #"#"               wz
        if_z    jmp     #err_no_media
                loc     ptra, #@con_par_buff
                mov     dstr_par1, #" "
.next_par
                call    #dstrtok                        ' Z = (PTRA == 0)
        if_nz   jmp     #.get_pattern
                loc     ptra, #@sz_cmd_bad_syntax
                call    #dtx_nl_asciiz
                jmp     #dtx_newline
.get_pattern
                call    #dget_match_pattern
        if_nz   jmp     #.notfound
                loc     ptra, #@match_pattern_buff
                mov     lmm_c, #"?"                     ' Is the name pattern wildcarded?
                call    #dstrchr                        ' Z = (PTRA == 0)
                mov     dnum_dirs, ptra                 ' Test dnum_dirs (0 == no wildcards)
                mov     dnum_files, #0                  ' Track files processed
.search
                mov     dpar1, #DIR_FILEF               ' Only looking for files
                call    #ddir_find_first
                mov     pb, ptrb
                mov     dpad_char, dpar1
.loop
                cmp     dret1, #DIR_FILEB       wz
        if_z    jmp     #.cat
                cmp     dret1, #DIR_EOFB        wz
        if_z    cmp     dnum_files, #0          wz
        if_z    jmp     #.notfound
        if_nz   ret
                cmp     dret1, #DIR_INVALIDB    wz
        if_z    jmp     #.notfound
.next
                call    #ddir_find_next
                jmp     #.loop
.cat
                add     dnum_files, #1
                cmp     dnum_dirs, #0           wz
        if_z    jmp     #.out
                call    #dtx_newline
                loc     ptra, #@shortname_buff
                call    #dget_8dot3name
                call    #dtx_nl_asciiz
                call    #dtx_newline
.out
                rdlong  dtot_bytes_lo, ptrb[lDIR_FileSize >> 2]
                rdword  dtx, ptrb[wDIR_FstClusHI >> 1]
                setword datpar1, dtx, #1
                rdword  dtx, ptrb[wDIR_FstClusLO >> 1]
                setword datpar1, dtx, #0
                call    #dtx_newline
                call    #dget_first_data_clus
.outclus
                cmp     datpar1, ##FILE_EOF     wz
        if_z    ret
' Output data to the console
                mov     drx, dtot_bytes_lo
                fle     drx, dclus_size
                loc     ptrb, #@boms_cluster_buff
.data
                mov     drep, drx
                fle     drep, #80                       ' FIXME: console row/column values should be reg or constant
                call    #dtx_asciin
                waitx   ##_1us * 333
                mov     ptrb, ptra
                sub     drx, drep               wz
        if_nz   jmp     #.data
                cmp     dtot_bytes_lo, dclus_size wcz
        if_a    sub     dtot_bytes_lo, dclus_size
        if_a    jmp     #.multi_clus
                cmp     dnum_files, #0          wz
        if_z    ret
                jmp     #.next
.multi_clus
                call    #dget_next_data_clus
                jmp     #.outclus
.fail
                loc     ptra, #@sz_file_read_err
                jmp     #dtx_nl_asciiz
.notfound
                loc     ptra, #@sz_file_not_found       ' No match if no pattern constructed
                jmp     #dtx_nl_asciiz
' */
' /* err_no_media
err_no_media
                loc     ptra, #@sz_no_media
                jmp     #dtx_nl_asciiz
' */
' /* os_cmd_dir
'------------------------------------------------------------------------------
' Output a directory listing to the console. The output includes file/dir last
' modified date and time and file sizes. At this time only 8.3 entry names are
' processed. The output may be filtered by using the MS-DOS "*" and "?"
' wildcards in the search name. If no search pattern is provided, all file and
' directory names will be retrieved.
'------------------------------------------------------------------------------
' On entry:
'   drx - set to the media volume ID (A-Z) or "#" if no media present.
' On exit:
'------------------------------------------------------------------------------
os_cmd_dir
                cmp     drx, #"#"               wz
        if_z    jmp     #err_no_media
                call    #ddir_init
' Walk the directory and send formatted results of the "DIR" command
.search
                mov     dpar1, #ENTMATCH_FILE_DIR | DIR_LNAME_SUBCOMPF
                call    #ddir_find_first
.loop
                jmprel  dret1
                jmp     #ddir_summary                   ' No more entries to process
                jmp     #.next                          ' Entry was marked as deleted/free
                jmp     #.next                          ' Volume label is cached
                jmp     #.long_subcomp                  ' Only output longname sub-components if debugon
                jmp     #.isdir
                jmp     #.isfile
                jmp     #.isinvalid
                jmp     #.entry_overflow
.next
                call    #ddir_find_next
                jmp     #.loop
.entry_overflow
                loc     ptra, #@sz_entry_overflow
                jmp     #dtx_nl_asciiz
.isfile
                call    #dtx_newline
                call    #dtx_entry_datetime
                loc     ptra, #@sz_dir_pad
                call    #dtx_asciiz
                rdlong  dtx, ptrb[lDIR_FileSize >> 2]
                add     dtot_bytes_lo, dtx      wc
                addx    dtot_bytes_hi, #0
                mov     dpad_char, #" "
                mov     min_digits, #10
                call    #dtx_decimal
                mov     dtx, #" "
                call    #dtx_char
                loc     ptra, #@shortname_buff
                call    #dget_8dot3name
                call    #dtx_asciiz
                add     dnum_files, #1
                jmp     #.next
.isdir
                call    #dtx_newline
                call    #dtx_entry_datetime
                loc     ptra, #@sz_entry_dir
                call    #dtx_asciiz
                loc     ptra, #@shortname_buff
                call    #dget_8dot3name
                call    #dtx_asciiz
                mov     lmm_c, #12
                mov     dtx, #" "
                call    #dtx_rptchar
                add     dnum_dirs, #1
                jmp     #.next
.long_subcomp
                testb   dtxopts, #TX_VERBOSEB   wc
        if_nc   jmp     #.next
                loc     ptra, #@sz_longname_subcomp
                call    #dtx_nl_asciiz
                jmp     #.next
.isinvalid
                loc     ptra, #@sz_dirent_invalid
                call    #dtx_nl_asciiz                  ' FIXME: need to expand on this
                jmp     #.next
ddir_summary
                cmp     dnum_files, #0          wz
        if_z    cmp     dnum_dirs, #0           wz
        if_nz   jmp     #.summarize
                call    #dtx_newline
                loc     ptra, #@sz_file_not_found
                jmp     #dtx_asciiz_nl
.summarize
                mov     dpad_char, #" "
                mov     lmm_c, #5
                mov     dtx, #" "
                call    #dtx_nl_rptchar
                mov     min_digits, #10
                mov     dtx, dnum_files
                call    #dtx_decimal                    ' Count of files
                loc     ptra, #@sz_num_files
                call    #dtx_asciiz
                mov     lmm_p, dtot_bytes_lo
                mov     lmm_p2, dtot_bytes_hi
                mov     min_digits, #14
                call    #dtx_decimal64                  ' Total file bytes
                loc     ptra, #@sz_total_bytes
                call    #dtx_asciiz
                mov     lmm_c, #5
                mov     dtx, #" "
                call    #dtx_nl_rptchar
                mov     min_digits, #10
                mov     dtx, dnum_dirs
                call    #dtx_decimal                    ' Directory count
                loc     ptra, #@sz_num_dirs
                call    #dtx_asciiz
                qmul    dfsi_free_clus, dclus_size      ' Convert free clusters to bytes
                getqx   lmm_p                           ' Lower long of product
                getqy   lmm_p2                          ' Upper long of product
                mov     min_digits, #15
                call    #dtx_decimal64                  ' Hex->decimal text conversion to console
                loc     ptra, #@sz_bytes_free
                jmp     #dtx_asciiz
' */
' /* ddir_init
'------------------------------------------------------------------------------
' Initialize "DIR" command registers and get a filter pattern from the command
' input, if there. Output volume serial number and label information to the
' console.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
ddir_init
                mov     dnum_files, #0
                mov     dnum_dirs, #0
                mov     dtot_bytes_lo, #0
                mov     dtot_bytes_hi, #0
                loc     ptra, #@con_par_buff
                mov     dstr_par1, #" "
                call    #dstrtok
        if_nz   jmp     #.get_pattern
                loc     ptra, #@sz_dir_match_all
                loc     ptrb, #@match_pattern_buff
                call    #dstrcpy
                jmp     #.label
.get_pattern
                call    #dget_match_pattern
        if_nz   jmp     #ddir_summary                   ' No match if no pattern constructed
.label
                loc     ptra, #@sz_entry_label
                call    #dtx_nl_asciiz
                loc     ptra, #@sz_vol_label
                call    #dtx_asciiz
                loc     ptra, #@sz_vol_serial_num
                call    #dtx_nl_asciiz
                rdlong  stmp, ##vol_serial_num  wz
        if_z    jmp     #.noserial
                getword dtx, stmp, #1
                call    #dtx_hexword
                mov     dtx, #"-"
                call    #dtx_char
                getword dtx, stmp, #0
                call    #dtx_hexword
.noserial
                call    #dtx_newline
                loc     ptra, #@sz_directory_of
                call    #dtx_nl_asciiz
                loc     ptra, #@sz_cur_path
                call    #dtx_asciiz
                jmp     #dtx_newline
' */
' /* os_cmd_dirw
'------------------------------------------------------------------------------
' Output a "wide" directory listing to the console. The output includes only
' file and directory names. At this time only 8.3 entry names are processed.
' The output may be filtered by using the MS-DOS "*" and "?" wildcards in the
' search pattern. If no search pattern is provided, all file and directory
' names will be retrieved.
'------------------------------------------------------------------------------
' On entry:
'   drx - set to the media volume ID (A-Z) or "#" if no media present.
' On exit:
'------------------------------------------------------------------------------
os_cmd_dirw
                cmp     drx, #"#"               wz
        if_z    jmp     #err_no_media
                call    #ddir_init
                mov     drep, #0
                mov     dpar1, #ENTMATCH_FILE_DIR
                call    #ddir_find_first
                decod   dtmp, dret1
                test    dtmp, #ENTMATCH_FILE_DIR wz
        if_nz   call    #dtx_newline                    ' Have at least one file/dir to display
.loop
                jmprel  dret1
                jmp     #ddir_summary                   ' No more entries to process
                jmp     #.next                          ' Entry was marked as deleted/free
                jmp     #.next                          ' Volume label is cached
                jmp     #.next                          ' DIRW always ignores longname sub-components
                jmp     #.isdir
                jmp     #.isfile
                jmp     #.isinvalid
                jmp     #.entry_overflow
.next
                cmp     drep, #5                wz
        if_z    mov     drep, #0
        if_z    call    #dtx_newline
                call    #ddir_find_next
                jmp     #.loop
.entry_overflow
                loc     ptra, #@sz_entry_overflow
                jmp     #dtx_nl_asciiz
.isfile
                cmp     drep, #0                wcz
        if_a    loc     ptra, #@sz_filew_pre
        if_a    call    #dtx_asciiz
                loc     ptra, #@shortname_buff
                call    #dget_8dot3name
                call    #dtx_asciiz
                loc     ptra, #@sz_filew_post
                call    #dtx_asciiz
                rdlong  dtx, ptrb[lDIR_FileSize >> 2]
                add     dtot_bytes_lo, dtx      wc      ' FAT file size limited to 4GB
                addx    dtot_bytes_hi, #0
                add     dnum_files, #1
                add     drep, #1
                jmp     #.next
.isdir
                cmp     drep, #0                wz
        if_z    loc     ptra, #@sz_lbracket             ' At column zero, so just need start bracket char
        if_nz   loc     ptra, #@sz_dirw_pre             ' Need format padding if not column zero
                call    #dtx_asciiz
                loc     ptra, #@shortname_buff
                call    #dget_8dot3name
                loc     ptra, #@shortname_buff
                mov     lmm_c, #" "
                call    #dstrchr                        ' Z = (PTRA == 0) on return
                mov     dtx, #"]"
        if_nz   wrbyte  dtx, ptra
        if_nz   mov     stmp, #0
        if_z    mov     stmp, #"]"
                loc     ptra, #@shortname_buff
                call    #dtx_asciiz
                cmp     stmp, #0               wz
        if_z    mov     dtx, #" "
        if_nz   mov     dtx, stmp
                call    #dtx_char
                add     drep, #1
                add     dnum_dirs, #1
                jmp     #.next
.isinvalid
                loc     ptra, #@sz_dirent_invalid
                call    #dtx_nl_asciiz                  ' FIXME: need to expand on this
                jmp     #.next
' */
' /* os_cmd_cd
'------------------------------------------------------------------------------
' Open a directory and make it the current directory.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
os_cmd_cd
                cmp     drx, #"#"               wz
        if_z    jmp     #err_no_media
' Check for root, "." and ".." as targets
                loc     ptra, #@con_par_buff
                mov     lmm_p, #"/"
                mov     lmm_p2, #"\"
                call    #dstr_replace_chr               ' Allow "/" path separators but "\" is the norm
                loc     ptra, #@con_par_buff
                loc     ptrb, #@sz_cur_path
                mov     lmm_c, #3
                call    #dstrncmp                       ' Does the CD target start at root?
        if_nz   jmp     #.next0
                loc     ptra, #@con_par_buff
                call    #dstrlen
                cmp     lmm_c, #3               wz
        if_z    wrlong  #"\", ##con_par_buff
.next0
                loc     ptra, #@con_par_buff
                rdlong  drx, ptra
.slash
                and     drx, ##$ffffff
                cmp     drx, #$005c             wz      ' A single "\"?
        if_z    jmp     #.chkroot
                test    drx, #$ff               wz      ' First byte nul?
        if_nz   cmp     drx, #$002e             wz      ' Or dot followed by nul?
        if_z    ret                                     ' Either is a NOP
                cmp     drx, ##$002e2e          wz      ' Dotdot?
        if_nz   jmp     #.notdotdot
                cmp     dis_rootdir, #1         wz
        if_z    ret                                     ' Dotdot's a NOP when at root
                loc     ptra, #@sz_dir_match_dotdot     ' Need a proper .. match pattern
                loc     ptrb, #@match_pattern_buff
                call    #dstrcpy
                jmp     #.search
.chkroot
                cmp     dis_rootdir, #1         wz
        if_z    ret                                     ' At root, so it's a NOP
                mov     cbw0, #0
                jmp     #.cdroot                        ' Reload the root directory
.notdotdot
                loc     ptra, #@con_par_buff
                call    #dget_match_pattern
        if_nz   jmp     #.badpath
.search
                mov     dpar1, #DIR_DIRECTORYF
                call    #ddir_find_first
                cmp     dret1, #DIR_DIRECTORYB  wz
        if_z    jmp     #.open
.badpath
                loc     ptra, #@sz_bad_path
                jmp     #dtx_nl_asciiz
.open
                rdword  dtx, ptrb[wDIR_FstClusHI >> 1]  ' Directory cluster# high word
                setword cbw0, dtx, #1
                rdword  dtx, ptrb[wDIR_FstClusLO >> 1]  ' Directory cluster# high word
                setword cbw0, dtx, #0
.cdroot
                call    #dopen_dir
        if_z    jmp     #.badpath
                cmp     dis_rootdir, #0         wz
        if_z    jmp     #.notroot
' Just read the root directory, so reset the current path string
                loc     ptra, #@sz_cur_path
                wrbyte  #"\", ptra[2]
        _ret_   wrbyte  #0, ptra[3]
.notroot
                rdlong  drx, ##con_par_buff
                and     drx, ##$ffffff
                cmp     drx, ##$002e2e          wz      ' Dotdot?
        if_z    jmp     #.dotdot
                loc     ptra, #@sz_cur_path
                call    #dstrlen
                rdbyte  dtx, ptra[-1]
                cmp     dtx, #"\"               wz      ' Are we coming from root?
        if_nz   wrbyte  #"\", ptra++
                mov     ptrb, ptra
                loc     ptra, #@con_par_buff
                jmp     #dstrcpy
.dotdot
                loc     ptra, #@sz_cur_path
                mov     lmm_c, #"\"
                call    #dstrrchr
        if_z    jmp     #.badpath
        _ret_   wrbyte  #0, ptra
' */
' /* os_cmd_scanfat
'------------------------------------------------------------------------------
' Scan the FAT region and count the sector entries that are marked as free. If
' it is a FAT32 system and the count differs from what is stored in the FSInfo
' structure, the new free cluster count is saved to the media.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
os_cmd_scanfat
                cmp     drx, #"#"               wz
        if_z    jmp     #err_no_media
                loc     ptra, #@sz_fat
                call    #dtx_nl_asciiz
                call    #dscan_fat
        if_nz   jmp     #.fail
                cmp     df16_dir_secs, #0       wz
        if_nz   jmp     #.report                        ' FAT16 has no FSInfo structure
                cmp     dfsi_free_clus, fret1   wz
        if_z    jmp     #.report
                call    #dupdate_fsinfo
        if_z    jmp     #.report
.fail
                mov     dfsi_free_clus, fret1           ' Restore original count
                loc     ptra, #@sz_cmd_fail
                jmp     #dtx_nl_asciiz
.report
                loc     ptra, #@sz_scanfat_adj
                call    #dtx_nl_asciiz
                mov     dtx, dfsi_free_clus
                subs    dtx, fret1
                bith    dtxopts, #SHOW_POS_SIGNB
                call    #dtx_decimal_s
        _ret_   bitl    dtxopts, #SHOW_POS_SIGNB
' */
' /* os_cmd_getsec
'------------------------------------------------------------------------------
' Read one or more sectors from the media and output the bytes read to the
' console. If more than one sector is read, the previous sector data will be
' overwritten.
' 
'------------------------------------------------------------------------------
' On entry:
'   Usage - GETSEC start_sec [sec_count]
' On exit:
'------------------------------------------------------------------------------
os_cmd_getsec
                cmp     drx, #"#"               wz
        if_z    jmp     #err_no_media
                loc     ptra, #@con_par_buff
                mov     dstr_par1, #" "
                call    #dstrtok                        ' Z = (PTRA == 0)
        if_z    jmp     #.badpar
                mov     cbw0, ptra
                mov     ptra, #0
                call    #dstrtok
        if_z    mov     drx, #1
        if_z    jmp     #.getvals
        if_nz   mov     drx, ptra
                mov     ptra, #0
                call    #dstrtok
        if_nz   jmp     #.badpar                        ' Too many parameters
.getvals
                mov     ptra, cbw0
                call    #datol                          ' NC if conversion failed
        if_nc   jmp     #.badpar
                mov     cbw0, dret1
                cmp     drx, #1                 wz
        if_z    jmp     #.getsec
                mov     ptra, drx
                call    #datol
        if_nc   jmp     #.badpar
                mov     drx, dret1
                fge     drx, #1                         ' At least some range limiting...
                mov     ftmp, drx
                add     ftmp, cbw0
                cmp     ftmp, dvol_secs         wcz
        if_ae   mov     drx, dvol_secs
        if_ae   sub     drx, cbw0                       ' Ensure startsec + secs <= volsecs
                mov     cbw1, #1
.getsec
                call    #dtx_newline
                mov     cbw_io_data_ptr, ##boms_sector_buff
                call    #dget_sectors
        if_nz   ret
                mov     ptra, #0
                mov     lmm_p, ##boms_sector_buff
                mov     lmm_p2, ##SECTOR_512
                call    #dtx_hexlist
                add     cbw0, #1
        _ret_   djnz    drx, #.getsec
.badpar
                loc     ptra, #@sz_cmd_bad_syntax
                jmp     #dtx_nl_asciiz
' */
' /* os_cmd_putsec
'------------------------------------------------------------------------------
' Write one sector to the media.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
os_cmd_putsec
                ret
' */
' /* dget_dirent_type
'------------------------------------------------------------------------------
' Determine the type of a directory entry (label, longname sub-component,
' directory or file).
'------------------------------------------------------------------------------
' On entry:
'   PTRB - directory buffer address of the entry to check.
' On exit:
'   PTRB - unchanged.
'   dret1 - directory entry type constant.
'   fr0, fr1 - trashed.
'------------------------------------------------------------------------------
dget_dirent_type
                rdbyte  stmp, ptrb              wz      ' First byte of an entry has multiple meanings
        if_z    mov     dret1, #DIR_EOFB
        if_z    ret                                     ' If zero this entry is free and no allocated entries follow
                cmp     stmp, #DIR_ENTRY_FREE   wz
        if_e    mov     dret1, #DIR_FREEB
        if_e    ret                                     ' Entry is marked deleted/free
' Determine the type of this entry
                rdbyte  fr0, ptrb[bLDIR_Attr]           ' bLDIRAttr and bDIRAttr have identical offsets
                mov     fr1, fr0                        ' We'll use this multiple times
                and     fr0, #ATTR_LONGNAME_MASK
                cmp     fr0, #ATTR_LONGNAME     wz
        if_e    mov     dret1, #DIR_LNAME_SUBCOMPB
        if_e    jmp     #.exit
                mov     fr0, fr1
                and     fr0, #ATTR_DIRECTORYF | ATTR_VOLUME_IDF wz
        if_z    mov     dret1, #DIR_FILEB
        if_z    jmp     #.exit
                mov     fr0, fr1
                and     fr0, #ATTR_DIRECTORYF | ATTR_VOLUME_IDF
                cmp     fr0, #ATTR_DIRECTORYF   wz
        if_e    mov     dret1, #DIR_DIRECTORYB
        if_e    jmp     #.exit
                mov     fr0, fr1
                and     fr0, #ATTR_DIRECTORYF | ATTR_VOLUME_IDF
                cmp     fr0, #ATTR_VOLUME_IDF   wz
        if_e    mov     dret1, #DIR_VOL_LABELB
        if_e    jmp     #.exit
                mov     dret1, #DIR_INVALIDB
.exit
                ret
' */
' /* ddir_find_first, ddir_find_next
'------------------------------------------------------------------------------
' Search the current directory for name matches.
'------------------------------------------------------------------------------
' On entry:
'   dpar1 - entry type(s) to match (ddir_find_first).
' On exit:
'   dret1 - result of the dget_dirent_type routine, which will be one of:
'     DIR_EOFB, DIR_FREEB, DIR_VOL_LABELB, DIR_LNAME_SUBCOMPB
'     DIR_DIRECTORYB, DIR_FILEB, DIR_INVALIDB.
'   PTRB - points to the start of the current directory entry.
'------------------------------------------------------------------------------
ddir_find_first
                loc     ptrb, #@boms_dir_buff
                mov     dirent_ptr, ptrb                ' Make the entry pointer and match flags sticky
                mov     dirent_flgs, dpar1
                mov     fr2, dirent_cnt
                shl     fr2, #5                         ' Directory entry count * 32 = bytes in the buffer
                add     fr2, ptrb
                call    #dget_dirent_type
                jmp     #find_filter
ddir_find_next
                add     dirent_ptr, #DIR_ENTRY_SIZE
                mov     ptrb, dirent_ptr
                cmp     dirent_ptr, fr2         wcz
        if_a    mov     dret1, #DIR_OVERFLOWB           ' FIXME: FAT32 has no max for dir entries
        if_a    ret
                call    #dget_dirent_type
find_filter
                cmp     dret1, #DIR_EOFB        wz
        if_nz   cmp     dret1, #DIR_INVALIDB    wz      ' DEBUG
        if_z    ret                                     ' Always report these entries
                decod   dtmp, dret1                     ' Convert entry bit position to flag for TEST
                test    dirent_flgs, dtmp       wz
        if_z    jmp     #ddir_find_next                 ' Not the entry type caller wants
                test    dtmp, #ENTMATCH_FILE_DIR wz     ' Only file and directory name entries use pattern matching
        if_z    ret                                     ' Entry matched but not file/dir type
                call    #ddirname_compare
        if_z    ret                                     ' Entry type and name match!
                jmp     #ddir_find_next
' */
' /* dget_8dot3name
'------------------------------------------------------------------------------
' Format an 8.3 name for console output.
'------------------------------------------------------------------------------
' On entry:
'   PTRB - address of the shortname directory entry.
'   PTRA - address of the formatted shortname buffer.
' On exit:
'   PTRA, PTRB - unchanged.
'------------------------------------------------------------------------------
dget_8dot3name
                mov     lmm_p, ptra
                mov     lmm_p2, ptrb                    ' Save start addresses
                mov     didx, #0
                rep     #4, #8                          ' Count spaces in the name field and
                rdbyte  dtx, ptrb++                     ' append them after the extension field
                cmp     dtx, #" "               wz
        if_e    add     didx, #1
        if_ne   wrbyte  dtx, ptra++
                rdbyte  dtx, ptrb++
                cmp     dtx, #" "               wz
        if_e    add     didx, #1                        ' If no extension the padding must include
        if_ne   wrbyte  #".", ptra++                    ' the dot separator that wasn't used
                wrbyte  dtx, ptra++
                rep     #2, #2                          ' Copy remaining extension chars as-is
                rdbyte  dtx, ptrb++
                wrbyte  dtx, ptra++
                cmp     didx, #0                wz
        if_z    jmp     #.exit
'                rep     @.exit, didx                    ' Append any accumulated space characters
                rep     #1, didx                        ' Append any accumulated space characters
                wrbyte  #" ", ptra++
.exit
                mov     ptra, lmm_p
        _ret_   mov     ptrb, lmm_p2
' */
' /* dtx_entry_date
'------------------------------------------------------------------------------
' Read, format and output a directory entry time. The "create" date/time fields
' are the only ones mandatory, so that's all that is supported at this time.
'------------------------------------------------------------------------------
' On entry:
'   PTRB - start address of the directory entry.
' On exit:
'------------------------------------------------------------------------------
dtx_entry_date
                rdword  stmp, ptrb[wDIR_WrtDate >> 1]
                mov     dtx, stmp
                and     dtx, ##DATE_MOY_MASK
                shr     dtx, #5
                mov     dpad_char, #"0"
                mov     min_digits, #2
                call    #dtx_decimal
                mov     dtx, #"/"
                call    #dtx_char
                mov     dtx, stmp
                and     dtx, #DATE_DOM_MASK
                mov     min_digits, #2
                call    #dtx_decimal
                mov     dtx, #"/"
                call    #dtx_char
                mov     dtx, stmp
                and     dtx, ##DATE_YEARS_MASK
                shr     dtx, #9
                add     dtx, ##1980                     ' MS-DOS epoch is 01/01/1980
                jmp     #dtx_decimal
' */
' /* dtx_entry_datetime, dtx_entry_time
'------------------------------------------------------------------------------
' Read, format and output a directory entry time. The "create" date/time fields
' are the only ones mandatory, so that's all that is supported at this time.
'------------------------------------------------------------------------------
' On entry:
'   PTRB - start address of the directory entry.
' On exit:
'------------------------------------------------------------------------------
dtx_entry_datetime
                call    #dtx_entry_date
dtx_entry_time
                mov     dtx, #" "
                mov     lmm_c, #2
                call    #dtx_rptchar
                rdword  stmp, ptrb[wDIR_WrtTime >> 1]
                mov     dtx, stmp
                and     dtx, ##TIME_HOURS_MASK
                shr     dtx, #11
                cmp     dtx, #12                wcz     ' Set AM/PM
        if_ae   loc     ptra, #@sz_pm
        if_a    sub     dtx, #12                        ' Adjust 24-hour to AM/PM
        if_b    loc     ptra, #@sz_am
                mov     min_digits, #2
                call    #dtx_decimal
                mov     dtx, #":"
                call    #dtx_char
                mov     dtx, stmp
                and     dtx, ##TIME_MINUTES_MASK
                shr     dtx, #5
                mov     min_digits, #2
                call    #dtx_decimal
                jmp     #dtx_asciiz
' */
' /* dmemcpy
'------------------------------------------------------------------------------
' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - source address.
'   PTRB - destination address.
'   lmm_c - length of copy, in bytes.
' On exit:
'------------------------------------------------------------------------------
dmemcpy
                rdbyte  lmm_w, ptra++
                wrbyte  lmm_w, ptrb++
        _ret_   djnz    lmm_c, #dmemcpy
' */
' /* dmemset
'------------------------------------------------------------------------------
' Copies the character c to the first n characters of the string str.
'------------------------------------------------------------------------------
' On entry:
'   lmm_p - address of str.
'   lmm_x - value for fill.
'   lmm_c - number of bytes to be set to the value.
' On exit:
'   lmm_p - points to byte n of str.
'------------------------------------------------------------------------------
dmemset
                wrbyte  lmm_x, lmm_p
                add     lmm_p, #1
        _ret_   djnz    lmm_c, #dmemset
' */
' /* init_io_data
'------------------------------------------------------------------------------
' Initialize the mass storage data area to start-up values.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
init_io_data
                mov     dtmp, ##mass_storage_start
.loop
                wrbyte  #0, dtmp
                add     dtmp, #1
                cmp     dtmp, ##mass_storage_end  wz
        if_nz   jmp     #.loop
                wrbyte  #PID_DATA0, ##datain_next_datax' Reset IN/OUT datax sequence
        _ret_   wrbyte  #PID_DATA0, ##dataout_next_datax
' */
' /* serial_init
'------------------------------------------------------------------------------
' Initialize smart pins for asynchronous serial output.
'------------------------------------------------------------------------------
serial_init
'                mov     lmm_x, ##_115_200_8b
'                mov     lmm_x, ##_1M_8b
'                mov     lmm_x, ##_1_5M_8b
                mov     lmm_x, ##_2M_8b
'                mov     lmm_x, ##_3M_8b
                call    #_SerialInit                    ' Use the monitor in ROM routine to configure async RX/TX smart pins
                call    #dtx_cls                        ' Clear the terminal screen
                loc     ptra, #@dcog_started
                jmp     #dtx_asciiz
' */
' #region Terminal output routines
' /* dtx_result_to_con
'------------------------------------------------------------------------------
' Output detailed transaction results to the terminal. If reg dtxopts has the
' TX_VERBOSEB bitflag cleared, transactions with an ACK result will not be
' output.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - address of the zero-terminated string that describes the
'     transaction, zero if no string defined.
'   dpar2 - return code for the transaction.
'   dpar3 - if not ERR_NONE, a contextual error code.
' On exit:
'   dpar2, dpar3 unchanged.
'------------------------------------------------------------------------------
dtx_result_to_con
                modcz   _clr, _clr              wcz     ' Ensure both C and Z clear before tests
                testb   dtxopts, #TX_VERBOSEB   wc      ' Suppress ACK/ERR_NONE/ERR_ACK_RETRY when not verbose
        if_nc   cmp     dpar2, #PID_ACK         wz
  if_nc_and_nz  cmp     dpar2, #ERR_NONE        wz
  if_nc_and_nz  cmp     dpar2, #ERR_ACK_RETRY   wz
'  if_nc_and_nz  cmp     dpar2, #PID_NAK         wz
  if_nc_and_z   ret
dtx_result_code
                cmp     ptra, #0                wz
        if_z    loc     ptra, #@sz_generic_result
                call    #dtx_nl_asciiz
                cmp     dpar2, #ERR_END         wcz
        if_b    jmp     #.extended_code                 ' The error has bus and transfer/transaction context
'------------------------------------------------------------------------------
' Fetch a pointer to the text string for a USB response PID.
'------------------------------------------------------------------------------
' On entry:
'   dpar2 - USB response PID type.
'------------------------------------------------------------------------------
.code_text
                mov     ptra, #0
                cmp     dpar2, #PID_ACK         wz      ' Get text equivalent of USB result PID
        if_z    loc     ptra, #@sz_ack
                cmp     dpar2, #PID_NAK         wz
        if_z    loc     ptra, #@sz_nak
                cmp     dpar2, #PID_STALL       wz
        if_z    loc     ptra, #@sz_stall
                cmp     ptra, #0                wz
        if_nz   jmp     #dtx_asciiz                     ' If known PID response, output text and back to caller
.hex
                mov     dtx, dpar2                      ' Output the USB result as a hex value
                bith    dtxopts, #PREPEND_0XB
                call    #dtx_hexlong
        _ret_   bitl    dtxopts, #PREPEND_0XB
.extended_code
                mov     ptra, dpar2
                shl     ptra, #2                        ' Table offset in longs
                add     ptra, ##err_code_text
                rdlong  ptra, ptra
                jmp     #dtx_asciiz                     ' Concatenate transfer/transaction result text and back to caller
' */
' /* dtx_txn_result
'------------------------------------------------------------------------------
' Raw data for transaction results posted by the host.
'------------------------------------------------------------------------------
dtx_txn_result
                bith    dtxopts, #APPEND_NLB
                call    #dtx_newline
                mov     dtx, dpar1
                call    #dtx_hexlong
                mov     dtx, dpar2
                call    #dtx_hexlong
                mov     dtx, dpar3
                call    #dtx_hexlong
        _ret_   bitl    dtxopts, #APPEND_NLB
' */
' /* dtx_hexlist
'------------------------------------------------------------------------------
' Serial output of hex bytes/longs in space-delimited format using the P2 ROM
' Monitor routine. Output is always 16 bytes or four longs per line.
'------------------------------------------------------------------------------
' On entry:
'   lmm_p -  start address
'   lmm_p2 - count of bytes/longs to list
'   lmm_f - constant _BYTE_ (16 per line) or _LONG_ (4 per line)
'   PTRA - if not zero a pointer to a header string.
' On exit:
'------------------------------------------------------------------------------
dtx_dbg_hexbytes
                testb   dtxopts, #TX_VERBOSEB   wc
        if_nc   ret
dtx_hexbytes
                mov     lmm_f, #_BYTE_
                jmp     #dtx_header
dtx_dbg_hexlongs
                testb   dtxopts, #TX_VERBOSEB   wc
        if_nc   ret
dtx_hexlongs
                mov     lmm_f, #_LONG_
                cmp     lmm_p, ##$3ff           wcz
        if_a    shl     lmm_p2, #2                      ' If in hub space adjust count in longs to count in bytes
dtx_header
                cmp     ptra, #0                wz
        if_nz   call    #dtx_nl_asciiz
                call    #dtx_newline
                cmp     lmm_p2, #0              wz
        if_z    ret
dtx_hexlist
                mov     ptra, lmm_p2
                add     ptra, lmm_p                     ' Calculate the end address
                or      lmm_f, #_LIST                   ' ROM monitor hex list option
.loop
                call    #_HubList
                waitx   ##_1us * 500                    ' Line delay
                cmp     lmm_p, ptra             wcz
        if_b    jmp     #.loop
                ret
' htx_hexdump used by the "Demo" class driver variant
htx_hexdump
                rdlut   pb, #D_PAR1
                rdlut   dr0, #D_PAR2
dtx_unknown
                loc     ptra, #@sz_unknown_data
                call    #dtx_nl_asciiz
                mov     dr1, #16                        ' Column count
.loop
                cmp     dr1, #16                wz
        if_z    waitx   ##_1us * 18                     ' Line delay
        if_z    mov     dr1, #0
        if_z    call    #dtx_newline
                mov     dtx, #" "
                call    #dtx_char
                rdbyte  dtx, pb
                add     pb, #1
                call    #dtx_hexbyte
                add     dr1, #1
                djnz    dr0, #.loop
                ret
' */
' /* htx_dbg_data
'------------------------------------------------------------------------------
' Output a single host debug value to the terminal.
'------------------------------------------------------------------------------
' On entry:
'   dpar2 - whatever the host put there.
' On exit:
'------------------------------------------------------------------------------
htx_dbg_data
                loc     ptra, #@sz_dbg_data
                call    #dtx_nl_asciiz
                mov     dtx, dpar1
                jmp     #dtx_hexlong                    ' Debug data overrides OPT_VERBOSE setting
' */
' /* htx_break
'------------------------------------------------------------------------------
' Output host breakpoint info and debug value. The host halts after posting
' this request, so the driver does too.
'------------------------------------------------------------------------------
' On entry:
'   dpar1 - whatever the host put there.
' On exit:
'------------------------------------------------------------------------------
htx_break
                loc     ptra, #@sz_breakh
                call    #dtx_asciiz
                mov     dtx, dpar1
                call    #dtx_hexlong
                call    #dtx_newline
                loc     ptra, #@sz_host_stopped         ' Host halts
                call    #dtx_nl_asciiz
.halt           jmp     #.halt                          ' Driver halts
' */
' /* drx_char_nowait/wait
'------------------------------------------------------------------------------
' Read an input character from the serial terminal.
'------------------------------------------------------------------------------
' On entry:
'   reg lmm_x - any value.
' On exit:
'   C = 0, Z = 1, no new character and lmm_x unchanged.
'   C = 1, Z = 0, lmm_x = character value (including NUL).
'------------------------------------------------------------------------------
drx_char_nowait
                testp   #RX_PIN                 wc
        if_nc   modz    _set                    wz
        if_nc   ret                             wcz
get_char
                rdpin   lmm_x, #RX_PIN
                shr     lmm_x, #32 - 8
        _ret_   modz    _clr                    wz
drx_char_wait
                testp   #RX_PIN                 wc
        if_nc   jmp     #drx_char_wait
                jmp     #get_char
' */
' /* dtx_char
'------------------------------------------------------------------------------
' Output a character to the terminal. The carriage return character ($0D) is
' translated to a CR+LF newline sequence. For untranslated CR output, call the
' dtx_rawchar routine.
'------------------------------------------------------------------------------
' On entry:
'   dtx - character to output.
' On exit:
'   dtx - unchanged.
'------------------------------------------------------------------------------
dtx_char
                mov     lmm_x, dtx
                cmp     lmm_x, #CR              wz
        if_z    jmp     #_HubTxCR
                jmp     #_HubTx
{
                testp   #TX_PIN                 wc
        if_nc   jmp     #dtx_char
                wypin   dtx, #TX_PIN
                cmp     dtx, #CR                wz
        if_z    mov     dtx, #LF
        if_z    jmp     #dtx_char
                ret
}
'------------------------------------------------------------------------------
' Outut a character to the terminal without translation.
'------------------------------------------------------------------------------
' On entry:
'   dtx - character to output.
' On exit:
'   dtx - unchanged.
'------------------------------------------------------------------------------
dtx_rawchar
                mov     lmm_x, dtx
                jmp     #_HubTx
' */
'------------------------------------------------------------------------------
' /* dtx_newline
'------------------------------------------------------------------------------
' Explicit CR+LF newline sequence.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
dtx_newline
                jmp     #_HubTxCR
' */
' /* dtx_asciin
'------------------------------------------------------------------------------
' Output N characters to the terminal
'------------------------------------------------------------------------------
' On entry:
'   PTRB - address of the first byte of the string.
'   drep - count of characters to output.
' On exit:
'   PTRB - unchangd.
'   PTRA - pointer to char N.
'   drep - unchanged
'------------------------------------------------------------------------------
dtx_nl_asciin
                call    #dtx_newline
dtx_asciin
                mov     lmm_c, drep             wz
        if_z    ret
                mov     ptra, ptrb
.loop
                rdbyte  lmm_x, ptra++           wz
        if_z    ret
                call    #_HubTx
        _ret_   djnz    lmm_c, #.loop
' */
' /* htx_asciiz, dtx_asciiz
'------------------------------------------------------------------------------
' Output an ASCIIZ string to the terminal.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - address of first byte of the string.
' On exit:
'   PTRA - address of the byte that follows the zero terminator.
'------------------------------------------------------------------------------
htx_asciiz
                mov     ptra, dpar1                     ' Fetch string addr posted by host
dtx_nl_asciiz
                call    #dtx_newline
dtx_asciiz
                rdbyte  dtx, ptra++             wz
        if_z    ret
                call    #dtx_char
                jmp     #dtx_asciiz
dtx_asciiz_nl
                call    #dtx_asciiz
                jmp     #dtx_newline
' */
' /* dtx_indexed_asciiz
'------------------------------------------------------------------------------
' Output an ASCIIZ string to the terminal using an indexed pointer list.
'------------------------------------------------------------------------------
' On entry:
'   lmm_c - index to the asciiz pointer for output.
'   PTRA - address of the first pointer in the list.
' On exit:
'------------------------------------------------------------------------------
dtx_nl_indexed_asciiz
                call    #dtx_newline
dtx_indexed_asciiz
                shl     lmm_c, #2                       ' Accessing longs in hub
                add     ptra, lmm_c
                rdlong  ptra, ptra
                jmp     #dtx_asciiz
' */
' /* dstr_upper_csum, dstrn_upper_csum
'------------------------------------------------------------------------------
' Non-destructive uppercase conversion and checksum of a zero or character
' delimited string.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - address of the asciiz string to scan.
'   dpar1 - if not zero it is treated as an additional break character.
'   dpar2 - optional count of characters to process (dstrn_upper_csum only).
' On exit:
'   PTRA - undefined.
'   drep - processed string length.
'   dr0 - string checksum.
'------------------------------------------------------------------------------
dstrn_upper_csum
                jmp     #csum_init
dstr_upper_csum
                mov     dpar2, ##-1
csum_init
                mov     dr0, #0
                mov     drep, #0
.loop
                rdbyte  dtx, ptra++             wz
        if_nz   cmp     dtx, dpar1              wz
        if_z    ret
                cmp     dtx, #"a"               wcz
        if_ae   jmp     #.chkz
.chksum
                shr     dr0, #1                 wc
        if_c    add     dr0, #$80
                add     dr0, dtx
                and     dr0, #$ff
                add     drep, #1
        _ret_   djnz    dpar2, #.loop
.chkz
                cmp     dtx, #"z"               wcz
        if_a    jmp     #.chksum
                sub     dtx, #$20
                jmp     #.chksum
' */
' /* dgetline, dgetdelim
'------------------------------------------------------------------------------
' Read a line from a file into a buffer.
'------------------------------------------------------------------------------
' On entry:
'   lmm_p - start address of the line to read.
'   lmm_p2 - address of the line buffer. It is assumed that the caller has
'     allocated enough space to hold the line being read.
' On exit:
'   lmm_c - the count of characters read, including the delimiter character.
'------------------------------------------------------------------------------
dgetline
                ret
' */
' /* disspace
'------------------------------------------------------------------------------
' Test if c is a whitespace character.
'------------------------------------------------------------------------------
' On entry:
'   lmm_c - c.
' On exit:
'   Z = (c != whitespace)
'------------------------------------------------------------------------------
disspace
                mov     lmm_p, ##sz_whitespace
                mov     lmm_w, #0
.loop
                rdbyte  lmm_x, lmm_p            wz
        if_z    ret
                cmp     lmm_x, lmm_c            wz
        if_nz   add     lmm_p, #1
        if_nz   jmp     #.loop
        _ret_   modz    _clr                    wz
' */
' /* dstrcpy_toupper, dstrcpybc_toupper
'------------------------------------------------------------------------------
' Copy a zero or character delimited string with uppercase conversion. String
' src is unaltered and string dest is zero terminated.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - src pointer.
'   PTRB - dest pointer.
'   dpar1 - if not 0, a break character to match (dstrcpybc_toupper).
' On exit:
'   PTRA - points to the character that follows the zero terminator, or the
'     character that follows the break character (dstrcpybc_toupper).
'   lmm_c - count of characters scanned.
'------------------------------------------------------------------------------
dstrcpy_toupper
                mov     dpar1, #0
dstrcpybc_toupper
                mov     lmm_c, #0
.loop
                rdbyte  dtx, ptra++             wz
        if_nz   cmp     dtx, dpar1              wz
        if_z    wrbyte  #0, ptrb
        if_z    add     lmm_c, #1                       ' Add break char to the count
        if_z    ret
                cmp     dtx, #"a"               wcz
        if_b    jmp     #.next
                cmp     dtx, #"z"               wcz
        if_be   sub     dtx, #$20
.next
                wrbyte  dtx, ptrb++
                add     lmm_c, #1
                jmp     #.loop
' */
' /* datol
'------------------------------------------------------------------------------
' Converts the string str to an unsigned long.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - points to str.
' On exit:
'   dret1 - the converted long, zero if no valid conversion could be performed.
'   C = 1 if the conversion was successful, otherwise C = 0.
'   Z = (dret1 == 0)
'------------------------------------------------------------------------------
datol
                mov     dr0, ptra
                mov     dret1, #0
                mov     dr2, #1
                call    #dstrlen
                cmp     lmm_c, #10              wcz
        if_a    jmp     #.fail                          ' Exceeds max long digits
.mul
                rdbyte  dtx, --ptra
                call    #disdigit
        if_nz   jmp     #.fail
                sub     dtx, #"0"
                cmp     dr2, ##10000            wcz     ' Use 16x16 mul while we can
        if_be   mul     dtx, dr2
        if_be   mul     dr2, #10
        if_be   jmp     #.add
                qmul    dtx, dr2                        ' In 32x32 territory
                getqx   dtx
                qmul    dr2, #10
                getqx   dr2
.add
                add     dret1, dtx              wc
        if_c    jmp     #.fail                          ' Exceeds max long
                cmp     ptra, dr0               wcz
        if_a    jmp     #.mul                           ' More digits?
                modc    _set                    wc
        _ret_   cmp     dret1, #0               wz
.fail
        _ret_   mov     dret1, #0               wcz
' */
' /* disdigit
'------------------------------------------------------------------------------
' Test char to see if it is a dicimal digit ("0" through "9").
'------------------------------------------------------------------------------
' dtx - the character to test.
' Z = (dtx >= "0" && dtx <= "9")
'------------------------------------------------------------------------------
disdigit
                cmp     dtx, #"0"               wcz
        if_b    jmp     #.fail
                cmp     dtx, #"9"               wcz
        if_a    jmp     #.fail
        _ret_   modcz   _clr, _set              wcz
.fail
        _ret_   modcz   _set, _clr              wcz
' */
' /* dstrcat, dstrncat
'------------------------------------------------------------------------------
' Append string src to the end of string dest. The caller must ensure that
' dest has been properly sized to contain src and that src must not overlap
' dest.
'------------------------------------------------------------------------------
' On entry:
'   PTRB - dest pointer.
'   PTRA - src pointer.
' On exit:
'   PTRB - points to the start of string (dest + src).
'------------------------------------------------------------------------------
dstrcat
                mov     lmm_w, ptrb                     ' Push dest pointer
.tail
                rdbyte  lmm_c, ptrb++
                tjnz    lmm_c, #.tail
.cat
                rdbyte  lmm_c, ptra++
                wrbyte  lmm_c, ptrb++
                tjnz    lmm_c, #.cat
        _ret_   mov     ptrb, lmm_w                     ' Pop dest pointer
' */
' /* dstrchr
'------------------------------------------------------------------------------
' Scans for the first occurrence of the character c in the string str.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - str pointer.
'   lmm_c - character to match in str.
' On exit:
'   PTRA - points to the first occurrence of character c, or zero if the
'     character is not found.
'   Z = (PTRA == 0).
'------------------------------------------------------------------------------
dstrchr
                rdbyte  lmm_w, ptra++           wz
                tjz     lmm_w, #.exit
                cmp     lmm_w, lmm_c            wz
        if_nz   jmp     #dstrchr
.exit
                cmp     lmm_w, #0               wz
        if_nz   sub     ptra, #1                        ' Adjust to point to the matched character
        if_z    mov     ptra, #0
        _ret_   cmp     ptra, #0                wz
' */
' /* dstrcmp, dstrncmp
'------------------------------------------------------------------------------
' Compare at most the first n bytes of str1 and str2 (zero terminated).
'------------------------------------------------------------------------------
' On entry:
'   PTRA - str1 pointer.
'   PTRB - str2 pointer.
'   lmm_c - maximum characters to compare (dstrncmp).
' On exit:
'   dstr_ret1 - count of matched characters.
'   C, Z flags set according to (CMPS str1[n], str2[n]):
'     if_b str1 < str2, if_a str1 > str2, if_e str1 == str2.
'------------------------------------------------------------------------------
dstrcmp         mov     lmm_c, ##$-1
dstrncmp
                mov     dstr_ret1, #0                   ' Matched character count
.loop
                rdbyte  dtx, ptra++
                rdbyte  drx, ptrb++
                cmp     dtx, drx                wz
        if_ne   jmp     #.exit                          ' str1[n] != str2[n]?
                cmp     dtx, #0                 wz
        if_e    jmp     #.exit                          ' If one is zero, both are zero
                add     dstr_ret1, #1
                cmp     dstr_ret1, lmm_c        wz
        if_nz   jmp     #.loop
.exit
        _ret_   cmps    dtx, drx                wcz
' */
' /* dstrcpy, dstrncpy
'------------------------------------------------------------------------------
' Copy string src to dest, or copy up to N characters (dstrncpy).
'------------------------------------------------------------------------------
' On entry:
'   PTRA - src pointer.
'   PTRB - dest pointer.
'   lmm_c - number of characters to copy from source (dstrncpy).
' On exit:
'   PTRB - unchanged.
'------------------------------------------------------------------------------
dstrcpy         mov     lmm_c, ##$-1                    ' Break at NULL
dstrncpy
                mov     lmm_w, ptrb                     ' Push dest pointer
.loop
                rdbyte  lmm_x, ptra++
                wrbyte  lmm_x, ptrb++
                tjz     lmm_x, #.exit
                sub     lmm_c, #1
                tjnz    lmm_c, #.loop
                wrbyte  #0, ptrb                        ' Don't forget to terminate dest
.exit
        _ret_   mov     ptrb, lmm_w                     ' Pop dest pointer
' */
' /* dstrlen, dstrlenr
'------------------------------------------------------------------------------
' Compute the length of string str up to, but not including the terminating
' null character.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - str pointer.
' On exit:
'   lmm_c - count of characters.
'   PTRA - points to the string terminating zero (dstrlen).
'   PTRA - reset to the start of the string (dstrlenr).
'   Z = (lmm_c == 0).
'------------------------------------------------------------------------------
dstrlenr
                mov     lmm_f, #1                       ' Set PTRA reset mode
                skip    lmm_f                           ' and skip next instruction
dstrlen
                mov     lmm_f, #0
                mov     lmm_c, #0
                mov     lmm_w, ptra
.loop
                rdbyte  lmm_x, ptra++
                tjz     lmm_x, #.exit
                add     lmm_c, #1
                jmp     #.loop
.exit
                cmp     lmm_f, #0               wz
        if_z    sub     ptra, #1                        ' Park on the zero terminator
        if_nz   mov     ptra, lmm_w                     ' Reset to start-of-string
        _ret_   cmp     lmm_c, #0               wz
' */
' /* dstrpbrk, dstrnpbrk
'------------------------------------------------------------------------------
' Finds the first character in str1 that matches any character specified in
' str2.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - str1 pointer.
'   PTRB - str2 pointer.
' On exit:
'   dstr_ret1 - pointer to the character in str1 that was matched, or zero if
'     no match was found.
'   Z = (dstr_ret1 == 0).
'------------------------------------------------------------------------------
dstrpbrk
                mov     lmm_w, ptrb                     ' Push str2 pointer
                mov     dstr_ret1, #0
.oloop
                rdbyte  lmm_x, ptra++
                tjz     lmm_x, #.exit
.iloop
                rdbyte  lmm_c, ptrb++           wz
        if_z    mov     ptrb, lmm_w
        if_z    jmp     #.oloop
                cmp     lmm_c, lmm_x            wz
        if_nz   jmp     #.iloop
                sub     ptrb, #1
                mov     dstr_ret1, ptrb
.exit
        _ret_   cmp     dstr_ret1, #0           wz
' */
' /* dstr_replace_chr
'------------------------------------------------------------------------------
' Replace all ocurrences of character c1 with c2.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - string pointer.
'   lmm_p - the character to match.
'   lmm_p2 - the replacement character.
' On exit:
'   lmm_c - count of replaced characters.
'------------------------------------------------------------------------------
dstr_replace_chr
                mov     lmm_c, #0
                rep     #6, #0
                rdbyte  lmm_x, ptra             wz
        if_z    ret
                cmp     lmm_x, lmm_p            wz
        if_z    wrbyte  lmm_p2, ptra
        if_z    add     lmm_c, #1
                add     ptra, #1

' */
' /* dstrrchr
'------------------------------------------------------------------------------
' Searches for the last occurrence of the character c in the string str.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - str pointer.
'   lmm_c - character to match.
' On exit:
'   PTRA - points to the last occurence of c in str else zero if c was not
'     matched.
'   lmm_x - if the character was matched, the position of the character in the
'     string, otherwise undefined.
'   Z = (PTRA == 0).
'------------------------------------------------------------------------------
dstrrchr
                mov     lmm_p, ptra
                mov     lmm_x, #0
.tail
                rdbyte  lmm_w, ptra++
                tjnz    lmm_w, #.tail
.head
                rdbyte  lmm_w, --ptra
                cmp     lmm_w, lmm_c            wz
        if_z    mov     lmm_x, lmm_p
        if_z    subr    lmm_x, ptra
        if_z    add     lmm_x, #1                       ' Return the position, not the offset
        if_z    jmp     #.exit
                cmp     lmm_p, ptra             wz
        if_nz   jmp     #.head
                mov     ptra, #0
.exit
        _ret_   cmp     ptra, #0                wz
' */
' /* dstrtok
'------------------------------------------------------------------------------
' Breaks string str into a series of tokens separated by a delimiter character.
' The first CALL to dstrtok must have PTRA set to the start address of the zero
' terminated string to be processed. Subsequent CALLs to dstrtok must have PTRA
' set to zero in order to retrieve the next token, if any. If no more tokens
' are found, PTRA will be set to zero on return.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - points to the string to be scanned. The contents of the string are
'     modified and broken into smaller strings (tokens).
'   dstr_par1 - the character to use as the delimiter. The delimiter character
'     may be changed between CALLs.
' On exit:
'   PTRA - points to the start of the first/next token else, zero.
'   dstr_par1 - unchanged.
'   Z = (PTRA == 0).
'------------------------------------------------------------------------------
dstrtok
                tjz     ptra, #.set_token_ptr
                mov     dstr_ptr, ptra                  ' Init dstr_ptr to cover zero-length string case
' We have a start address, so scan and set dstr_ptr to the next token, if any
.head_token
                rdbyte  dtx, ptra               wz
        if_z    jmp     #.exit
                cmp     dtx, dstr_par1          wz      ' Swallow any leading delimiter char
        if_z    add     ptra, #1
        if_z    jmp     #.head_token
                mov     dstr_ptr, ptra                  ' Adjust for any delim chars skipped
.tail_token
                rdbyte  dtx, dstr_ptr           wz
        if_z    jmp     #.exit
                cmp     dtx, dstr_par1          wz
        if_z    wrbyte  #0, dstr_ptr
                add     dstr_ptr, #1
        if_z    jmp     #.exit
                jmp     #.tail_token
.set_token_ptr
                mov     ptra, dstr_ptr                  ' Tail token becomes head token
                jmp     #.head_token
.exit
                cmp     dstr_ptr, ptra          wz
        if_z    mov     ptra, #0
        _ret_   cmp     ptra, #0                wz
' */
' /* dtx_rptchar
'------------------------------------------------------------------------------
' Output a single character, repeated n times.
'------------------------------------------------------------------------------
' On entry:
'   dtx - character to transmit.
'   lmm_c - repeat count.
' On exit:
'------------------------------------------------------------------------------
dtx_nl_rptchar
                call    #dtx_newline
dtx_rptchar
                call    #dtx_char
        _ret_   djnz    lmm_c, #dtx_rptchar
' */
' /* Terminal caret positioning routines
'------------------------------------------------------------------------------
' Terminal type jump table for the clear screen function.
'------------------------------------------------------------------------------
dtx_cls
                fle     dterm_type, #TERM_END - 1
                jmprel  dterm_type
                ret                                     ' Dumb termial
                jmp     #dtx_pst_cls                    ' Parallax Serial Terminal
                jmp     #dtx_vt100_cls                  ' ANSI/VT100
'------------------------------------------------------------------------------
' Parallax Serial Terminal clear screen function.
'------------------------------------------------------------------------------
dtx_pst_cls
                mov     lmm_x, #PST_CLS
                jmp     #_HubTx
'------------------------------------------------------------------------------
' VT100 escape sequence to clear the terminal screen.
'------------------------------------------------------------------------------
dtx_vt100_cls
                loc     ptra, #@sz_vt100_cls
                jmp     #dtx_asciiz
'------------------------------------------------------------------------------
' Move terminal cursor to the start of the current line.
'------------------------------------------------------------------------------
dtx_cr
                cmp     dterm_type, #TERM_PST   wz
        if_nz   mov     lmm_x, #CR                      ' CR moves the cursor to column zero on most terminals
        if_nz   jmp     #_HubTx
                mov     lmm_x, #PST_GOTOX               ' PST interprets CR as CR+NL, so use its GOTO-X
                call    #_HubTx                         ' function to set the cursor at column zero
                mov     lmm_x, #0
                jmp     #_HubTx
' */
' /* dtx_stack_ret_addr
'------------------------------------------------------------------------------
' Output the address at the top of the hardware stack.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
dtx_dbg_stack_ret_addr
                testb   dtxopts, #TX_VERBOSEB   wc
        if_nc   ret
dtx_stack_ret_addr
                pop     caller_ret_addr
                pop     target_ret_addr
                loc     ptra, #@sz_stack_addr
                call    #dtx_nl_asciiz
                mov     dtx, target_ret_addr
                push    target_ret_addr
                push    caller_ret_addr
                jmp     #dtx_nl_hexlong
{
'topstack
                loc     ptra, #@$
                mov     dtx, ptra
                call    #dtx_nl_hexlong
                pop     target_ret_addr
                loc     ptra, #@sz_stack_addr
                call    #dtx_nl_asciiz
                mov     dtx, target_ret_addr
                push    target_ret_addr
                call    #dtx_nl_hexlong
'end
}
' */
' /* dtx_dbgval
'------------------------------------------------------------------------------
' Output class driver debug value (driver does not halt).
'------------------------------------------------------------------------------
' On entry:
'   dpar3 - arbitrary debug value.
' On exit:
'------------------------------------------------------------------------------
dtx_dbgval
                loc     ptra, #@sz_breakd
                call    #dtx_asciiz
                mov     dtx, dpar3
                jmp     #dtx_hexlong
' */
' /* dtx_nl_hdr_decimal, dtx_nl_hdr_decimals
'------------------------------------------------------------------------------
' Output a header asciiz string followed by a decimal value to the terminal.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - address of the asciiz header string.
'   dtx - value to convert and output as decimal.
'------------------------------------------------------------------------------
dtx_nl_hdr_decimal
                mov     dr4, dtx                        ' Push output value
                call    #dtx_nl_asciiz
                mov     dtx, dr4
                jmp     #dtx_decimal
dtx_nl_hdr_decimals
                mov     dr4, dtx
                call    #dtx_nl_asciiz
                mov     dtx, dr4
                jmp     #dtx_decimal_s
' */
' /* dtx_decimal_s, dtx_decimal
'------------------------------------------------------------------------------
' Convert a signed/unsigned 32-bit value to decimal text. Based on a routine
' written by Ozpropdev.
'------------------------------------------------------------------------------
' On entry:
'   dtx - value to convert to decimal characters.
'   min_digits - if the value has fewer than min_digits, pad with leading
'     zeros or custom character.
'   dpad_char - if not 0, the character to use as a pad instead of zero.
' On exit:
'------------------------------------------------------------------------------
dtx_dbg_nl_decimal
                testb   dtxopts, #TX_VERBOSEB   wc
        if_nc   ret
dtx_nl_decimal
                call    #dtx_newline
                jmp     #dtx_decimal
dtx_nl_decimal_s
                call    #dtx_newline
dtx_decimal_s
                mov     dtmp, dtx               wc      ' Sign bit set?
                negc    dtmp                            ' If negative, back to positive for output
                test    dtxopts, #SHOW_POS_SIGNF wz     ' Show "+" sign if set or pad with space if cleared
        if_c    mov     dtx, #"-"
  if_nc_and_z   mov     dtx, #" "
  if_nc_and_nz  mov     dtx, #"+"
                call    #dtx_char
                mov     dtx, dtmp
dtx_decimal
                mov     dr0, ##1_000_000_000            ' Divisor
                mov     dr1, #0                         ' Reg dr1 holds digit postions 7..0
                mov     drep, #10                       ' Max of 10 digit output
                fle     min_digits, #10                 ' FIXME: should throw out-of-range error
                fge     min_digits, #1
                mov     dr3, #0
'                rep     @.end, #10
                rep     #10, #10
                qdiv    dtx, dr0
                getqx   dtmp                    wz
        if_nz   add     dr3, #1                         ' Becomes non-zero at first leading non-zero digit
                cmp     dr3, #0                 wz
        if_z    sub     drep, #1                        ' Decrement digit count if it's a leading zero
                getqy   dtx
                rolnib  dr2, dr1, #7                    ' Reg dr2 holds digit postions 9..8
                rolnib  dr1, dtmp, #0
                qdiv    dr0, #10
                getqx   dr0
.end
                cmp     drep, #0                wz
        if_z    mov     drep, #1                        ' The value was zero so ensure one is output
                cmp     min_digits, #1          wz
        if_z    jmp     #.out                           ' No output of leading zeros or custom char
                cmp     dpad_char, #0           wz
        if_z    mov     dpad_char, #"0"                 ' If no custom char defined default to zero
                cmp     drep, min_digits        wcz
        if_ae   jmp     #.out
                mov     lmm_c, min_digits
                sub     lmm_c, drep
                mov     dtx, dpad_char
                call    #dtx_rptchar
.out
                cmp     drep, #9                wcz
        if_b    jmp     #.r1out
                mov     dr3, drep
                sub     drep, #8                        ' Get count of digits > 8
                mov     dtx, dr2
                call    #dtx_hexn
                mov     drep, dr3
.r1out
                mov     dtx, dr1                        ' Output remaining digits
                call    #dtx_hexn
        _ret_   mov     min_digits, #1                  ' Reset to default
' */
' /* dtx_decimal64
'------------------------------------------------------------------------------
' Convert an unsigned 64-bit value to decimal text. This routine is a C->PASM
' interpretation of an algorithm by Douglas W. Jones of the University of Iowa
' Department of Computer Science. The algorithm may be found at:
'   http://homepage.divms.uiowa.edu/~jones/bcd/decimal.html
' By breaking the 64-bit value into five 16-bit base 10,000 chunks, the P2
' CORDIC solver's 64/32 unsigned divide with 32-bit quotient and 32-bit
' remainder function may be utilized.
'------------------------------------------------------------------------------
' On entry:
'   lmm_p - low long of the 64-bit value to convert.
'   lmm_p2 - high long of the 64-bit value to convert.
'   min_digits - if the value has fewer than min_digits, pad with leading
'     zeros or custom character up to min_digits. The default min_digits value
'     is one.
'   dpad_char - if not 0, the character to use as a pad instead of "0" for
'     leading zero positions.
' On exit:
'   PTRA - undefined.
'------------------------------------------------------------------------------
dtx_decimal64_nl
                call    #dtx_decimal64
                jmp     #dtx_newline
dtx_nl_decimal64
                call    #dtx_newline
dtx_decimal64
                getword dr0, lmm_p, #0
                getword dr1, lmm_p, #1
                getword dr2, lmm_p2, #0
                getword dr3, lmm_p2, #1
                mov     dtmp, ##656                     ' Calculate group zero
                mul     dtmp, dr3
                mov     stmp, dtmp
                mov     dtmp, ##7296
                mul     dtmp, dr2
                add     stmp, dtmp
                mov     dtmp, ##5536
                mul     dtmp, dr1
                add     stmp, dtmp
                add     dr0, stmp
                qdiv    dr0, ##10000
                getqx   lmm_x                           ' Quotient
                getqy   dr0                             ' Divisor
                mov     stmp, dr3                       ' Calculate group one
                mul     stmp, ##7671
                add     stmp, lmm_x
                mov     dtmp, dr2
                mul     dtmp, ##9496
                add     stmp, dtmp
                mul     dr1, #6
                add     dr1, stmp
                qdiv    dr1, ##10000
                getqx   lmm_x
                getqy   dr1
                mov     dtmp, dr3                       ' Calculate group two
                mul     dtmp, ##4749
                mov     stmp, dtmp
                add     stmp, lmm_x
                mov     dtmp, #42
                mul     dr2, dtmp
                add     dr2, stmp
                qdiv    dr2, ##10000
                getqx   lmm_x
                getqy   dr2
                mul     dr3, #281                       ' Calculate group three
                add     dr3, lmm_x
                qdiv    dr3, ##10000
                getqx   dr4                             ' The final quotient becomes group four
                getqy   dr3
' Convert hex->decimal text and write to the format buffer
                mov     didx, #4                        ' Convert the chunks to decimal digits from high to low
                loc     ptra, #@sz_dec64_buff
.convert
                alts    didx, #dr0                      ' Use cog register indirect addressing
                mov     dtx, 0-0
                call    #du16_to_strdec
                djnf    didx, #.convert
' Determine the count of digits to output, and replace leading zeros with a
' custom char if dpad_char is > zero
                loc     ptra, #@sz_dec64_buff
                mov     didx, #20                       ' didx is the offset to the first pad char or digit to output
.loop
                rdbyte  dtx, ptra               wz
        if_z    jmp     #.out
                cmp     dtx, #"0"               wz
        if_nz   jmp     #.out
                cmp     dpad_char, #0           wz
        if_nz   mov     dtx, dpad_char
        if_nz   wrbyte  dtx, ptra
                sub     didx, #1
                cmp     didx, #1                wz
        if_z    jmp     #.out
                add     ptra, #1
                jmp     #.loop
.out
' Output is no leading zeros, or pad chars, unless overridden by min_digits
                fge     didx, min_digits
                subr    didx, #20
                loc     ptra, #@sz_dec64_buff
                add     ptra, didx
                call    #dtx_asciiz
        _ret_   mov     min_digits, #1                  ' Reset to default of no leading zeros/pad
' /* du16_to_strdec
'------------------------------------------------------------------------------
' Helper routine for 64-bit->decimal text conversion. Converts a 16-bit
' unsigned hexadecimal value to ascii decimal characters and append the digits
' to a buffer. On return PTRA will be positioned to append a subsequent value
' to the output buffer.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - points to the current position in the output buffer.
'   dtx - the hex value to convert.
' On exit:
'   PTRA - points to the start of the next digit sequence, if any.
'------------------------------------------------------------------------------
du16_to_strdec
                mov     lmm_p, ##1_000
                mov     lmm_p2, #0
'                rep     @.end, #4
                rep     #6, #4
                qdiv    dtx, lmm_p
                getqx   dtmp
                getqy   dtx
                rolnib  lmm_p2, dtmp, #0
                qdiv    lmm_p, #10
                getqx   lmm_p
.end
' Append the converted digits to the format buffer.
'                rep     @.done, #4
                rep     #4, #4
                getnib  dtx, lmm_p2, #3
                add     dtx, #"0"
                wrbyte  dtx, ptra++
                shl     lmm_p2, #4
.done
        _ret_   wrbyte  #0, ptra                        ' Ready to append the next value, if any
' */
' /* dtx_bin
'------------------------------------------------------------------------------
' Convert to text one to 32 binary digits. Bits are sent MSb first.
'------------------------------------------------------------------------------
' On entry:
'   dtx - value to convert.
'   drep - count of bits to convert.
' On exit:
'------------------------------------------------------------------------------
dtx_bin
                fle     drep, #32
                fge     drep, #1
                mov     dtmp, dtx
                testb   dtxopts, #IN_PARENSB    wc
        if_c    mov     dtx, #"("
        if_c    call    #dtx_char
                testb   dtxopts, #PREPEND_0XB   wc
        if_c    loc     ptra, #@sz_0b                   ' Option prepend "0b" to output
        if_c    call    #dtx_asciiz
                mov     dtx, #32
                sub     dtx, drep
                shl     dtmp, dtx                       ' Left justify to get to MSb
.next
                shl     dtmp, #1                wc      ' Tx MSb->LSb
        if_nc   mov     dtx, #"0"
        if_c    mov     dtx, #"1"
                call    #dtx_char
                djnz    drep, #.next
                testb   dtxopts, #IN_PARENSB    wc
        if_c    mov     dtx, #")"
        if_c    call    #dtx_char
                testb   dtxopts, #APPEND_NLB    wc
        if_c    jmp     #dtx_newline
                ret
' */
' /* Output hex nibble/byte/word/long
'------------------------------------------------------------------------------
' On entry:
'   dtx - value to convert.
'   drep - count of nibbles to convert.
'------------------------------------------------------------------------------
dtx_nl_hexnib
                call    #dtx_newline
dtx_hexnib
                mov     drep, #1
                jmp     #dtx_hexn
dtx_nl_hexbyte
                call    #dtx_newline
dtx_hexbyte
                mov     drep, #2
                jmp     #dtx_hexn
dtx_nl_hexword
                call    #dtx_newline
dtx_hexword
                mov     drep, #4
                jmp     #dtx_hexn
dtx_nl_hdr_hexlong
                mov     dr4, dtx
                call    #dtx_nl_asciiz
                mov     dtx, dr4
                jmp     #dtx_hexlong
dtx_nl_hexlong
                call    #dtx_newline
dtx_hexlong
                mov     drep, #0
                jmp     #dtx_hexn
' */
' /* dtx_hexn
'------------------------------------------------------------------------------
' Convert to text one to eight hexadecimal/decimal digits of the value in the
' dtx register. Use a digit count of zero to output all eight digits.
'------------------------------------------------------------------------------
' On entry:
'   dtx - value to output as text.
'   drep - count of digits to output (one to seven).
' On exit:
'------------------------------------------------------------------------------
dtx_hexn
                mov     dtmp, dtx                       ' Save output char
                mov     lmm_f, #_HEX_                   ' Use the monitor in ROM routine to output hex chars
                cmp     drep, #8                wcz
        if_b    or      lmm_f, drep                     ' Cap to eight or fewer digits
                testb   dtxopts, #IN_PARENSB    wc
        if_c    mov     dtx, #"("
        if_c    call    #dtx_char
                testb   dtxopts, #PREPEND_0XB   wc
        if_c    loc     ptra, #@sz_0x
        if_c    call    #dtx_asciiz
                mov     lmm_x, dtmp
                call    #_HubHex                        ' Output digits
                testb   dtxopts, #IN_PARENSB    wc
        if_c    mov     dtx, #")"
        if_c    call    #dtx_char
                testb   dtxopts, #APPEND_NLB    wc
        if_c    jmp     #dtx_newline
                ret
' */
' /* htx_retstat
'------------------------------------------------------------------------------
' Output USB host receiver status word (data:flags) plus one debug value.
'------------------------------------------------------------------------------
' On entry:
'   dpar1 - rx status word.
'   dpar2 - optional arbitrary debug value.
' On exit:
'------------------------------------------------------------------------------
{
htx_retstat
                mov     lmm_c, #12                      ' Format the output
                mov     dtx, #" "
                call    #dtx_rptchar
                loc     ptra, #@sz_stathdr
                call    #dtx_asciiz
                loc     ptra, #@sz_stat
                call    #dtx_asciiz
                mov     dtx, dpar1                      ' Fetch the USB rx status word
                push    dtx
                mov     drep, #8
                call    #dtx_bin                        ' Output USB rx status bits
                mov     lmm_c, #2
                mov     dtx, #" "
                call    #dtx_rptchar
                mov     dtx, #"$"
                call    #dtx_char
                pop     dtx
                shr     dtx, #8
                call    #dtx_hexbyte                    ' Output USB rx data byte
                call    #dtx_newline
                loc     ptra, #@sz_ret
                call    #dtx_asciiz
                mov     dtx, dpar2                      ' Fetch the debug data
                call    #dtx_hexlong
                call    #dtx_newline
                ret
}
' */
' #endregion Terminal output routines
' /* dload_lut
'------------------------------------------------------------------------------
' Load driver code/data from hub RAM to LUT, if any
'------------------------------------------------------------------------------
dload_lut
                mov     drep, ##@dlut_end - 4           ' Will be copying SETQ2 N - 1 longs
                subs    drep, ##@dlut_start     wc
        if_c    ret                                     ' If < 0 no LUT code/data
                shr     drep, #2                        ' Adjust count for longs
                setq2   drep
        _ret_   rdlong  DLUT_BASE, ##@dlut_start        ' Copy and return
' */
' /* rom_monitor
'------------------------------------------------------------------------------
' Enter the P2 monitor in ROM
'------------------------------------------------------------------------------
rom_monitor
                drvl    #DRIVER_ACTIVE_LED              ' Keep driver feedback LED lit while in the monitor
                call    #_HubTxCR
                call    #_HubTxStrVer
                call    #_HubMonitor
                drvh    #DRIVER_ACTIVE_LED
' */
' /* dpulse_led
'------------------------------------------------------------------------------
' Blink Prop123-A9 LED12 while the driver is in the disconnected/idle state.
'------------------------------------------------------------------------------
dpulse_led
                drvnot  #DRIVER_ACTIVE_LED
                getct   dct3
        _ret_   addct3  dct3, ##PULSE_TIME
' */
                long    DBG_C0DEDEAD                    ' End of code marker
' #endregion DAT (Class Driver HubExec)
' #region CON (USB Descriptor Definitions)
con
'------------------------------------------------------------------------------
' USB References:
' Universal Serial Bus Specification, Revision 2.0
'   www.usb.org/developers/docs/usb20_docs/
' Device Class Definition for Human Interface Devices (HID), Version 1.11
'   www.usb.org/developers/hidpage/
'------------------------------------------------------------------------------
' SETUP packet bmRequestType bit groups (Section 9.3.1, Table 9-2).
' Use TYPE_STANDARD for all USB Standard Device Request codes.
'------------------------------------------------------------------------------
' D7 Data direction  | D6:5 Type    | D4:0 Recipient
'------------------------------------------------------------------------------
' 0 - Host-to-device | 0 = Standard | 0 = Device
' 1 - Device-to-host | 1 = Class    | 1 = Interface
'                    | 2 = Vendor   | 2 = Endpoint
'                    | 3 = Reserved | 3 = Other
'                    |              | 4 -31 = Reserved
'------------------------------------------------------------------------------
        DIR_HOST_TO_DEV = 0 << 7
        DIR_DEV_TO_HOST = 1 << 7                ' D7 Data direction
        TYPE_STANDARD   = %00 << 5              ' D6:D5 Type (use Standard for all USB Standard Device Requests
        TYPE_CLASS      = %01 << 5
        TYPE_VENDOR     = %10 << 5
        TYPE_RESERVED   = %11 << 5
        RECIP_DEVICE    = %0_0000               ' D4..D0 Recipient
        RECIP_INTERFACE = %0_0001
        RECIP_ENDPOINT  = %0_0010
        RECIP_OTHER     = %0_0011
'       RECIP 4 - 31 = Reserved
'------------------------------------------------------------------------------
' Standard Device Request Codes (Section 9.4, Table 9-4):
'------------------------------------------------------------------------------
        #0, REQ_GET_STATUS, REQ_CLEAR_FEATURE, REQ_RESERVED_1, REQ_SET_FEATURE
        REQ_RESERVED2, REQ_SET_ADDR, REQ_GET_DESC, REQ_SET_DESC, REQ_GET_CONFIG
        REQ_SET_CONFIG, REQ_GET_INTF, REQ_SET_INTF, REQ_SYNC_FRAME
'------------------------------------------------------------------------------
' Hub Class Request Codes (Section 11.24.2, Table 11-16):
'------------------------------------------------------------------------------
        #0, HUB_GET_STATUS, HUB_CLEAR_FEATURE, HUB_GET_STATE, HUB_SET_FEATURE
        HUB_RESERVED_1, HUB_RESERVED_2, HUB_GET_DESCRIPTOR, HUB_SET_DESCRIPTOR
'------------------------------------------------------------------------------
' Standard Feature Selectors (Section 9.4, Table 9-6):
'------------------------------------------------------------------------------
        #0, ENDPOINT_HALT, DEV_REMOTE_WAKEUP
'------------------------------------------------------------------------------
' Hub Class Feature Selectors (Section 11.24.2, Table 11-17):
'------------------------------------------------------------------------------
        #0, C_HUB_LOCAL_POWER, C_HUB_OVER_CURRENT
        #0, PORT_CONNECTION, PORT_ENABLE, PORT_SUSPEND, PORT_OVER_CURRENT, PORT_RESET
        #8, PORT_POWER, PORT_LOW_SPEED
        #16, C_PORT_CONNECTION, C_PORT_ENABLE, C_PORT_SUSPEND, C_PORT_OVERCURRENT
        C_PORT_RESET, PORT_TEST, PORT_INDICATOR
'------------------------------------------------------------------------------
' Standard descriptor types (Section 9.4, Table 9-5):
'------------------------------------------------------------------------------
        #$01, TYPE_DEVICE, TYPE_CONFIG, TYPE_STRING, TYPE_INTERFACE, TYPE_ENDPOINT
        TYPE_QUALIFIER, TYPE_OTHER_SPEED, TYPE_INTERFACE_PWR, TYPE_OTG
        TYPE_HUB = $29
'------------------------------------------------------------------------------
' Device/Interface Class Codes (full list at www.usb.org/developers/defined_class):
'------------------------------------------------------------------------------
        #$00, CLASS_INFO_INTF, CLASS_AUDIO, CLASS_COMM, CLASS_HID, CLASS_UNDEF0
        CLASS_PHYSICAL, CLASS_IMAGE, CLASS_PRINTER, CLASS_MASS_STORAGE, CLASS_HUB
        CLASS_CDC_DATA, CLASS_SMARTCARD, CLASS_UNDEF1, CLASS_CONT_SECURITY, CLASS_VIDEO
        CLASS_HEALTH, CLASS_AUDIO_VIDEO, CLASS_BILLBOARD, CLASS_TYPE_C_BRIDGE
        CLASS_DIAGNOSTIC_DEV  = $dc
        CLASS_WIRELESS_CTRL   = $e0
        CLASS_MISCELLANEOUS   = $ef
        CLASS_APP_SPECIFIC    = $fe
        CLASS_VENDOR_SPECIFIC = $ff
'------------------------------------------------------------------------------
' Mass Storage Subclass Codes
'------------------------------------------------------------------------------
        #$00, SUBCLASS_SCSI_CMD_NOT_REPORTED, SUBCLASS_RBC, SUBCLASS_MMC_5_ATAPI
        SUBCLASS_OBSOLETE0, SUBCLASS_UFI, SUBCLASS_OBSOLETE1, SUBCLASS_SCSI_CMD
        SUBCLASS_LSD_FS, SUBCLASS_IEEE_1667 ' $09 - $FE reserved
        #$ff, SUBCLASS_VENDOR_SPECIFIC
'------------------------------------------------------------------------------
' Mass Storage Interface Protocols
'------------------------------------------------------------------------------
        #$00, PROTO_CBI_CCI, PROTO_CBI_NO_CCI, PROTO_OBSOLETE0 ' $03 - $4f reserved
        #$50, PROTO_BULK_ONLY ' $51 - $61 reserved
        #$62, PROTO_UAS ' $63 - $fe reserved
        #$ff, PROTO_VENDOR_SPECIFIC
'------------------------------------------------------------------------------
' Mass Storage Endpoint Descriptor bitmasks and constants
'------------------------------------------------------------------------------
        ENDP_NUM_MASK  = %0000_1111    ' Bits 3..0 determine endpoint number
        ENDP_DIR_MASK  = %1_0000000    ' 1 = IN, 0 = OUT transfer direction
        ENDP_ATTR_BULK = %000000_1_0   ' Bit 1 set if it's a bulk endpoint
        BBB_INTF_MATCH = 4             ' Count of interface data elements to match
'------------------------------------------------------------------------------
' Mass Storage Class Requests:
'------------------------------------------------------------------------------
        #$00, MS_GET_STATUS
        #$fc, MS_GET_REQUESTS, MS_PUT_REUESTS, MS_GET_MAX_LUN, MS_BOMS_RESET
'------------------------------------------------------------------------------
' HID Class Requests (v1.11 HID Device Class Definition, Section 7.2):
'------------------------------------------------------------------------------
        #$01, HID_GET_REPORT, HID_GET_IDLE, HID_GET_PROTO[6] ' $04 - $08 reserved
        HID_SET_REPORT, HID_SET_IDLE, HID_SET_PROTO
' HID Descriptor types:
        #$21, TYPE_HID, TYPE_REPORT, TYPE_PHYSICAL ' HID types $24 - $2f are reserved
'------------------------------------------------------------------------------
' HID report types (v1.11 HID Device Class Definition, Section 7.2.1):
'------------------------------------------------------------------------------
        #$01, TYPE_INPUT, TYPE_OUTPUT, TYPE_FEATURE ' $04 - $ff are reserved
'------------------------------------------------------------------------------
' HID Interface SubClasses:
'------------------------------------------------------------------------------
        #$00, SUBCLASS_INTF_NONE, SUBCLASS_INTF_BOOT
'------------------------------------------------------------------------------
' HID Protocol codes:
'------------------------------------------------------------------------------
        #$00, INTF_PROTO_NONE, INTF_PROTO_KBD, INTF_PROTO_MOUSE
        #$00, BOOT_PROTOCOL, REPORT_PROTOCOL
'------------------------------------------------------------------------------
' Other HID buffer lengths:
'------------------------------------------------------------------------------
        MAX_HID_REPTS   = 4             ' We have this many HID report buffers
        REPT_BUFF_LEN   = 1024          ' HID reports can be quite large
        REPT_STRUCT_LEN = REPT_BUFF_LEN + 2 ' Struct is wLength, bData[REPT_BUFF_LEN]
        LANG_BUFF_LEN   = 128           ' LangID array buffer (in bytes)
        USTR_BUFF_LEN   = 128           ' Unicode string buffer (in bytes)
'------------------------------------------------------------------------------
' USB-IF defined language IDs (http://www.usb.org/developers/docs.html)
'------------------------------------------------------------------------------
        LANG_ENG_US  = $0409            ' English (United States)
        LOCAL_LANGID = LANG_ENG_US      ' Set your default langID here
'------------------------------------------------------------------------------
' SETUP structure member offsets.
' NOTE: These offsets are defined in terms of the structure member's data type,
'       to take advantage of PTRA/B scaled indexing, e.g.:
'         RDBYTE D,   PTRA[bRequest]
'         WRWORD D/#, PTRA[wLength]
'------------------------------------------------------------------------------
        bmRequestType = 0
        bRequest      = 1
        wValue        = 1
        wIndex        = 2
        wLength       = 3
' SETUP bmRequestType combinations:
{
        HTD_STD_DEV = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
        DTH_STD_DEV = (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
        HTD_STD_INT = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_INTERFACE)
        HTD_STD_EP  = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_ENDPOINT)
}
'------------------------------------------------------------------------------
' Standard USB descriptor structure sizes in bytes. The values defined are the
' minimum size of the descriptor:
'------------------------------------------------------------------------------
        SETUP_TXN_LEN = 8
        DEV_DESC_LEN  = 18
        CON_DESC_LEN  = 9
        INTF_DESC_LEN = 9
        ENDP_DESC_LEN = 7
        STR0_DESC_LEN = 4
        USTR_DESC_LEN = 4
'------------------------------------------------------------------------------
' Other USB-related buffer sizes:
'------------------------------------------------------------------------------
        URX_BUFF_LEN = 128      ' USB receiver scratch buffer
        CON_BUFF_LEN = 256      ' Entire configuration descriptor chain
'------------------------------------------------------------------------------
' CON_bmAttrs member bit positions:
'------------------------------------------------------------------------------
        ATTR_RESVB     = 7      ' Reserved (should always be one)
        ATTR_SELF_PWRB = 6      ' Device Self-Powered
        ATTR_RMT_WAKEB = 5      ' Supports remote wakeup
'       bmAttributes bits 4..0 reserved and reset to zero
'------------------------------------------------------------------------------
' Standard USB descriptor struct member offset and member size, in bytes. Note
' that the DESC_bLength and DESC_bDescType members are defined in all of the
' descriptors (including HID) at the offsets shown.
'------------------+
' !!! IMPORTANT !!!|
'------------------+
' All standard descriptor member offsets are defined in bytes, so if you want
' to use PTRA/B indexing for WORD or LONG data, the unscaled PTRx[##index20]
' syntax should be used and the compiler will invoke AUGS with RDxxxx/WRxxxx,
' e.g.: RDBYTE D,   PTRA[DEV_bMaxPktSize0] is OK when it's a byte member
'       WRWORD D/#, PTRA[##DEV_bIdProduct] use unscaled if member is word/long.
' It goes without saying that if PTRA/B unscaled indexing is used with pre/post
' increment/decrement, one must be very careful...
'------------------------------------------------------------------------------
'       Member          Offset  Size    Value           Description
'------------------------------------------------------------------------------
        DESC_bLength     = 0    ' 1     Number          Minimum size of this descriptor in bytes
        DESC_bDescType   = 1    ' 1     Constant        TYPE_DEVICE
' Device Descriptor (Section 9.6.1, Table 9-8):
        DEV_bcdUSB       = 2    ' 2     BCD             e.g., 2.10 is $0210
        DEV_bDevClass    = 4    ' 1     Class           Class code assigned by USB-IF.
        DEV_bDevSubClass = 5    ' 1     SubClass        SubClass Code assigned by USB-IF.
        DEV_bProtocol    = 6    ' 1     Protocol        Protocol Code assigned by USB-IF.
        DEV_bMaxPktSize0 = 7    ' 1     Number          Max packet size for endpoint 0. Must be 8 for LS, 16, 32 or 64 for FS.
        DEV_idVendor     = 8    ' 2     ID              Vendor ID - must be obtained from USB-IF.
        DEV_idProduct    = 10   ' 2     ID              PRoduct ID - must be obtained from USB-IF.
        DEV_bcdDevice    = 12   ' 2     BCD             Device release number in BCD.
        DEV_iMfg         = 14   ' 1     Index           Index of string descriptor describing manufacturer - set to zero if no string.
        DEV_iProduct     = 15   ' 1     Index           Index of string descriptor describing product - set to zero if no string.
        DEV_iSerialNum   = 16   ' 1     Index           Index of string descriptor describing device serial number - set to zero if no string.
        DEV_iNumConfigs  = 17   ' 1     Number          Number of possible configurations.
' Configuration Descriptor (Section 9.6.3, Table 9-10):
'       DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'       DESC_bDescType   = 1    ' 1     Constant        TYPE_CONFIG
        CON_wTotalLen    = 2    ' 2     Number          See Section 9.6.3, Table 9-10.
        CON_bNumIntf     = 4    ' 1     Number          Number of interfaces supported by this configuration.
        CON_bConfigVal   = 5    ' 1     Number          Value to use as an argument to the SetConfiguration() request to select this configuration.
        CON_iConfig      = 6    ' 1     Index           Index of string descriptor describing this configuration.
        CON_bmAttrs      = 7    ' 1     Bitmap          See Table 9-10.
        CON_bMaxPower    = 8    ' 1     mA              Expressed in 2MA units (i.e. 50 = 100 mA)
' Interface Descriptor (Section 9.6.5, Table 9-12):
'       DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'       DESC_bDescType   = 1    ' 1     Constant        TYPE_INTERFACE
        INTF_bIntfNum    = 2    ' 1     Number          See Table 9-12.
        INTF_bAltSetting = 3    ' 1     Number          Value used to select this alternate setting for the interface identified in the prior field.
        INTF_bNumEndpts  = 4    ' 1     Number          See Table 9-12.
        INTF_bIntfClass  = 5    ' 1     Class           Class code (assigned by USB-IF). If this field is 0xFF, the interface class is vendor-specific.
        INTF_bSubClass   = 6    ' 1     SubClass        Subclass code (assigned by USB-IF). These codes are qualified by the value of the
                                '                       bIntfClass field. If the bInterfaceClass field is not set to 0xFF, all values are
                                '                       reserved for assignment by the USB-IF.
        INTF_bProtocol   = 7    ' 1     Protocol        Protocol code (assigned by the USB). These codes are qualified by the value of the
                                '                       bIntfClass and the bSubClass fields. If this field is set to 0xFF, the device uses a
                                '                       vendor-specific protocol for this interface.
        INTF_iInterface  = 8    ' 1     Index           Index of string descriptor describing this interface.
' Endpoint Descriptor (Section 9.6.6, Table 9-13):
'       DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'       DESC_bDescType   = 1    ' 1     Constant        TYPE_ENDPOINT
        ENDP_bAddress    = 2    ' 1     Endpoint        See table 9-13.
        ENDP_bmAttrs     = 3    ' 1     Bitmap
        ENDP_wMaxPktSize = 4    ' 2     Number
        ENDP_bInterval   = 6    ' 1     Number
' String Descriptor Zero (Section 9.6.7, Table 9-15):
'       DESC_bLength     = 0    ' 1     N + 2
'       DESC_bDescType   = 1    ' 1     Constant
        STR0_wLangID     = 2    ' N     LangID[(N - 2) / 2]
' Unicode String Descriptor (Section 9.6.7, Table 9-16):
'       DESC_bLength     = 0    ' 1     N + 2
'       DESC_bDescType   = 1    ' 1     Constant
        USTR_wString     = 2    ' N     wString[(N - 2) / 2]
' Hub Descriptor (Section 11.23.2.1, Table 11-13):
'       DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'       DESC_bDescType   = 1    ' 1     Constant        TYPE_HUB ($29)
        HUB_bNbrPorts    = 2    ' 1     Number          Number of downstream facing ports that this hub supports
        HUB_wProperties  = 3    ' 2     Bitmask
        HUB_bPwrOn2Good  = 5    ' 1     Number          Time (in 2ms intervals) to wait before accessing a powered-on port
        HUB_CntrlCurrent = 6    ' 1     Number          Maximum current requirements of the controller in mA.
        HUB_DevRemovable = 7    ' *     Variable        Byte-granularity field to indicate if a port has a removable device
' 0B = device removable, 1B = non-removable
' Bit0 Reserved for future use, bit1: port1, bit2: port2, bitN: portN, up to a max of 255 ports
'       HUB_PortPwrMask  = *    ' *     Variable        This field exists for compatibility with v1.0 compliant devices
' All bits should be set to 1B. One bit for each port, with pad bits to make the number of bits a multiple of 8.
' HID Descriptor (Section 6.2.1)
'       DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'       DESC_bDescType   = 1    ' 1     Constant        TYPE_HID ($21)
        HID_bcdHID       = 2    ' 2     BCD             e.g., 1.10 is $0110
        HID_bCountryCode = 4    ' 1     Number          Hardware target country
        HID_bNumDesc     = 5    ' 1     Number          Number of HID class descriptors to follow, always at least one
        HID_bDescType    = 6    ' 1     Constant        Type of HID class descriptor e.g. TYPE_REPORT ($22)
        HID_wDescLength  = 7    ' 2     Number          Total length of descriptor(s)
' #endregion Con (USB Descriptor Definitions)
' #region DAT (Hub RAM Strings & Buffers)
dat
                orgh
' Static data:
'button_list             byte    PB1, PB2, PB3, 0        ' Prop123-A9 pushbuttons in use
' /* Startup splash text:
dcog_started            byte    "USB low/full speed minimal host & bulk-only mass storage driver v0.03.", 0
sz_verbose_opt          byte    "Debug output to terminal is ", 0
sz_unused_opt           byte    "Unused toggle state is ", 0
sz_off                  byte    "off.", 0
sz_on                   byte    "on.", 0
sz_set                  byte    "set.", 0
sz_cleared              byte    "cleared.", 0
sz_notfound             byte    "not found.", 0
sz_0x                   byte    "0x", 0
sz_0b                   byte    "0b", 0
sz_unknown_data         byte    " Data:", 0
sz_vt100_cls            byte    ESC, "[2J", ESC, "[H", 0
sz_vt100_set_cursor     byte    ESC, "[999;999f", 0
sz_vt100_query_curpos   byte    ESC, "[6n", 0
sz_vt100_save_cursor    byte    ESC, "[s", 0
sz_vt100_unsave_cursor  byte    ESC, "[u", 0
sz_whitespace           byte    " ", TAB, CR, LF, VT, FF, 0 
' */
' /* Status messages:
sz_fullspeed            byte    "<Full-Speed device connected.>", 0
sz_lowspeed             byte    "<Low-Speed device connected.>", 0
sz_disconnect           byte    "<Device disconnected>.", 0
sz_generic_result       byte    "Transaction result: ", 0
sz_getdev_result        byte    "GetDescriptor(TYPE_DEVICE): ", 0
sz_getconf_result       byte    "GetDescriptor(TYPE_CONFIG): ", 0
sz_setaddr_result       byte    "SetAddress(): ", 0
sz_getrpt_result        byte    "GetDescriptor(TYPE_REPORT): ", 0
sz_getstr_result        byte    "GetDescriptor(TYPE_STRING): ", 0
sz_setcon_result        byte    "SetConfiguration(): ", 0
sz_setprot_result       byte    "SetProtocol(): ", 0
sz_ctrlread_result      byte    "ControlRead(): ", 0
sz_ctrlwrite_result     byte    "ControlWrite(): ", 0
sz_clr_endp_result      byte    "ClearFeature(ENDPOINT_HALT): ", 0
sz_datain_result        byte    "DataIN(): ", 0
sz_dataout_result       byte    "DataOUT(): ", 0
sz_setrept_output       byte    "SetReport(TYPE_OUTPUT): ", 0
sz_success              byte    "Success!", 0
sz_fail                 byte    "Fail!", 0
sz_wait_timeout         byte    "Wait timeout expired.", 0
sz_bummer               byte    "Bummer! I don't know what to do with this device.", 0
sz_txn_err              byte    "Error ", 0
sz_omit_strs            byte    "The device offers no string descriptors.", 0
sz_ack                  byte    "ACK", 0
sz_nak                  byte    "NAK", 0
sz_stall                byte    "STALL", 0
sz_colon_space          byte    ": ", 0
sz_comma_space          byte    ", ", 0
sz_nak_count            byte    "[IN-NAK]: ", 0
sz_woohoo_msd           byte    "Woo-hoo! Mass storage device configured.", 0
sz_kbd_ready            byte    "Keyboard ready...", 0
sz_kbd_leds             byte    "LED bits: 0b", 0
sz_kbd_data             byte    "Kbd Data: ", 0
sz_woohoo_mouse         byte    "Woo-hoo, found a boot mouse!", 0
sz_mouse_ready          byte    "Mouse ready...", 0
sz_mouse_hdrd0          byte    "Count: ", 0
sz_mouse_hdrd1          byte    ", Buttons: ", 0
sz_mouse_hdr0           byte    ", Buttons: ", 0
sz_mouse_hdr1           byte    ", X: ", 0
sz_mouse_hdr2           byte    ", Y: ", 0
sz_mouse_hdr3           byte    ", Device specific: ", 0
sz_task_end             byte    "Task routine return...", 0
sz_devent_end           byte    "Driver event routine return...", 0
' */
' /* Host and other debug stuff
'sz_stathdr              byte    CR, "NeES10KJ  Data", CR, 0
'sz_stat                 byte    CR, "USB Status: ", 0
sz_host_stopped         byte    "!!Host has stopped!!", 0
sz_dbg_data             byte    "Debug Data: ", 0
sz_breakh               byte    "Debug Break (Host): $", 0
sz_breakd               byte    "Debug Value (Driver): $", 0
sz_stack_addr           byte    "HWStack return address: ", 0
' */
' /* Error code descriptions (indexed 0..n):
sz_err_none             byte    "The operation completed successfully.", 0
sz_err_urx              byte    "Bit unstuff error, EOP or SE0 > 3 bit-times or SE1.", 0
sz_err_se1              byte    "!USB in illegal SE1 state!", 0
sz_err_packet           byte    "Packet missing or corrupt.", 0
sz_err_tat              byte    "Bus turn-around time exceeded.", 0
sz_err_txn_retry        byte    "Retry limit exceeded, transaction canceled.", 0
sz_err_xfer_retry       byte    "Retry limit exceeded, transfer canceled.", 0
sz_err_nak              byte    "NAK retry limit exceeded.", 0
sz_err_ack_retry        byte    "IN DATAx sync recovery.", 0
sz_err_empty_pkt        byte    "Unexpected empty packet.", 0
sz_err_rx_crc           byte    "Rx CRC16 error.", 0
sz_err_datax_sync       byte    "DATAx sync error.", 0
' String pointer table for error code descriptions:
err_code_text           long    sz_err_none, sz_err_urx, sz_err_se1, sz_err_packet
                        long    sz_err_tat, sz_err_txn_retry, sz_err_xfer_retry
                        long    sz_err_nak, sz_err_ack_retry, sz_err_empty_pkt
                        long    sz_err_rx_crc, sz_err_datax_sync
' */
' #region Partially populated SETUP/descriptor packets
get_dev_desc            byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
                        byte    REQ_GET_DESC
                        word    TYPE_DEVICE << 8
                        word    0       ' Zero or Language ID (Section 9.6.7)
                        word    0       ' Number of bytes to transfer if there is a data stage
get_config_desc         byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
                        byte    REQ_GET_DESC
                        word    TYPE_CONFIG << 8
                        word    0       ' Zero or Language ID (Section 9.6.7)
                        word    0       ' Number of bytes to transfer if there is a data stage
set_config              byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
                        byte    REQ_SET_CONFIG
                        word    0       ' Configuration value
                        word    0       ' Zero
                        word    0       ' Zero, as REQ_SET_CONFIG has no data stage
set_address             byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
                        byte    REQ_SET_ADDR
                        word    0       ' Zero
                        word    0       ' Zero
                        word    0       ' Zero, as REQ_SET_ADDR has no data stage
' Clear Endpoint Feature
req_clear_endpoint
                        byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_ENDPOINT)
                        byte    REQ_CLEAR_FEATURE
                        word    ENDPOINT_HALT
                        word    0               ' IN/OUT endpoint address to clear
                        word    0               ' No data stage
' Bulk-Only Mass Storage Reset Request
req_boms_reset
                        byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                        byte    MS_BOMS_RESET
                        word    0
                        word    0               ' Device interface index
                        word    0
' Mass Storage Get Max LUN Request
req_max_lun
                        byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_INTERFACE)
                        byte    MS_GET_MAX_LUN
                        word    0
                        word    0               ' Device interface index
                        word    1               ' One byte expected in data stage
' Mass Storage Get Status Request?
msd_dev_status          byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_OTHER)
                        byte    MS_GET_STATUS
                        word    0       ' Zero
                        word    0       ' Endpoint address without direction flag?
                        word    4       ' Expected status bytes to receive
' #endregion Partially populated SETUP/descriptor packets
' #region Mass storage constants
con
'------------------------------------------------------------------------------
' Info for the currently connected mass storage device (cog reg msd_status):
'------------------------------------------------------------------------------
' |  PQ_PDT  |RM_VERSION|  OUT EP   |   IN EP   |
' +----------+----------+-----------+-----------+
' |%xxx_xxxxx|%x_xxxxxxx|%0_000_xxxx|%1_000_xxxx|
' +----------+----------+-----------+-----------+
' Bitmasks:
                STAT_PQ  = INQ_PQ << 24
                STAT_PDT = INQ_PDT << 24
' Bitflag positions:
        #23, STAT_RMB
' Bitflags:
        STAT_RMF = |< STAT_RMB
'------------------------------------------------------------------------------
' The host/driver hub RAM interface parameter block structure used for IN/OUT
' data transfers. The member offsets assume hub RD/WR PTRA/B indexing:
' b = RDBYTE/WRBYTE, w = RDWORD/WRWORD, l = RDLONG/WRLONG
'------------------------------------------------------------------------------
                lUSB_TOKEN_PKT   = 0            ' Standard USB CRC5|ENDP|ADDR|PID token packet
                lUSB_MAX_PKT     = 1            ' IN/OUT packet maximum size
                lUSB_TOTAL_BYTES = 2            ' Total IN/OUT bytes expected for the transfer
                lUSB_NEXT_DATAX  = 3            ' DATA0/DATA1 synchronization token to use to start the IN/OUT transfer
                lUSB_BUFF_PTR    = 4            ' Hub RAM pointer to the IN/OUT buffer sized to handle lUSB_TOTAL_BYTES
' Count of longs in the hub RAM IN/OUT interface parameter block:
                UIO_PARAMS_READ  = 5 - 1        ' IN/OUT parameter longs for SETQ (n - 1) hub->reg fast block move
                UIO_PARAMS_WRITE = 2 - 1        ' Only the first two parameters are modified by the host
'------------------------------------------------------------------------------
' Mass Storage Constants
'------------------------------------------------------------------------------
                CBWSignature = (("C" << 24) | ("B" << 16) | ("S" << 8) | "U")   ' Command Block Wrapper signature
                CSWSignature = (("S" << 24) | ("B" << 16) | ("S" << 8) | "U")   ' Command Status Wrapper signature
                BULKIO_DIRB  = 7                ' bmCBWFlags bit 7 is transfer direction (1 = IN)
                BULK_DIR_IN  = %1_0_000000      ' Bit 6 is obsolete and must be zero
                BULK_DIR_OUT = %0_0_000000      ' Bits 5..0 are reserved and must be zero
' Fixed packet sizes
                CBW_SIZE            = $1f       ' Command Block Wrapper size is always 31 bytes
                CBWCB_LENGTH        = $10       ' Size of the command block buffer
                CSW_SIZE            = $0d       ' Command Status Wrapper structure size
' Command Descriptor Block CONTROL field bitmask:
' The NACA (Norrmal ACA) bit specifies whether an auto contingent allegiance (ACA)
' is established if the command returns with CHECK CONDITION status. An NACA bit
' set to zero specifies that an ACA shall not be established.
                CDB_CONTROL_VS      = %11_000_0_00 ' Vendor specific
                CDB_CONTROL_NACA    = %00_000_1_00 ' Normal ACA (NACA) bit
' SCSI command codes:
                CMD_READ6           = $08
                CMD_REPORT_LUNS     = $a0
                CMD_WRITE6          = $0a
' Command Block Wrapper structure offsets assume hub RD/WR PTRA/B indexing:
' b = RDBYTE/WRBYTE, w = RDWORD/WRWORD, l = RDLONG/WRLONG
                lCBWSignature       = 0
                lCBWTag             = 1
                lCBWDataXferLen     = 2
                bmCBWFlags          = 12
                bCBWLUN             = 13
                bCBWCBLen           = 14
                bCBWCB              = 15
' Command Status Wrapper constants:
                CSW_VALID_LEN       = 13        ' CSW must always be this length to be considered valid
' Command Status Wrapper structure offsets assume hub RD/WR PTRA/B indexing:
' b = RDBYTE/WRBYTE, dw = RDWORD/WRWORD, l = RDLONG/WRLONG
                lCSWSignature       = 0
                lCSWTag             = 1
                lCSWDataResidue     = 2
                bCSWStatus          = 12
' Command Block Status values:
                CBS_CMD_PASSED      = $00       ' NOTE: if a non-zero code is returned, the class driver should
                CBS_CMD_FAILED      = $01       ' execute a MODE SENSE command to retrieve error details
                CBS_PHASE_ERROR     = $02
' Anything above $02 is reserved in the USB Bulk-Only spec, so use them for our own purposes
                CBS_CSW_SIZE_ERROR  = $03       ' CSW was not the correct size
                CBS_BAD_SIGNATURE   = $04       ' CSW signature was not correct
                CBS_TAG_MISMATCH    = $05       ' CSW tag didn't match the CBW tag
                CBS_RESIDUE_ERROR   = $06       ' CSW residue greater than the CBW transfer length value
'               03h and 04h reserved (obsolete)
'               05h - ffh reserved
'------------------------------------------------------------------------------
' Command Block field size and parameter offsets for SCSI commands. Offset zero
' of the block is the bCBWCB address of the CBW. The SCSI command opcode is
' always the first field byte.
                bSCSI_Cmd           = 0
'------------------------------------------------------------------------------
' INQUIRY:
                CMD_INQUIRY         = $12
                INQUIRY_CBLEN       = 6                 ' Size of INQUIRY parameter field
' CBW bitmasks:
                INQ_CMDDT           = %000000_1_0       ' Command Support Data (CMDDT), obsolete
                INQ_EVPD            = %000000_0_1       ' Enable Vital Product Data (EVPD)
' CBW field offsets;
                bmINQ_EVPD          = 1                 ' EVPD clear, return standard data
                bINQ_PageCode       = 2                 ' EVPD set, page code field specifies data to return
                bINQ_AllocLen       = 4                 ' Total IN data bytes expected
              ' CONTROL             = 5
' Response data lengths used:
                STD_INQ_LEN         = $24               ' Minimum stnadard INQUIRY data struct size
                EXT_INQ_LEN         = $60               ' Maximum standard INQUIRY data struct size
              ' Fields 96..n                            ' Vendor specific information
                MAX_INQ_LEN         = $ff               ' Struct can never be larger than this
' ASCII data field lengths:
                INQ_VENDOR_ID_LEN   = 8                 ' Identifies the vendor of the product
                INQ_PRODUCT_ID_LEN  = 16                ' Defined by the vendor
                INQ_VERSION_REV_LEN = 4                 ' Defined by the vendor
' Standard INQUIRY response bitmasks:
                INQ_PQ              = %111_00000        ' Peripheral Qualifier
                INQ_PDT             = %000_11111        ' Peripheral Device Type (PDT)
                INQ_RMB             = %1_0000000        ' Removable media flag. Bits 6..0 reserved (always zero)
                INQ_RDF             = %0000_1111        ' Response Data Format (RDF)
' Vital Product Data (VPD) codes of interest:
                VPD_SUPPORTED_PAGES = $00
                VPD_SERIAL_NUM      = $80
                VPD_EXTENDED_DATA   = $86
' Standard INQUIRY response offsets:
' Peripheral Qualifier (PQ) field values:
' %000: The specified peripheral device type is currently connected to this logical unit. If the device
'       server cannot determine whether or not a physical device is currently connected, it also shall
'       use this peripheral qualifier when returning the INQUIRY data. This peripheral qualifier does
'       not mean that the device is ready for access by the initiator.
' %001: The device server is capable of supporting the specified peripheral device type on this logical
'       unit. However, the physical device is not currently connected to this logical unit.
' %010: Reserved
' %011: The device server is not capable of supporting a physical device on this logical unit. For this
'       peripheral qualifier the peripheral device type shall be set to 1Fh to provide compatibility
'       with previous versions of SCSI. All other peripheral device type values are reserved for this
'       peripheral qualifier.
' %1xx: Vendor-specific.
'------------------------------------
' Peripheral Qualifier (PQ) bit field:
' %000: a device is connected to this logical unit.
' Peripheral Device Type (PDT) bit field:
' $00:  Direct access block device (e.g. magnetic disk). The only device type we're interested in.
' $01..$1f: Other device type codes or reverved values.
                bmInq_PQ_PDT        = 0
                bmInq_RMB           = 1                 ' If RMB flag (bit 7) set, media is removable, bits 6..0 reserved
                bmInqVersion        = 2                 ' This driver should support values 3..7 and probably 0..2
                bmInqRDF            = 3                 ' Response Data Format should = 2, values < 2 are obsolete
                bInqAddedLen        = 4                 ' Set to response total length - 5, e.g. $1f if returning $24 bytes
                bInqVendorID        = 8                 ' 8-byte field (MSB->LSB)
                bInqProductID       = 15                ' 16-byte field (MSB->LSB)
                bInqProductRev      = 32                ' 4-byte field (MSB->LSB)
' Extended INQUIRY response offsets:
                bInqDriveSerNum     = 36                ' 4-byte field (MSB->LSB)
'------------------------------------------------------------------------------
' MODE SELECT(6)
                CMD_MODE_SELECT6    = $15
                MODE_SELECT6_CBLEN  = $06
'------------------------------------------------------------------------------
' MODE SENSE(6) provides a means for a device server to report parameters to an
' application client. It is a complementary command to the MODE SELECT (6)
' command.
                CMD_MODE_SENSE6     = $1a
                MODE_SENSE6_CBLEN   = $06
' CBW bitmasks:
                MSENSE_DBD          = %0000_1_000       ' bmDBD, zero = return block descs in response, one = no block descs
                MSENSE_PAGE_CTRL    = %11_000000        ' bmPC_PageCode
' Mask values:
                CTRL_CURRENT        = %00_000000
                CTRL_CHANGEABLE     = %01_000000
                CTRL_DEFAULT        = %10_000000
                CTRL_SAVED          = %11_000000
                MSENSE_PAGECODE     = %00_111111        ' bmPC_PageCode
' Page codes of interest:
                MSENS_PC_FDMP       = $05               ' Flexible disk mode page (FDMP)
                MSENS_PC_Cache      = $08               ' Defines parameters that relate to device's use of cache
                MSENS_PC_InfoExept  = $1c               ' Informational Exceptions Control
                MSENS_PC_AllPages   = $3f               ' All supported mode pages
' CWB parameter offsets:
                bmMSENS_DBD         = 1
                bmMSENS_PC_PageCode = 2
                bMSENS_SubpageCode  = 3
                bMSENS_AllocLen     = 4
              ' CONTROL             = 5
' Response header bDevSpecificParms bitmasks:
                DSP_WP              = %1_00_0_0000      ' Set if the media is write-protected
                DSP_EPOFUA          = %0_00_1_0000      ' Set if the device supports DBP and FUA bits (used in caching)
' Response header fixed offsets:
                bModeDataLen        = 0         ' Number of bytes that follow
                bMediumType         = 1         ' $00 for SBC devices
                bDevSpecificParms   = 2         ' See above bitmasks
                bBlockDescLen       = 3         ' Length in bytes of all block descriptors in the mode parameter list
'------------------------------------------------------------------------------
' READ(10):
                CMD_READ10          = $28
                READ10_CBLEN        = $0a
' CBW bitmasks:
                RDPROTECT           = %111_0_0_0_00
                DPO                 = %000_1_0_0_00
                FUA                 = %000_0_1_0_00
                RARC                = %000_0_0_1_00
' CBW parameter offsets:
                bmRD10_RDProtect    = 1
                bRD10_LBAddr        = 2         ' 4-byte field, big endian
                bmRD10_GroupNumber  = 6
                bRD10TransferLen    = 7         ' 2-byte field, big endian
              ' CONTROL             = 9
'------------------------------------------------------------------------------
' READ CAPACITY(10):
                CMD_READ_CAPACITY10 = $25
                RD_CAP10_CBLEN      = $0a
                RD_CAP10_DATA_LEN   = $08       ' Expected IN data length is always this
' CBW parameter offsets:
              ' bAlwaysZero         = 1
              ' bAlwaysZero         = 2         ' 4-byte field, big endian
              ' bAlwaysZero         = 6         ' 2-byte field
              ' bAlwaysZero         = 8
              ' CONTROL             = 9
' Response parameter data:
                lLastLBA            = 0         ' Returned logical block address, big endian
                lBlockLengthBytes   = 1
'------------------------------------------------------------------------------
' READ FORMAT CAPACITIES:
                CMD_RDFMTCAPS       = $23       ' This is a Multimedia Command (MMC)
                RDFMTCAPS_CBLEN     = $0a
                RDFMTCAPS_DATA_MIN  = $0c
                RDFMTCAPS_DATA_MAX  = $fc
' CBW parameter offsets:
              ' Bytes 1..6 reserved, must be zero
                bRFCap_AllocLen     = 7         ' 2-byte field, big endian
              ' Control             = 9
' Response bitmasks:
                RFC_DESC_TYPE       = %000000_11
' Descriptor types:
                DT_RESERVED         = %00
                DT_UNFORMATTED      = $01       ' Reported value is for the max formatted capacity for this media
                DT_FORMATTED        = $10       ' Reported value is the current media's capacity
                DT_NO_MEDIA         = $11       ' No media Present. Reported value is for max capacity of a media
                                                ' that the logical unit is capable of reading
' Response Capacity List Header:
              ' Bytes 0..2 reserved, must be zero
                bCapListLength      = 3         ' Specifies length of Capacity Descriptors to follow
' Each Capacity Descriptor is 8 bytes in length, making bCapListLength equal to 8 x number of descriptors.
' Values of n * 8 are valid, where 0 < n < 32.
                bCapNumBlocks       = 4         ' 4-byte field, big endian, number of blocks
                lCapNumBlocks       = 1
                bmCapDescType       = 8         ' Indicates the type of information the descriptor contains
                bCapBlockLength     = 9         ' 3-byte field, big endian, length in bytes of each logical block
                lDescTypeBlockLen   = 2
              ' Offset 12..n remainder of descriptors
'------------------------------------------------------------------------------
' REQUEST SENSE requests that the device server transfer sense data to the
' application client:
                CMD_REQUEST_SENSE   = $03
                REQ_SENSE_CBLEN     = $06
' Fixed format data structure length:
                SENSE_DATA_MIN_LEN  = $12       ' Sense data structure base size
                SENSE_DATA_MAX_LEN  = $fc       ' May be as long as this with "additional" data
' CWB bitmasks:
                SENSE_DESC_FORMAT   = %0000000_1 ' If cleared, fixed format sense data shall be returned.
                                                 ' If set and descriptor format sense data is supported, return descriptor
' CWB parameter offsets:
                bmRQSENS_DescFormat = 1         ' Bits 7..1 always zero
                wRQSENS_RS_Reserved = 2         ' 2-byte field, always zero
                bRQSENS_AllocLen    = 4         ' Class driver should request 252 bytes to ensure all sense data is retrieved
              ' CONTROL             = 5
' Response fields:
' Bit masks:
                SENSE_VALID_FLAG    = %1_0000000
                SENSE_RESPONSE_MASK = %0_1111111
                SENSE_RESPONSE_70h  = %0_1110000
                SENSE_RESPONSE_71h  = %0_1110001
                SENSE_FILEMARK      = %1_0_0_0_0000     ' Filemark (sequential-access devices)
                SENSE_EOM           = %0_1_0_0_0000     ' End-of-medium (sequential access and printers)
                SENSE_ILI           = %0_0_1_0_0000     ' Incorrect length indicator, set indicates requested logical block
                                                        ' length != actual logical block length of the data on the medium
                SENSE_RESERVED      = %0_0_0_0_0000     ' Always cleared
                SENSE_KEY_MASK      = %0_0_0_0_1111     '
                SENSE_SKSV          = %1_0000000
' Data field offsets, in bytes:
                bmValid_Response    = 0
                bSenseObsolete      = 1
                bmF_E_I_R_SK        = 2         ' Sense Key resides here (SK)
                bSenseInfo          = 3         ' Big endian long
                bAdditionalData     = 7         ' Additional sense data (n-7)
                bSenseCmdInfo       = 8         ' Big endian long
                lSenseCmdInfo       = 2         ' Sense Command Information
                bASC                = 12        ' Additional Sense Code
                bASCQ               = 13        ' Additional Sense Code Qualifier
                wASC_ASCQ           = 6
                bFRUC               = 14        ' Field Replaceable Unit Code
                bSKSV               = 15        ' Bit 23 of SenseKeySpecific
                bSenseKeySpecfic    = 15        ' Bits 22..0, big endian
                bAdditionalBytes    = 18        ' Additional bytes (18..n), MSB->LSB
' Sense keys:
                S_NO_SENSE          = $00
                S_RECOVERED_ERROR   = $01
                S_NOT_READY         = $02
                S_MEDIUM_ERROR      = $03
                S_HARDWARE_ERROR    = $04
                S_ILLEGAL_REQUEST   = $05
                S_UNIT_ATTENTION    = $06
                S_KEY_UNKNOWN       = $07
{
                S_DATA_PROTECT      = $07
                S_BLANK_CHECK       = $08
                S_VENDOR_SPECIFIC   = $09
                S_COPY_ABORTED      = $0a
                S_ABORTED_COMMAND   = $0b
                S_VOLUME_OVERFLOW   = $0d
                S_MISCOMPARE        = $0e
                S_COMPLETED         = $0f
}
' Recognized ASC/ASCQ code combinations:
                ASC_Q_NO_INFO            = $0000
                ASC_Q_PD_WRITE_FAULT     = $0003
                ASC_Q_FATAL_READ_ERROR   = $0011
                ASC_Q_INVALID_CMD_OPCODE = $0020
                ASC_Q_LBA_OUT_OF_RANGE   = $0021
                ASC_Q_WRITE_PROTECTED    = $0027
                ASC_Q_NOTRDY_RDY_CHANGE  = $0028
                ASC_Q_MEDIUM_NOT_PRESENT = $003a
                ASC_Q_UNKNOWN            = $ffff
'------------------------------------------------------------------------------
' SEND DIAGNOSTIC (in practice rarely used by host):
                CMD_SEND_DIAGNOSTIC = $1d
                SEND_DIAG_CBLEN     = $06
'------------------------------------------------------------------------------
' TEST UNIT READY:
                CMD_TEST_UNIT_READY = $00
                TEST_UNIT_RDY_CBLEN = $06
'------------------------------------------------------------------------------
' WRITE(10):
                CMD_WRITE10         = $2a
                WRITE10_CBLEN       = $0a
' CBW bitmasks:
                WRPROTECT           = %111_0_0_0_00
'               DPO                 = %000_1_0_0_00 ' Same as READ(10)
'               FUA                 = %000_0_1_0_00
                ROO                 = %000_0_0_1_11 ' Reserved, obsolete, obsolete
' CBW parameter offsets:
                bmWR10_WRProtect    = 1
                bWR10_LBAddr        = 2         ' 4-byte field, big endian
                bmWR10_GroupNumber  = 6
                bWR10TransferLen    = 7         ' 2-byte field, big endian
              ' CONTROL             = 9
'------------------------------------------------------------------------------
' Master Boot Record Sector:

' #endregion Mass storage constants
' #region Structures and data buffers
dat
                orgh
                alignl
'------------------------------------------------------------------------------
' Mass storage class Command Block Wrapper (CBW) structure:
'------------------------------------------------------------------------------
' Command Block Wrapper (CBW) structure
CBWStruct
                        long    CBWSignature ' "USBC": signature value is defined by USB
                        long    0       ' Driver-created value that the device must echo back in the bulk transfer's CSW
                        long    0       ' Expected IN/OUT data bytes. If zero, no USB data stage between the CBW and CSW transfers
                        byte    0       ' Bit 7 is transfer direction (1 = IN); bits 6..0 must be zero
                        byte    0       ' LUN to address (zero, unless the device supports multiple LUNs)
                        byte    0       ' Valid length of CBWCB. Only values $01..$10 are valid
CBWCB                   byte    0[16]   ' The command block to execute. The first byte is at structure offset bCBWCB
                                        ' The device shall ignore content of the bCBWCB field past (CBWCB + bCBWBLen - 1)
' Command Status Wrapper (CSW) structure:
CSWStruct
                        long    0       ' This field must echo the CBW signature "USBC"
                        long    0       ' Device sets this field to the associated CBW dCBWTag value that was received
                        long    0       ' Difference between the amount of data expected and actual to/from host
                        byte    0       ' Command status code: CBS_CMD_SUCCESS, CBS_CMD_FAILED, CBS_PHASE_ERROR
' Verbose output header strings:
sz_csw                  byte    "Status:", 0
sz_cmd_data             byte    "Data:", 0
sz_cmd_nodata           byte    "No data...", 0
sz_bulkin_stall         byte    "Bulk-IN endpoint STALL...", 0
sz_bulkout_stall        byte    "Bulk-OUT endpoint STALL...", 0
sz_stall_recovery       byte    "STALL recovery: ", 0
sz_csw_status           byte    "SCSI command error: ", 0
sz_asc                  byte    "ASC: 0x", 0
sz_ascq                 byte    ", ASCQ: 0x", 0
' CSW status codes (indexed 0..n):
sz_csw_passed           byte    "Passed", 0
sz_csw_failed           byte    "Failed", 0
sz_csw_phase_error      byte    "Phase error", 0
sz_csw_size_error       byte    "Invalid CSW length", 0
sz_csw_bad_signature    byte    "Invalid CSW signature", 0
sz_csw_tag_error        byte    "CBW->CSW tag mismatch", 0
sz_csw_residue_error    byte    "CSW residue overflow", 0
csw_error_ptr           long    sz_csw_passed, sz_csw_failed, sz_csw_phase_error, sz_csw_size_error
                        long    sz_csw_bad_signature, sz_csw_tag_error, sz_csw_residue_error
' Recognized sense key codes (indexed 0..n):
sz_s_no_sense           byte    "No sense", 0
sz_s_recovered_error    byte    "Recovered error", 0
sz_s_not_ready          byte    "Device not ready", 0
sz_s_medium_error       byte    "Medium error", 0
sz_s_hardware_error     byte    "Hardware error", 0
sz_s_illegal_request    byte    "Illegal request", 0
sz_s_unit_attention     byte    "Unit requires attention", 0
sz_s_unknown_sense_key  byte    "Unknown sense key", 0
sz_s_error_ptr          long    sz_s_no_sense, sz_s_recovered_error, sz_s_not_ready
                        long    sz_s_medium_error, sz_s_hardware_error, sz_s_illegal_request
                        long    sz_s_unit_attention, sz_s_unknown_sense_key
' Recognized sense ASC/ASCQ code combinations:
sz_no_additional_info   byte    "no additional sense information", 0
sz_write_fault          byte    "peripheral device write fault", 0
sz_fatal_read_err       byte    "unrecovered read error", 0
sz_invalid_opcode       byte    "invalid command opcode", 0
sz_lba_out_of_range     byte    "LBA out of range", 0
sz_write_protected      byte    "write protected", 0
sz_notrdy_rdy_change    byte    "not ready to ready change, or medium may have changed", 0
sz_medium_not_present   byte    "medium not present", 0
sz_asc_q_unknown        byte    "unrecognized ASC/ASCQ code combination", 0
asc_error_ptr           long    sz_no_additional_info, sz_write_fault, sz_fatal_read_err
                        long    sz_invalid_opcode, sz_lba_out_of_range, sz_write_protected
                        long    sz_notrdy_rdy_change, sz_medium_not_present, sz_asc_q_unknown
asc_ascq_codes          word    ASC_Q_NO_INFO, ASC_Q_PD_WRITE_FAULT, ASC_Q_FATAL_READ_ERROR
                        word    ASC_Q_INVALID_CMD_OPCODE, ASC_Q_LBA_OUT_OF_RANGE, ASC_Q_WRITE_PROTECTED
                        word    ASC_Q_NOTRDY_RDY_CHANGE, ASC_Q_MEDIUM_NOT_PRESENT, ASC_Q_UNKNOWN
'------------------------------------------------------------------------------
' Header strings for verbose terminal output, and command block parameter
' buffers for implemented SCSI command codes:
'------------------------------------------------------------------------------
sz_req_max_lun          byte    "RequestMaxLUN(): ", 0
sz_sec_size             byte    "Sector size: ", 0
sz_ptn_type             byte    "Partition type: 0x", 0
sz_clus_size            byte    "Cluster size: ", 0
sz_vol_base             byte    "Volume base sector: ", 0
sz_rsvd_sec_cnt         byte    "Reserved sector count: ", 0
sz_root_dir_sec_cnt     byte    "RootDir sector count: ", 0
sz_fat_size             byte    "Sector count of one FAT: ", 0
sz_fat_sec_cnt          byte    "FAT region sector count: ", 0
sz_fat_base             byte    "FAT region base sector: ", 0
sz_fsinfo_base          byte    "FSInfo base sector (in reserved): ", 0
sz_root_clus_num        byte    "RootDir cluster#: ", 0
sz_root_dir_base        byte    "RootDir base sector: ", 0
sz_dfd_base             byte    "Dir/file/data base sector: ", 0
sz_dfd_secs             byte    "Count of data region sectors: ", 0
sz_dfd_clus             byte    "Count of data region clusters: ", 0
sz_free_clus            byte    "Count of free clusters: ", 0
sz_fsi_free_clus        byte    "FSInfo free clusters: ", 0
sz_fsi_nxt_free         byte    "FSInfo next free cluster: ", 0
sz_vol_secs             byte    "Count of volume sectors: ", 0
sz_unused_secs          byte    "Unused sectors: ", 0
sz_vol_overrun          byte    "Volume overrun!: ", 0
sz_cmd_retry            byte    "Command retry...", 0
sz_srch_filesys         byte    "Checking media for a FAT file system...", 0
sz_unknown_partition    byte    "Unsupported partition type: 0x", 0
sz_vol_fat16            byte    "FAT16 volume mounted.", 0
sz_vol_fat32            byte    "FAT32 volume mounted.", 0
sz_no_fat_ptn           byte    "No FAT16 or FAT32 volume found.", 0
sz_msd_mount_fail       byte    "Unable to mount this device.", 0
sz_dirent_invalid       byte    "Invalid directory entry: ", 0
sz_bad_path             byte    "Cannot find the directory specified.", 0
sz_file_read_err        byte    "File read error.", 0
sz_file_write_err       byte    "File write error.", 0
sz_mbr0                 byte    "MBR0", 0
sz_ptn_bpb              byte    "Partition BPB", 0
sz_fsinfo               byte    "FSInfo", 0
sz_fat                  byte    "Scanning FAT region.", 0
sz_dir_base             byte    "RootDir", 0
sz_fdd_base             byte    "File and directory data", 0
sz_format_info          byte    "Format info: ", 0
sz_highest_lba          byte    "Highest LBA: ", 0
sz_removable            byte    "Media is removable", 0
sz_not_removable        byte    "Media not removable", 0
sz_is_spc               byte    "SCSI version is ANSI X3.131:1994 (SCSI-2) or higher", 0
sz_not_spc              byte    "Device does not claim conformance to any SPC standard", 0
sz_vendor_id            byte    "Vendor ID: ", 0
sz_product_rev          byte    "Product ID: ", 0
sz_version_level        byte    "Version level: ", 0
sz_inquiry              byte    "INQUIRY(6): ", 0
cb_inquiry              byte    CMD_INQUIRY, 0[INQUIRY_CBLEN - 1]
sz_read10               byte    "READ(10): ", 0
cb_read10               byte    CMD_READ10, 0[READ10_CBLEN - 1]
sz_read_capacity10      byte    "READ CAPACITY(10): ", 0
cb_read_capacity10      byte    CMD_READ_CAPACITY10, 0[RD_CAP10_CBLEN - 1]
sz_rd_fmt_capacities    byte    "READ FORMAT CAPACITIES(10): ", 0
cb_rd_fmt_capacities    byte    CMD_RDFMTCAPS, 0[RDFMTCAPS_CBLEN - 1]
sz_request_sense        byte    "REQUEST SENSE(6): ", 0
cb_request_sense        byte    CMD_REQUEST_SENSE, 0[REQ_SENSE_CBLEN - 1]
sz_test_unit_ready      byte    "TEST UNIT READY(6): ", 0
cb_test_unit_ready      byte    CMD_TEST_UNIT_READY, 0[TEST_UNIT_RDY_CBLEN - 1]
sz_write10              byte    "WRITE(10): ", 0
cb_write10              byte    CMD_WRITE10, 0[WRITE10_CBLEN - 1]
{ Reference...
'------------------------------------------------------------------------------
' SCSI fixed size Command Blocks. If a parameter is not required, its structure
' member must be set to zero.
'------------------------------------------------------------------------------
CB10Command             byte    0       ' As the name suggests, always 10 bytes in length
CB10MI_SA               byte    0       ' Bits 7..5 misc CDB info, bits 4..0 SERVICE ACTION (if required)
CB10LBA                 long    0       ' Transmitted as big endian, if required
CB10MI                  byte    0       ' Miscellaneous CDB information
CB10Length              word    0       ' Transfer/parameter list/allocation length
                                        ' Transmitted as big endian, if required
CB10Control             byte    0
}

'------------------------------------------------------------------------------
' Standard INQUIRY response data format shall contain at least 36 bytes:
'------------------------------------------------------------------------------
InquiryData             byte    0[MAX_INQ_LEN]
'------------------------------------------------------------------------------
' READ CAPACITY10 response buffer:
'------------------------------------------------------------------------------
RdCapacity10            byte    0[RD_CAP10_DATA_LEN]
'------------------------------------------------------------------------------
' READ FORMAT CAPACITIES response buffer:
'------------------------------------------------------------------------------
RdFmtCapacities         byte    0[RDFMTCAPS_DATA_MAX]
'------------------------------------------------------------------------------
' Standard REQUEST SENSE response data can be as large as 254 bytes:
'------------------------------------------------------------------------------
RequestSenseData
                        byte    0[SENSE_DATA_MAX_LEN]
' REQUEST SENSE has its own CSW:
CSWRequestSense
                        long    0       ' This field must echo the CBW signature "USBC"
                        long    0       ' Device sets this field to the associated CBW dCBWTag value that was received
                        long    0       ' Difference between the amount of data expected and actual to/from host
                        byte    0       ' Command status code: CBS_CMD_SUCCESS, CBS_CMD_FAILED, CBS_PHASE_ERROR
'------------------------------------------------------------------------------
' Parameter blocks for mass storage bulk-only IN/OUT transfer
'------------------------------------------------------------------------------
mass_storage_start
ctrl_io_max_pkt         byte    0                       ' Max packet size for control IN/OUT data
kbd_intf_idx            byte    0
mouse_intf_idx          byte    0
bulk_io_intf_idx        byte    0                       ' Bulk IN/OUT interface index (zero-based)
msd_max_lun             byte    0                       ' Maximum LUN count reported by device
' Data IN parameter block (labels must be kept in this order!)
datain_ep_addr          long    0
datain_next_datax       long    0                       ' DATAx PID to expect on the next IN data transfer
datain_max_pkt          long    0                       ' Shall be 8, 16, 32 or 64 bytes
datain_total_bytes      long    0                       ' Total IN bytes to be expected
datain_buff_ptr         long    0                       ' Hub RAM pointer to the IN buffer sized to at least total_bytes
' Data OUT parameter block (labels must be kept in this order!)
dataout_ep_addr         long    0
dataout_next_datax      long    0                       ' DATAx PID to start the next OUT data transfer
dataout_max_pkt         long    0                       ' Shall be 8, 16, 32 or 64 bytes
dataout_total_bytes     long    0                       ' Total OUT bytes to be transferred
dataout_buff_ptr        long    0                       ' Hub RAM pointer to the OUT buffer sized to at least total_bytes
last_pkt_cnt            long    0                       ' DEBUG
mass_storage_end
'------------------------------------------------------------------------------
' The USB data cache area gets zero-filled at every device disconnect
'------------------------------------------------------------------------------
usb_cache_start
urx_buff                byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
dev_desc_buff           byte    0[DEV_DESC_LEN]         ' Device descriptor
con_desc_buff           byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain
usb_cache_end
'------------------------------------------------------------------------------
boms_sector_buff        byte    $dd[SECTOR_512]         ' Scratch buffer
boms_fsinfo_buff        byte    $dd[SECTOR_512]         ' FSInfo structure
boms_fat_buff           byte    $dd[SECTOR_512]         ' FAT region cluster entry search buffer
boms_dir_buff           byte    $dd[DIR_BUFF_LEN]       ' Cache up to 1024 32-byte directory entries
boms_cluster_buff       byte    $dd[SECTOR_512 * 64]    ' This driver supports up to 32KB data cluster size
'------------------------------------------------------------------------------
' #endregion Structures and data buffers
' #endregion DAT (Hub RAM Strings & Buffers)
'------------------------------------------------------------------------------
' #region Mass storage and FAT file system stuff
con
'------------------------------------------------------------------------------
' BOMS/FAT file system constants:
'------------------------------------------------------------------------------
' Supported sector sizes and fixed buffer sizes:
        SECTOR_512       = 512
        DIR_BUFF_LEN     = SECTOR_512 * 64
' Currently supported FAT partition types:
'        FAT12_LE16MB       = $01        ' <= 16MB
'        FAT16_GE16MB_L32MB = $04        ' >= 16MB and < 32MB
        F16_32MB_2GB     = $06          ' 32MB to 2GB
        F32_512MB_2TB    = $0b          ' 512MB to 2TB
        F32_LBA_LE2TB    = $0c          ' LBA: 512MB to 2TB
        F16_LBA_32MB_2GB = $0e          ' LBA: 32MB to 2GB
' Values used to determine FAT type:
        FAT12_MAGIC      = 4085
        FAT16_MAGIC      = 65525
        MAX_CLUSTER_SIZE = 32 * 1024    ' Cluster size > 32KB is a compatibility no-no
        EXT_BOOT_SIG     = $29          ' Extended boot signature value
        MBR_55_AA        = $aa55        ' Reversed, as MBR speaks little endian
' Bios Parameter Block data offsets:
        wBPB_BytsPerSec  = 11
        bBPB_SecPerClus  = 13
        wBPB_RsvdSecCnt  = 14
        bBPB_NumFATs     = 16           ' Count of FAT data structures on the volume (should be 2)
        wBPB_RootEntCnt  = 17           ' Count of 32-byte directory entries in the root directory, zero if FAT32
        wBPB_TotSec16    = 19           ' If this field is zero, the total sector count is at offset 32
        wBPB_FATSz16     = 22           ' If this field is zero, use the lBPB_FATSz32 field for sectors per FAT
        lBPB_TotSec32    = 32           ' If non-zero, this is a total sector count for both FAT16 and FAT32
' Offsets 36+ differ between FAT16 and FAT32
' FAT16 BPB/boot sector offsets 36+:
        bBS16_BootSig    = 38           ' Extended boot signature ($29) that indicates the following three fields are present
        lBS16_VolID      = 39           ' Volume serial number and label together are useful in tracking removable media
        nBS16_VolLab11   = 43           ' Volume label which should match the label in the root directory
        nBS16_FSType8    = 54           ' One of "FAT12   ", "FAT16   ", or "FAT     " - DO NOT USE TO IDENTIFY FAT TYPE
' FAT32 BPB/boot sector offsets 36+:
        lBPB_FATSz32     = 36           ' 32-bit sectors per FAT
        wBPB_ExtFlags    = 40           ' FAT mirroring control bitmask
        wBPB_FSVer       = 42           ' FAT32 major.minor revision number - DO NOT MOUNT VOLUME if > 0.0
        lBPB_RootClus    = 44           ' Cluster number of the first cluster of the root directory, usually 2
        wBPB_FSInfo      = 48           ' Sector# of the FSINFO structure in the reserved area of the volume
        bBS32_BootSig    = 66           ' Same definition as FAT16
        lBS32_VolID      = 67           ' ""
        nBS32_VolLab11   = 71           ' ""
        nBS32_FSType8    = 82           ' Always set to "FAT32   " - DO NOT USE TO IDENTIFY FAT TYPE
' Partition table region:
        PTN_TBL_BASE     = 446          ' MBR offset to the base address of the partition table
        PTN_ENTRY_LEN    = 16           ' Max of four 16-byte entries
' Partition entry offsets:
        bPtnActive       = 0
        bPtnType         = 4
        lPtnBaseSector   = 8            ' LBA: sector# of the partition's first sector
                                        ' as an offset from the MBR sector (physical sector zero)
        lPtnTotalSectors = 12           ' Total number of sectors in the partition
        wMBRSignature0   = 64           ' MBR signature relative to the base of the partition table
        wMBRSignature1   = 510          ' MBR signature relative to the start of the MBR
' FSInfo constants:
        FSI_LEAD_SIG     = $41615252    ' Used to identify the FSInfo sector
        FSI_STRUC_SIG    = $61417272    ' Another signature closer to the most-used FSInfo fields
        FSI_TRAIL_SIG    = MBR_55_AA << 16 ' Final signature for FAT32 verification
' FSInfo field offsets:
        lFSI_LeadSig     = 0            ' FSI_LEAD_SIG
        nFSI_Reserved480 = 4            ' 480 bytes reserved, code must initialize to zero
        lFSI_StrucSig    = 484          ' FSI_STRUC_SIG
        lFSI_FreeCount   = 488          ' Last known free cluster count on the volume. $ffffffff if unknowned
                                        ' and it must be calculated. The value may not be correct, so it should
                                        ' be ranged checked to make sure it's <= the volume cluster count
        lFSI_NxtFree     = 492          ' Indicates the cluster number the driver should use to start looking for
                                        ' free clusters. If $ffffffff the driver should start looking at cluster 2
                                        ' It also should be validated as <= the volume cluster count before use
        nFSI_Reserved12  = 496          ' 12 bytes reserved, code must initialize to zero
        lFSI_TrailSig    = 508          ' FSI_TRAIL_SIG
' Directory entry constants:
        FAT16_EOC_MINVAL    = $fff8     ' Tested as: if(ClusterNum >= *_EOC_MARK) IsEOF = TRUE;
        FAT16_EOC_SET       = $ffff     ' Use *_EOC_SET value when marking FAT cluster entries as EOC
        FAT_EOC_MINVAL      = $0ffffff8
        FAT32_EOC_SET       = $0fffffff
        FILE_EOF            = $ffffffff ' End-of-file test to use for both FAT16 and FAT32 file operations
        FAT32_CLUSRSVD_MASK = $f0000000 ' Preserve the high nibble WHEN WRITING a cluster#
        FAT16_BAD_CLUS      = $fff7     ' FAT16 bad cluster mark
        FAT_BAD_CLUS        = $0ffffff7 ' FAT32 bad cluster mark (remember to preserve high nibble)
        DIR_ENTRY_SIZE      = 32        ' Size of one directory entry
        LAST_LONG_ENTRY     = $40       ' LDIR_Ord field for last long entry == N | LAST_LONG_ENTRY
        DIR_ENTRY_KANJ      = $05       ' DIR_Name[0]: actual file name character (KANJI lead byte)
        DIR_ENTRY_FREE      = $e5       ' DIR_Name[0]: the entry is free (no file or directory name in the entry
        SHORTNAME_SIZE      = 11        ' Maximum length of a "short" file/directory name and extension
        SHORTNAME_PATH_SIZE = 80        ' Total path length of a short name (64 path + 3 drive letter + 8.3 + NUL)
        LONGNAME_PATH_SIZE  = 260       ' Maximum path length of a long name, including trailing NUL
        CLN_SHUT_BITMASK16  = $8000     ' FAT16: if bit is 1, volume is clean else not dismounted properly
        HRD_ERR_BITMASK16   = $4000     ' FAT16: if bit is 1, no disk read/write errors were encountered
        CLN_SHUT_BITMASK32  = $08000000 ' As above, but FAT32
        HRD_ERR_BITMASK32   = $04000000 ' As above, but FAT32
' Directory entry type bit positions:
        #0, DIR_EOFB, DIR_FREEB, DIR_VOL_LABELB, DIR_LNAME_SUBCOMPB
        DIR_DIRECTORYB, DIR_FILEB, DIR_INVALIDB, DIR_OVERFLOWB
' Directory entry type flags:
        DIR_EOFF           = |< DIR_EOFB
        DIR_FREEF          = |< DIR_FREEB
        DIR_VOL_LABELF     = |< DIR_VOL_LABELB
        DIR_LNAME_SUBCOMPF = |< DIR_LNAME_SUBCOMPB
        DIR_DIRECTORYF     = |< DIR_DIRECTORYB
        DIR_FILEF          = |< DIR_FILEB
        DIR_INVALIDF       = |< DIR_INVALIDB
        DIR_OVERFLOWF      = |< DIR_OVERFLOWB
' Directory entry type bitmasks:
        ENTMATCH_ALL      = %001111110
        ENTMATCH_FILE_DIR = DIR_FILEF | DIR_DIRECTORYF
' File attribute bit positions:
        #0, ATTR_READ_ONLYB, ATTR_HIDDENB, ATTR_SYSTEMB, ATTR_VOLUME_IDB
        ATTR_DIRECTORYB, ATTR_ARCHIVEB
' File attribute flags:
        ATTR_READ_ONLYF = |< ATTR_READ_ONLYB
        ATTR_HIDDENF    = |< ATTR_HIDDENB
        ATTR_SYSTEMF    = |< ATTR_SYSTEMB
        ATTR_VOLUME_IDF = |< ATTR_VOLUME_IDB
        ATTR_DIRECTORYF = |< ATTR_DIRECTORYB
        ATTR_ARCHIVEF   = |< ATTR_ARCHIVEB
' Useful file attribute bitmasks:
        ATTR_SHORTNAME     = %00_0_1_1_1_1_0 ' Flags & attrs = 0 if a short file name
        ATTR_SHORTNAME_HID = %00_0_1_1_1_0_0 ' As above plus includes hidden files
        ATTR_LONGNAME      = %00_0_0_1_1_1_1 ' $0f & attrs = $0f if the entry is a long file name
        ATTR_LONGNAME_MASK = %00_1_1_1_1_1_1 ' Used to identify long-name sub-components
' Date bitmasks:
        DATE_DOM_MASK      = %0000000_0000_11111 ' Day of month, 1-31 inclusive
        DATE_MOY_MASK      = %0000000_1111_00000 ' Month of year, 1 == January, 1-12 inclusive
        DATE_YEARS_MASK    = %1111111_0000_00000 ' Count of years since 1980, 0-127 (1980-2107)
' Time bitmasks, valid range Midnight 00:00:00 to 23:59:58
        TIME_SECONDS_MASK  = %00000_000000_11111 ' 2-second count, valid range 0-29 inclusive (0-58 seconds)
        TIME_MINUTES_MASK  = %00000_111111_00000 ' Minutes, valid range 0-59 inclusive
        TIME_HOURS_MASK    = %11111_000000_00000 ' Hours, valid range 0-23 inclusive
' Short name directory entry fields:
' DIR_Name[0] may not equal $20
        nDIR_Name11       = 0   ' Upper case only
        bDIR_Attr         = 11  ' Bits 0..8: Read_Hidden_System_Vlabel_Dir_Archive_0_0
        bDIR_NTRes        = 12  ' Set to zero when a file is created and never modify or look at it
        bDIR_CrtTimeTenth = 13  ' Creation time tenths of a second, value range 0-199 inclusive
        wDIR_CrtTime      = 14  ' Time file was created
        wDIR_CrtDate      = 16  ' Date file was created
        wDIR_LstAccDate   = 18  ' Last access date; should be set same as wDIR_WrtDate
        wDIR_FstClusHI    = 20  ' High word of this entry's first cluster number (0 for FAT12/16)
        wDIR_WrtTime      = 22  ' Time of last write, which includes creation
        wDIR_WrtDate      = 24  ' Date of last write, which includes creation
        wDIR_FstClusLO    = 26  ' For FAT16, first data cluster number, for FAT32, low word of the first cluster
        lDIR_FileSize     = 28  ' The file size in bytes
' Long name directory entry fields:
        bLDIR_Ord        = 0    ' Always check this field when determining an entry type
        nLDIR_Name1_10   = 1
        bLDIR_Attr       = 11
        bLDIR_Type       = 12
        bLDIR_Chksum     = 13   ' Checksum of name in the short dir entry at the end of the long dir set.
        nLDIR_Name2_12   = 14   ' Characters 6-11 of the long-name sub-component
        wLDIR_FstClusLO  = 26   ' Must be ZERO as it's meaningless in a long-name context
        nLDIR_Name3_4    = 28   ' Characters 12-13 of the long-name sub-component
' Unicode -> UTF-8 constants:
        UTF8_C2          = $c2  ' $c2 + $80..$bf covers U+0000..U+00ff code point (Basic Latin)
        UTF8_C3          = $c3  ' $c3 + $80..$bf
'------------------------------------------------------------------------------
dat
sz_cmd_unknown          byte    "Command not recognized.", 0
sz_cmd_fail             byte    "Command failed.", 0
sz_cmd_bad_syntax       byte    "Command syntax incorrect.", 0
sz_longname_subcomp     byte    "Long name sub-component", 0
sz_access_denied        byte    "Access is denied.", 0
sz_no_media             byte    "No media present", 0
sz_media_present        byte    "Media present and ready", 0
sz_entry_label          byte    "Volume label: ", 0
sz_vol_serial_num       byte    "Serial number: ", 0
sz_directory_of         byte    " Directory of ", 0
sz_dir_pad              byte    "       ", 0
sz_lbracket             byte    "[", 0
sz_dirw_pre             byte    "  [", 0
sz_filew_pre            byte    "  ", 0
sz_filew_post           byte    "  ", 0
sz_entry_dir            byte    "    <DIR>         ", 0
sz_dir_match_dotdot     byte    "..          ", 0
sz_dir_match_all        byte    "???????????", 0
sz_path_separator       byte    "/\", 0
sz_file_not_found       byte    "File Not Found", 0
sz_entry_overflow       byte    "Entry overflow!", 0
sz_cur_data_clus        byte    "Data clus number: ", 0      ' dcur_data_clus
sz_data_clus_sec        byte    "Data clus sector#: ", 0     ' cbw0 = data region sector# that contains cluster#
sz_clus_fat_ent_sec     byte    "Cluster FAT entry sec#: ", 0 ' cbw0 = FAT region sector# that contains entry offset
sz_clus_ent_offset      byte    "Clus entry offset bytes: ", 0 ' dclus_offset = FAT cluster entry value offset
sz_clus_ent_val         byte    "Clus entry value: ", 0
sz_force_fatscan        byte    "The free cluster count is marked as unknown. Calculating now...", CR ' output next line too
sz_scanfat_adj          byte    "Free cluster count adjustment: ", 0
sz_fsinfo_updated       byte    "FSInfo data updated.", 0
sz_media_write_fail     byte    "Media write failed.", 0
sz_media_read_fail      byte    "Media read failed.", 0
sz_am                   byte    " AM", 0
sz_pm                   byte    " PM", 0
sz_num_files            byte    " File(s) ", 0
sz_num_dirs             byte    " Dir(s) ", 0
sz_total_bytes          byte    " bytes", 0
sz_bytes_free           byte    " bytes free", 0
sz_dir_invalid_chars    byte    $22, "*+,./:;<=>?[\]|", 0
sz_dec64_buff           byte    0[21 + 6 + 1]           ' Buffer for 64-bit hex->decimal formatted string
sz_cur_path             byte    "#:\", 0[LONGNAME_PATH_SIZE - 3]   ' Total longname path size including trailing NUL
con_rx_buff             byte    0[CMD_LINE_MAX_SIZE]    ' Terminal rx buffer
con_cmd_buff            byte    0[CMD_NAME_MAX_SIZE]    ' Command word buffer
con_par_buff            byte    0[CMD_LINE_MAX_SIZE - CMD_NAME_MAX_SIZE] ' Command parameter buffer, converted to uppercase
shortname_buff          byte    0[SHORTNAME_SIZE + 4] ' 8 + dot + 3 + nul
match_pattern_buff      byte    0[SHORTNAME_SIZE + 2] ' 8 + 4 + nul
longname_entry_cache    byte    0[DIR_ENTRY_SIZE * 20] ' 255 byte max longname needs this many dir entries
vol_serial_num          long    0
sz_vol_label            byte    0[SHORTNAME_SIZE + 1]
' Recognized console commands:
con_cmd_list            byte    3, "CLS", 0, 3, "DIR", 0, 4, "DIRW", 0, 6, "TGLDBG", 0, 3, "CAT", 0, 4, "TYPE", 0
                        byte    7, "MONITOR", 0, 2, "CD", 0, 7, "SCANFAT", 0, 6, "GETSEC", 0, 6, "PUTSEC", 0
                        byte    4, "TEST", 0[2]
'termtype_list           byte    3, "PST", 0, 5, "VT100", 0[2]
' #endregion FAT file system stuff
{{
+----------------------------------------------------------------------------------------------------------------------+
|                                             TERMS OF USE: MIT License                                                |
+----------------------------------------------------------------------------------------------------------------------+
|Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated          |
|documentation files (the "Software"), to deal in the Software without restriction, including without limitation the   |
|rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit|
|persons to whom the Software is furnished to do so, subject to the following conditions:                              |
|                                                                                                                      |
|The above copyright notice and this permission notice shall be included in all copies or substantial portions of the  |
|Software.                                                                                                             |
|                                                                                                                      |
|THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE  |
|WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR |
|COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR      |
|OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.      |
+----------------------------------------------------------------------------------------------------------------------+
}}
