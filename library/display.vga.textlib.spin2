CON
  STATE_NORMAL = 0
  STATE_ESCAPE = 1
  STATE_CSI = 2
  MAX_ESC_ARGS = 8

  CHAR_INVERSE = $01
  CHAR_BOLD = $02

  DEFAULT_FG_COLOR = $FFFFFF00
  DEFAULT_BG_COLOR = 0
  
VAR
  long curx, cury       ' cursor position
  long savex, savey
  long bgcolor, fgcolor ' current color
  long state
  long screenptr
  long args[MAX_ESC_ARGS]
  long argidx
  long char_effects
  
PRI init_terminal
  reset_graphics_state
  cls
  curx := cury := 0
  state := STATE_NORMAL
  screenptr := @screen_buffer

PRI reset_graphics_state
  bgcolor := DEFAULT_BG_COLOR
  fgcolor := DEFAULT_FG_COLOR
  char_effects := 0
  
PRI scrollup
  bytemove(screenptr, screenptr + 8*COLS, 8*(ROWS-1)*COLS)
  bytefill(screenptr + 8*(ROWS-1)*COLS, 0, 8*COLS)
  
PRI checkposition
  if curx => COLS
    curx := 0
    cury++
  elseif curx < 0
    curx := 0
  if cury => ROWS
    scrollup
    cury := ROWS-1
  elseif cury < 0
    cury := 0
    
PUB tx(c) | fg, bg
   if (state == STATE_NORMAL)
      if (c == 8) ' backspace
         --curx
      elseif (c == 10) ' line feed
         cury++
      elseif (c == 13) ' carriage return
         curx := 0
      elseif (c == 20) ' tab
         curx := (curx + 8) & ~7
      elseif (c == 27)
         state := STATE_ESCAPE
      else
         fg := fgcolor
         bg := bgcolor
         if char_effects & CHAR_INVERSE
           fg,bg := bg,fg  ' swap
         checkposition
         glyphat(curx, cury, c, fg, bg)
         curx++
   elseif (state == STATE_ESCAPE)
      handle_esc(c)
   elseif (state == STATE_CSI)
      handle_csi(c)

PRI handle_esc(c) | i
  if (c == "[")
    repeat i from 0 to MAX_ESC_ARGS-1
      args[i] := 0
    argidx := 0
    state := STATE_CSI
  elseif (c == "c")
    init_terminal
  else
    state := STATE_NORMAL

PRI defaultval(arg, v)
  return (arg) ? arg : v
  
' handle ANSI control sequences
PRI handle_csi(c)
{{
    glyphat(40, 10, c, $ffff0000, $00404000)
    pausems(1000)
}}
    if (c => "0" and c =< "9")
      args[argidx] := 10*args[argidx] + (c - "0")
      return
    argidx++
    if argidx == MAX_ESC_ARGS
      --argidx
    if (c == ";")
      return
    
    if (c == "A")
      cury -= defaultval(args[0], 1)
    elseif (c == "B")
      cury += defaultval(args[0], 1)
    elseif (c == "C")
      curx += defaultval(args[0], 1)
    elseif (c == "D")
      curx -= defaultval(args[0], 1)
    elseif (c == "E")
      cury += defaultval(args[0], 1)
      curx := 0
    elseif (c == "F")
      cury -= defaultval(args[0], 1)
      curx := 0
    elseif (c == "G")
      curx := defaultval(args[0], 1) - 1
    elseif (c == "H")
      cury := defaultval(args[0], 1) - 1
      curx := defaultval(args[1], 1) - 1
    elseif (c == "J")
      clear_in_display(defaultval(args[0], 0))
    elseif (c == "m")
      set_graphic_rendition(0)
    elseif (c == "s")
      savex := curx
      savey := cury
    elseif (c == "u")
      curx := savex
      cury := savey
    state := STATE_NORMAL

PUB glyphat(x, y, ch, fgcol, bgcol) | bufptr
  bufptr := @screen_buffer
  bufptr += (y*COLS + x) *8
  fgcol |= (ch & $FF)
  bgcol &= $FFFFFF00
  long[bufptr] := fgcol
  bufptr += 4
  long[bufptr] := bgcol

PUB cls
   longfill(@screen_buffer, 0, COLS*ROWS*2)

' clear from position a to position b (inclusive)
PRI clear(a, b) | ptr, cnt
  ptr := @screen_buffer + a
  cnt := b-a
  repeat while cnt => 0
    long[ptr] := fgcolor
    ptr += 4
    long[ptr] := bgcolor
    ptr += 4
    --cnt

' clear from cursor to end of display (if n==0) or from start of screen to cursor (n == 1)
' n==2 clears whole display and resets cursor to top
PRI clear_in_display(n) | startpix, endpix
  if n==2
    curx := cury := 0
    n:=0
  if n==1
    startpix := 0
    endpix := COLS*cury + curx
  else
    startpix := COLS*cury + curx
    endpix := COLS*ROWS - 1
  clear(startpix, endpix)

' get an argument that's already been set up, return -1 if not valid
PRI fetcharg(i)
  if i => argidx
    return -1
  return args[i]

' debug routine
PRI hexdig(i)
   if i =< 10
     return i + "0"
   return (i-10) + "A"

PRI set_graphic_rendition(i) | code, a, b
  if i > argidx
    return
  code := fetcharg(i++)

{{  
  a := hexdig(code & $F)
  b := hexdig((code >> 4) & $F)
  glyphat(41, 10, b, $ffffff00, $00202000)
  glyphat(42, 10, a, $ffffff00, $00202000)
  pausems(1000)
}}
  if code == 0
    reset_graphics_state
  elseif code == 1
    char_effects |= CHAR_BOLD
  elseif code == 7
    char_effects |= CHAR_INVERSE
  elseif code == 21
    char_effects &= !CHAR_BOLD
  elseif code == 22
    char_effects &= !CHAR_BOLD
  elseif code == 27
    char_effects &= !CHAR_INVERSE
  elseif code => 30 and code =< 37
    fgcolor := AnsiColor(code - 30)
  elseif code == 38
    fgcolor,i := GetArgColor(i)
  elseif code == 39
    fgcolor := DEFAULT_FG_COLOR
  elseif code => 40 and code =< 47
    bgcolor := AnsiColor(code - 40)
  elseif code == 48
    bgcolor,i := GetArgColor(i)
  elseif code == 49
    bgcolor := DEFAULT_BG_COLOR
  set_graphic_rendition(i)
  
DAT
colortab
  long $00000000, $7F000000, $007F0000, $7F7F0000
  long $00007F00, $7F007F00, $007F7F00, $C0C0C000
  long $7F7F7F00, $FF000000, $00FF0000, $FFFF0000
  long $0000FF00, $FF00FF00, $00FFFF00, $FFFFFFFF

' look up an ANSI color from the color table
PRI AnsiColor(n) | ptr
  if char_effects & CHAR_BOLD
    n += 8
  ptr := @colortab
  return long[ptr + 4*n]

' calculate an RGB color from a 6,6,6 encoded 8 bit color
PRI SixColor(x) | r, g, b
  b := x // 6
  x := x / 6
  g := x // 6
  r := x / 6
  r := (255 * r)/6
  g := (255 * g)/6
  b := (255 * b)/6
  return (r<<24) | (g<<16) | b

' get a color out of arguments
PRI GetArgColor(i) : col, newi | r, g, b, code
  code := fetcharg(i++)
  if code == 0
    return 0, i
  if code == 2
     r := fetcharg(i++) & $FF
     g := fetcharg(i++) & $FF
     b := fetcharg(i++) & $FF
     return (r<<24 | g<<16 | b<<8), i
  if code == 5
    r := fetcharg(i++) & $FF
    if (r =< 15)
      r := colortab[r]
    elseif (r => 232) 
      r := 10 * (r - 232)
      r +- 8
      return (r<<24 | r<<16 | r<<8), i
    else
      r := SixColor(r)
      return r, i
  return 0, i  ' punt for now

   